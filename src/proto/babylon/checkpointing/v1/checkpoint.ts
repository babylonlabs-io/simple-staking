// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: babylon/checkpointing/v1/checkpoint.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { ExtendedCommitInfo } from "../../../tendermint/abci/types";

export const protobufPackage = "babylon.checkpointing.v1";

/** CheckpointStatus is the status of a checkpoint. */
export enum CheckpointStatus {
  /** CKPT_STATUS_ACCUMULATING - ACCUMULATING defines a checkpoint that is awaiting for BLS signatures. */
  CKPT_STATUS_ACCUMULATING = 0,
  /** CKPT_STATUS_SEALED - SEALED defines a checkpoint that has accumulated sufficient BLS signatures. */
  CKPT_STATUS_SEALED = 1,
  /** CKPT_STATUS_SUBMITTED - SUBMITTED defines a checkpoint that is included on BTC. */
  CKPT_STATUS_SUBMITTED = 2,
  /** CKPT_STATUS_CONFIRMED - CONFIRMED defines a checkpoint that is k-deep on BTC. */
  CKPT_STATUS_CONFIRMED = 3,
  /** CKPT_STATUS_FINALIZED - FINALIZED defines a checkpoint that is w-deep on BTC. */
  CKPT_STATUS_FINALIZED = 4,
  UNRECOGNIZED = -1,
}

export function checkpointStatusFromJSON(object: any): CheckpointStatus {
  switch (object) {
    case 0:
    case "CKPT_STATUS_ACCUMULATING":
      return CheckpointStatus.CKPT_STATUS_ACCUMULATING;
    case 1:
    case "CKPT_STATUS_SEALED":
      return CheckpointStatus.CKPT_STATUS_SEALED;
    case 2:
    case "CKPT_STATUS_SUBMITTED":
      return CheckpointStatus.CKPT_STATUS_SUBMITTED;
    case 3:
    case "CKPT_STATUS_CONFIRMED":
      return CheckpointStatus.CKPT_STATUS_CONFIRMED;
    case 4:
    case "CKPT_STATUS_FINALIZED":
      return CheckpointStatus.CKPT_STATUS_FINALIZED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CheckpointStatus.UNRECOGNIZED;
  }
}

export function checkpointStatusToJSON(object: CheckpointStatus): string {
  switch (object) {
    case CheckpointStatus.CKPT_STATUS_ACCUMULATING:
      return "CKPT_STATUS_ACCUMULATING";
    case CheckpointStatus.CKPT_STATUS_SEALED:
      return "CKPT_STATUS_SEALED";
    case CheckpointStatus.CKPT_STATUS_SUBMITTED:
      return "CKPT_STATUS_SUBMITTED";
    case CheckpointStatus.CKPT_STATUS_CONFIRMED:
      return "CKPT_STATUS_CONFIRMED";
    case CheckpointStatus.CKPT_STATUS_FINALIZED:
      return "CKPT_STATUS_FINALIZED";
    case CheckpointStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** RawCheckpoint wraps the BLS multi sig with metadata */
export interface RawCheckpoint {
  /** epoch_num defines the epoch number the raw checkpoint is for */
  epochNum: number;
  /**
   * block_hash defines the 'BlockID.Hash', which is the hash of
   * the block that individual BLS sigs are signed on
   */
  blockHash: Uint8Array;
  /** bitmap defines the bitmap that indicates the signers of the BLS multi sig */
  bitmap: Uint8Array;
  /**
   * bls_multi_sig defines the multi sig that is aggregated from individual BLS
   * sigs
   */
  blsMultiSig: Uint8Array;
}

/** RawCheckpointWithMeta wraps the raw checkpoint with metadata. */
export interface RawCheckpointWithMeta {
  ckpt: RawCheckpoint | undefined;
  /** status defines the status of the checkpoint */
  status: CheckpointStatus;
  /** bls_aggr_pk defines the aggregated BLS public key */
  blsAggrPk: Uint8Array;
  /** power_sum defines the accumulated voting power for the checkpoint */
  powerSum: number;
  /**
   * lifecycle defines the lifecycle of this checkpoint, i.e., each state
   * transition and the time (in both timestamp and block height) of this
   * transition.
   */
  lifecycle: CheckpointStateUpdate[];
}

/** InjectedCheckpoint wraps the checkpoint and the extended votes */
export interface InjectedCheckpoint {
  ckpt: RawCheckpointWithMeta | undefined;
  /**
   * extended_commit_info is the commit info including the vote extensions
   * from the previous proposal
   */
  extendedCommitInfo: ExtendedCommitInfo | undefined;
}

/** CheckpointStateUpdate defines a state transition on the checkpoint. */
export interface CheckpointStateUpdate {
  /** state defines the event of a state transition towards this state */
  state: CheckpointStatus;
  /**
   * block_height is the height of the Babylon block that triggers the state
   * update
   */
  blockHeight: number;
  /**
   * block_time is the timestamp in the Babylon block that triggers the state
   * update
   */
  blockTime: Date | undefined;
}

/** BlsSig wraps the BLS sig with metadata. */
export interface BlsSig {
  /** epoch_num defines the epoch number that the BLS sig is signed on */
  epochNum: number;
  /**
   * block_hash defines the 'BlockID.Hash', which is the hash of
   * the block that individual BLS sigs are signed on
   */
  blockHash: Uint8Array;
  blsSig: Uint8Array;
  /**
   * can't find cosmos_proto.scalar when compiling due to cosmos v0.45.4 does
   * not support scalar string signer_address = 4 [(cosmos_proto.scalar) =
   * "cosmos.AddressString"]
   * the signer_address defines the address of the
   * signer
   */
  signerAddress: string;
  /** validator_address defines the validator's consensus address */
  validatorAddress: string;
}

function createBaseRawCheckpoint(): RawCheckpoint {
  return {
    epochNum: 0,
    blockHash: new Uint8Array(0),
    bitmap: new Uint8Array(0),
    blsMultiSig: new Uint8Array(0),
  };
}

export const RawCheckpoint: MessageFns<RawCheckpoint> = {
  encode(
    message: RawCheckpoint,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.epochNum !== 0) {
      writer.uint32(8).uint64(message.epochNum);
    }
    if (message.blockHash.length !== 0) {
      writer.uint32(18).bytes(message.blockHash);
    }
    if (message.bitmap.length !== 0) {
      writer.uint32(26).bytes(message.bitmap);
    }
    if (message.blsMultiSig.length !== 0) {
      writer.uint32(34).bytes(message.blsMultiSig);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RawCheckpoint {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRawCheckpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.epochNum = longToNumber(reader.uint64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blockHash = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bitmap = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.blsMultiSig = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RawCheckpoint {
    return {
      epochNum: isSet(object.epochNum) ? globalThis.Number(object.epochNum) : 0,
      blockHash: isSet(object.blockHash)
        ? bytesFromBase64(object.blockHash)
        : new Uint8Array(0),
      bitmap: isSet(object.bitmap)
        ? bytesFromBase64(object.bitmap)
        : new Uint8Array(0),
      blsMultiSig: isSet(object.blsMultiSig)
        ? bytesFromBase64(object.blsMultiSig)
        : new Uint8Array(0),
    };
  },

  toJSON(message: RawCheckpoint): unknown {
    const obj: any = {};
    if (message.epochNum !== 0) {
      obj.epochNum = Math.round(message.epochNum);
    }
    if (message.blockHash.length !== 0) {
      obj.blockHash = base64FromBytes(message.blockHash);
    }
    if (message.bitmap.length !== 0) {
      obj.bitmap = base64FromBytes(message.bitmap);
    }
    if (message.blsMultiSig.length !== 0) {
      obj.blsMultiSig = base64FromBytes(message.blsMultiSig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RawCheckpoint>, I>>(
    base?: I,
  ): RawCheckpoint {
    return RawCheckpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RawCheckpoint>, I>>(
    object: I,
  ): RawCheckpoint {
    const message = createBaseRawCheckpoint();
    message.epochNum = object.epochNum ?? 0;
    message.blockHash = object.blockHash ?? new Uint8Array(0);
    message.bitmap = object.bitmap ?? new Uint8Array(0);
    message.blsMultiSig = object.blsMultiSig ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRawCheckpointWithMeta(): RawCheckpointWithMeta {
  return {
    ckpt: undefined,
    status: 0,
    blsAggrPk: new Uint8Array(0),
    powerSum: 0,
    lifecycle: [],
  };
}

export const RawCheckpointWithMeta: MessageFns<RawCheckpointWithMeta> = {
  encode(
    message: RawCheckpointWithMeta,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.ckpt !== undefined) {
      RawCheckpoint.encode(message.ckpt, writer.uint32(10).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.blsAggrPk.length !== 0) {
      writer.uint32(26).bytes(message.blsAggrPk);
    }
    if (message.powerSum !== 0) {
      writer.uint32(32).uint64(message.powerSum);
    }
    for (const v of message.lifecycle) {
      CheckpointStateUpdate.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): RawCheckpointWithMeta {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRawCheckpointWithMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ckpt = RawCheckpoint.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.blsAggrPk = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.powerSum = longToNumber(reader.uint64());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lifecycle.push(
            CheckpointStateUpdate.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RawCheckpointWithMeta {
    return {
      ckpt: isSet(object.ckpt)
        ? RawCheckpoint.fromJSON(object.ckpt)
        : undefined,
      status: isSet(object.status)
        ? checkpointStatusFromJSON(object.status)
        : 0,
      blsAggrPk: isSet(object.blsAggrPk)
        ? bytesFromBase64(object.blsAggrPk)
        : new Uint8Array(0),
      powerSum: isSet(object.powerSum) ? globalThis.Number(object.powerSum) : 0,
      lifecycle: globalThis.Array.isArray(object?.lifecycle)
        ? object.lifecycle.map((e: any) => CheckpointStateUpdate.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RawCheckpointWithMeta): unknown {
    const obj: any = {};
    if (message.ckpt !== undefined) {
      obj.ckpt = RawCheckpoint.toJSON(message.ckpt);
    }
    if (message.status !== 0) {
      obj.status = checkpointStatusToJSON(message.status);
    }
    if (message.blsAggrPk.length !== 0) {
      obj.blsAggrPk = base64FromBytes(message.blsAggrPk);
    }
    if (message.powerSum !== 0) {
      obj.powerSum = Math.round(message.powerSum);
    }
    if (message.lifecycle?.length) {
      obj.lifecycle = message.lifecycle.map((e) =>
        CheckpointStateUpdate.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RawCheckpointWithMeta>, I>>(
    base?: I,
  ): RawCheckpointWithMeta {
    return RawCheckpointWithMeta.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RawCheckpointWithMeta>, I>>(
    object: I,
  ): RawCheckpointWithMeta {
    const message = createBaseRawCheckpointWithMeta();
    message.ckpt =
      object.ckpt !== undefined && object.ckpt !== null
        ? RawCheckpoint.fromPartial(object.ckpt)
        : undefined;
    message.status = object.status ?? 0;
    message.blsAggrPk = object.blsAggrPk ?? new Uint8Array(0);
    message.powerSum = object.powerSum ?? 0;
    message.lifecycle =
      object.lifecycle?.map((e) => CheckpointStateUpdate.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInjectedCheckpoint(): InjectedCheckpoint {
  return { ckpt: undefined, extendedCommitInfo: undefined };
}

export const InjectedCheckpoint: MessageFns<InjectedCheckpoint> = {
  encode(
    message: InjectedCheckpoint,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.ckpt !== undefined) {
      RawCheckpointWithMeta.encode(
        message.ckpt,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.extendedCommitInfo !== undefined) {
      ExtendedCommitInfo.encode(
        message.extendedCommitInfo,
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): InjectedCheckpoint {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInjectedCheckpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ckpt = RawCheckpointWithMeta.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.extendedCommitInfo = ExtendedCommitInfo.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InjectedCheckpoint {
    return {
      ckpt: isSet(object.ckpt)
        ? RawCheckpointWithMeta.fromJSON(object.ckpt)
        : undefined,
      extendedCommitInfo: isSet(object.extendedCommitInfo)
        ? ExtendedCommitInfo.fromJSON(object.extendedCommitInfo)
        : undefined,
    };
  },

  toJSON(message: InjectedCheckpoint): unknown {
    const obj: any = {};
    if (message.ckpt !== undefined) {
      obj.ckpt = RawCheckpointWithMeta.toJSON(message.ckpt);
    }
    if (message.extendedCommitInfo !== undefined) {
      obj.extendedCommitInfo = ExtendedCommitInfo.toJSON(
        message.extendedCommitInfo,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InjectedCheckpoint>, I>>(
    base?: I,
  ): InjectedCheckpoint {
    return InjectedCheckpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InjectedCheckpoint>, I>>(
    object: I,
  ): InjectedCheckpoint {
    const message = createBaseInjectedCheckpoint();
    message.ckpt =
      object.ckpt !== undefined && object.ckpt !== null
        ? RawCheckpointWithMeta.fromPartial(object.ckpt)
        : undefined;
    message.extendedCommitInfo =
      object.extendedCommitInfo !== undefined &&
      object.extendedCommitInfo !== null
        ? ExtendedCommitInfo.fromPartial(object.extendedCommitInfo)
        : undefined;
    return message;
  },
};

function createBaseCheckpointStateUpdate(): CheckpointStateUpdate {
  return { state: 0, blockHeight: 0, blockTime: undefined };
}

export const CheckpointStateUpdate: MessageFns<CheckpointStateUpdate> = {
  encode(
    message: CheckpointStateUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.blockHeight !== 0) {
      writer.uint32(16).uint64(message.blockHeight);
    }
    if (message.blockTime !== undefined) {
      Timestamp.encode(
        toTimestamp(message.blockTime),
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CheckpointStateUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckpointStateUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.blockHeight = longToNumber(reader.uint64());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.blockTime = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckpointStateUpdate {
    return {
      state: isSet(object.state) ? checkpointStatusFromJSON(object.state) : 0,
      blockHeight: isSet(object.blockHeight)
        ? globalThis.Number(object.blockHeight)
        : 0,
      blockTime: isSet(object.blockTime)
        ? fromJsonTimestamp(object.blockTime)
        : undefined,
    };
  },

  toJSON(message: CheckpointStateUpdate): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = checkpointStatusToJSON(message.state);
    }
    if (message.blockHeight !== 0) {
      obj.blockHeight = Math.round(message.blockHeight);
    }
    if (message.blockTime !== undefined) {
      obj.blockTime = message.blockTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckpointStateUpdate>, I>>(
    base?: I,
  ): CheckpointStateUpdate {
    return CheckpointStateUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckpointStateUpdate>, I>>(
    object: I,
  ): CheckpointStateUpdate {
    const message = createBaseCheckpointStateUpdate();
    message.state = object.state ?? 0;
    message.blockHeight = object.blockHeight ?? 0;
    message.blockTime = object.blockTime ?? undefined;
    return message;
  },
};

function createBaseBlsSig(): BlsSig {
  return {
    epochNum: 0,
    blockHash: new Uint8Array(0),
    blsSig: new Uint8Array(0),
    signerAddress: "",
    validatorAddress: "",
  };
}

export const BlsSig: MessageFns<BlsSig> = {
  encode(
    message: BlsSig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.epochNum !== 0) {
      writer.uint32(8).uint64(message.epochNum);
    }
    if (message.blockHash.length !== 0) {
      writer.uint32(18).bytes(message.blockHash);
    }
    if (message.blsSig.length !== 0) {
      writer.uint32(26).bytes(message.blsSig);
    }
    if (message.signerAddress !== "") {
      writer.uint32(34).string(message.signerAddress);
    }
    if (message.validatorAddress !== "") {
      writer.uint32(42).string(message.validatorAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlsSig {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlsSig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.epochNum = longToNumber(reader.uint64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blockHash = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.blsSig = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.signerAddress = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlsSig {
    return {
      epochNum: isSet(object.epochNum) ? globalThis.Number(object.epochNum) : 0,
      blockHash: isSet(object.blockHash)
        ? bytesFromBase64(object.blockHash)
        : new Uint8Array(0),
      blsSig: isSet(object.blsSig)
        ? bytesFromBase64(object.blsSig)
        : new Uint8Array(0),
      signerAddress: isSet(object.signerAddress)
        ? globalThis.String(object.signerAddress)
        : "",
      validatorAddress: isSet(object.validatorAddress)
        ? globalThis.String(object.validatorAddress)
        : "",
    };
  },

  toJSON(message: BlsSig): unknown {
    const obj: any = {};
    if (message.epochNum !== 0) {
      obj.epochNum = Math.round(message.epochNum);
    }
    if (message.blockHash.length !== 0) {
      obj.blockHash = base64FromBytes(message.blockHash);
    }
    if (message.blsSig.length !== 0) {
      obj.blsSig = base64FromBytes(message.blsSig);
    }
    if (message.signerAddress !== "") {
      obj.signerAddress = message.signerAddress;
    }
    if (message.validatorAddress !== "") {
      obj.validatorAddress = message.validatorAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlsSig>, I>>(base?: I): BlsSig {
    return BlsSig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlsSig>, I>>(object: I): BlsSig {
    const message = createBaseBlsSig();
    message.epochNum = object.epochNum ?? 0;
    message.blockHash = object.blockHash ?? new Uint8Array(0);
    message.blsSig = object.blsSig ?? new Uint8Array(0);
    message.signerAddress = object.signerAddress ?? "";
    message.validatorAddress = object.validatorAddress ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
