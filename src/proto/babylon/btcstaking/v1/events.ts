// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: babylon/btcstaking/v1/events.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  BTCDelegationStatus,
  bTCDelegationStatusFromJSON,
  bTCDelegationStatusToJSON,
  SelectiveSlashingEvidence,
} from "./btcstaking";

export const protobufPackage = "babylon.btcstaking.v1";

/** FinalityProviderStatus is the status of a finality provider. */
export enum FinalityProviderStatus {
  /**
   * FINALITY_PROVIDER_STATUS_INACTIVE - FINALITY_PROVIDER_STATUS_INACTIVE defines a finality provider that does not have sufficient
   * delegations or does not have timestamped public randomness.
   */
  FINALITY_PROVIDER_STATUS_INACTIVE = 0,
  /**
   * FINALITY_PROVIDER_STATUS_ACTIVE - FINALITY_PROVIDER_STATUS_ACTIVE defines a finality provider that have sufficient delegations
   * and have timestamped public randomness.
   */
  FINALITY_PROVIDER_STATUS_ACTIVE = 1,
  /** FINALITY_PROVIDER_STATUS_JAILED - FINALITY_PROVIDER_STATUS_JAILED defines a finality provider that is jailed due to downtime */
  FINALITY_PROVIDER_STATUS_JAILED = 2,
  /** FINALITY_PROVIDER_STATUS_SLASHED - FINALITY_PROVIDER_STATUS_SLASHED defines a finality provider that is slashed due to double-sign */
  FINALITY_PROVIDER_STATUS_SLASHED = 3,
  UNRECOGNIZED = -1,
}

export function finalityProviderStatusFromJSON(
  object: any,
): FinalityProviderStatus {
  switch (object) {
    case 0:
    case "FINALITY_PROVIDER_STATUS_INACTIVE":
      return FinalityProviderStatus.FINALITY_PROVIDER_STATUS_INACTIVE;
    case 1:
    case "FINALITY_PROVIDER_STATUS_ACTIVE":
      return FinalityProviderStatus.FINALITY_PROVIDER_STATUS_ACTIVE;
    case 2:
    case "FINALITY_PROVIDER_STATUS_JAILED":
      return FinalityProviderStatus.FINALITY_PROVIDER_STATUS_JAILED;
    case 3:
    case "FINALITY_PROVIDER_STATUS_SLASHED":
      return FinalityProviderStatus.FINALITY_PROVIDER_STATUS_SLASHED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FinalityProviderStatus.UNRECOGNIZED;
  }
}

export function finalityProviderStatusToJSON(
  object: FinalityProviderStatus,
): string {
  switch (object) {
    case FinalityProviderStatus.FINALITY_PROVIDER_STATUS_INACTIVE:
      return "FINALITY_PROVIDER_STATUS_INACTIVE";
    case FinalityProviderStatus.FINALITY_PROVIDER_STATUS_ACTIVE:
      return "FINALITY_PROVIDER_STATUS_ACTIVE";
    case FinalityProviderStatus.FINALITY_PROVIDER_STATUS_JAILED:
      return "FINALITY_PROVIDER_STATUS_JAILED";
    case FinalityProviderStatus.FINALITY_PROVIDER_STATUS_SLASHED:
      return "FINALITY_PROVIDER_STATUS_SLASHED";
    case FinalityProviderStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** EventFinalityProviderCreated is the event emitted when a finality provider is created */
export interface EventFinalityProviderCreated {
  /** btc_pk_hex is the hex string of Bitcoin secp256k1 PK of this finality provider */
  btcPkHex: string;
  /** addr is the babylon address to receive commission from delegations. */
  addr: string;
  /** commission defines the commission rate of the finality provider in decimals. */
  commission: string;
  /** moniker defines a human-readable name for the finality provider. */
  moniker: string;
  /** identity defines an optional identity signature (ex. UPort or Keybase). */
  identity: string;
  /** website defines an optional website link. */
  website: string;
  /** security_contact defines an optional email for security contact. */
  securityContact: string;
  /** details define other optional details. */
  details: string;
}

/** EventFinalityProviderEdited is the event emitted when a finality provider is edited */
export interface EventFinalityProviderEdited {
  /** btc_pk_hex is the hex string of Bitcoin secp256k1 PK of this finality provider */
  btcPkHex: string;
  /** commission defines the commission rate of the finality provider in decimals. */
  commission: string;
  /** moniker defines a human-readable name for the finality provider. */
  moniker: string;
  /** identity defines an optional identity signature (ex. UPort or Keybase). */
  identity: string;
  /** website defines an optional website link. */
  website: string;
  /** security_contact defines an optional email for security contact. */
  securityContact: string;
  /** details define other optional details. */
  details: string;
}

/**
 * EventBTCDelegationStateUpdate is the event emitted when a BTC delegation's state is
 * updated. There are the following possible state transitions:
 * - non-existing -> pending, which happens upon `MsgCreateBTCDelegation`
 * - pending -> active, which happens upon `MsgAddCovenantSigs`
 * - active -> unbonded, which happens upon `MsgBTCUndelegate` or upon staking tx timelock expires
 */
export interface EventBTCDelegationStateUpdate {
  /**
   * staking_tx_hash is the hash of the staking tx.
   * It uniquely identifies a BTC delegation
   */
  stakingTxHash: string;
  /** new_state is the new state of this BTC delegation */
  newState: BTCDelegationStatus;
}

/**
 * EventSelectiveSlashing is the event emitted when an adversarial
 * finality provider selectively slashes a BTC delegation. This will
 * result in slashing of all BTC delegations under this finality provider.
 */
export interface EventSelectiveSlashing {
  /** evidence is the evidence of selective slashing */
  evidence: SelectiveSlashingEvidence | undefined;
}

/**
 * EventPowerDistUpdate is an event that affects voting power distribution
 * of BTC staking protocol
 */
export interface EventPowerDistUpdate {
  /** slashed_fp means a finality provider is slashed */
  slashedFp?: EventPowerDistUpdate_EventSlashedFinalityProvider | undefined;
  /** jailed_fp means a finality provider is jailed */
  jailedFp?: EventPowerDistUpdate_EventJailedFinalityProvider | undefined;
  /** unjailed_fp means a jailed finality provider is unjailed */
  unjailedFp?: EventPowerDistUpdate_EventUnjailedFinalityProvider | undefined;
  /** btc_del_state_update means a BTC delegation's state is updated */
  btcDelStateUpdate?: EventBTCDelegationStateUpdate | undefined;
}

/**
 * EventSlashedFinalityProvider defines an event that a finality provider
 * is slashed
 * TODO: unify with existing slashing events
 */
export interface EventPowerDistUpdate_EventSlashedFinalityProvider {
  pk: Uint8Array;
}

/**
 * EventJailedFinalityProvider defines an event that a finality provider
 * is jailed after being detected sluggish
 */
export interface EventPowerDistUpdate_EventJailedFinalityProvider {
  pk: Uint8Array;
}

/**
 * EventUnjailedFinalityProvider defines an event that a jailed finality provider
 * is unjailed after the jailing period is passed
 */
export interface EventPowerDistUpdate_EventUnjailedFinalityProvider {
  pk: Uint8Array;
}

/**
 * A finality provider starts with status INACTIVE once registered.
 * Possible status transitions are when:
 * 1. it has accumulated sufficient delegations and has
 * timestamped public randomness:
 * INACTIVE -> ACTIVE
 * 2. it is jailed due to downtime:
 * ACTIVE -> JAILED
 * 3. it is slashed due to double-sign:
 * ACTIVE -> SLASHED
 * 4. it is unjailed after a jailing period:
 * JAILED -> INACTIVE/ACTIVE (depending on (1))
 * 5. it does not have sufficient delegations or does not
 * have timestamped public randomness:
 * ACTIVE -> INACTIVE.
 * Note that it is impossible for a SLASHED finality provider to
 * transition to other status
 */
export interface EventFinalityProviderStatusChange {
  /** btc_pk is the BTC public key of the finality provider */
  btcPk: string;
  /**
   * new_state is the status that the finality provider
   * is transitioned to, following FinalityProviderStatus
   */
  newState: string;
}

/**
 * EventBTCDelegationCreated is the event emitted when a BTC delegation is created
 * on the Babylon chain
 */
export interface EventBTCDelegationCreated {
  /**
   * staking_tx_hash is the hash of the staking tx.
   * It uniquely identifies a BTC delegation
   */
  stakingTxHash: string;
  /** version of the params used to validate the delegation */
  paramsVersion: string;
  /**
   * finality_provider_btc_pks_hex is the list of hex str of Bitcoin secp256k1 PK of
   * the finality providers that this BTC delegation delegates to
   * the PK follows encoding in BIP-340 spec
   */
  finalityProviderBtcPksHex: string[];
  /**
   * staker_btc_pk_hex is the hex str of Bitcoin secp256k1 PK of the staker that
   * creates this BTC delegation the PK follows encoding in BIP-340 spec
   */
  stakerBtcPkHex: string;
  /** staking_time is the timelock of the staking tx specified in the BTC script */
  stakingTime: string;
  /**
   * staking_amount is the total amount of BTC stake in this delegation
   * quantified in satoshi
   */
  stakingAmount: string;
  /** unbonding_time is the time is timelock on unbonding tx chosen by the staker */
  unbondingTime: string;
  /** unbonding_tx is hex encoded bytes of the unsigned unbonding tx */
  unbondingTx: string;
  /** new_state of the BTC delegation */
  newState: string;
}

/**
 * EventCovenantSignatureReceived is the event emitted when a covenant committee
 * sends valid covenant signatures for a BTC delegation
 */
export interface EventCovenantSignatureReceived {
  /**
   * staking_tx_hash is the hash of the staking identifing the BTC delegation
   * that this covenant signature is for
   */
  stakingTxHash: string;
  /**
   * covenant_btc_pk_hex is the hex str of Bitcoin secp256k1 PK of the
   * covnenat committee that send the signature
   */
  covenantBtcPkHex: string;
  /**
   * covenant_unbonding_signature_hex is the hex str of the BIP340 Schnorr
   * signature of the covenant committee on the unbonding tx
   */
  covenantUnbondingSignatureHex: string;
}

/**
 * EventCovenantQuorumReached is the event emitted quorum of covenant committee
 * is reached for a BTC delegation
 */
export interface EventCovenantQuorumReached {
  /**
   * staking_tx_hash is the hash of the staking identifing the BTC delegation
   * that this covenant signature is for
   */
  stakingTxHash: string;
  /** new_state of the BTC delegation */
  newState: string;
}

/**
 * EventBTCDelegationInclusionProofReceived is the event emitted when a BTC delegation
 * inclusion proof is received
 */
export interface EventBTCDelegationInclusionProofReceived {
  /**
   * staking_tx_hash is the hash of the staking tx.
   * It uniquely identifies a BTC delegation
   */
  stakingTxHash: string;
  /**
   * start_height is the start BTC height of the BTC delegation
   * it is the start BTC height of the timelock
   */
  startHeight: string;
  /**
   * end_height is the end height of the BTC delegation
   * it is calculated by end_height = start_height + staking_time
   */
  endHeight: string;
  /** new_state of the BTC delegation */
  newState: string;
}

/**
 * EventBTCDelgationUnbondedEarly is the event emitted when a BTC delegation
 * is unbonded by staker sending unbonding tx to BTC
 */
export interface EventBTCDelgationUnbondedEarly {
  /**
   * staking_tx_hash is the hash of the staking tx.
   * It uniquely identifies a BTC delegation
   */
  stakingTxHash: string;
  /** new_state of the BTC delegation */
  newState: string;
}

/**
 * EventBTCDelegationExpired is the event emitted when a BTC delegation
 * is unbonded by expiration of the staking tx timelock
 */
export interface EventBTCDelegationExpired {
  /**
   * staking_tx_hash is the hash of the staking tx.
   * It uniquely identifies a BTC delegation
   */
  stakingTxHash: string;
  /** new_state of the BTC delegation */
  newState: string;
}

function createBaseEventFinalityProviderCreated(): EventFinalityProviderCreated {
  return {
    btcPkHex: "",
    addr: "",
    commission: "",
    moniker: "",
    identity: "",
    website: "",
    securityContact: "",
    details: "",
  };
}

export const EventFinalityProviderCreated: MessageFns<EventFinalityProviderCreated> =
  {
    encode(
      message: EventFinalityProviderCreated,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.btcPkHex !== "") {
        writer.uint32(10).string(message.btcPkHex);
      }
      if (message.addr !== "") {
        writer.uint32(18).string(message.addr);
      }
      if (message.commission !== "") {
        writer.uint32(26).string(message.commission);
      }
      if (message.moniker !== "") {
        writer.uint32(34).string(message.moniker);
      }
      if (message.identity !== "") {
        writer.uint32(42).string(message.identity);
      }
      if (message.website !== "") {
        writer.uint32(50).string(message.website);
      }
      if (message.securityContact !== "") {
        writer.uint32(58).string(message.securityContact);
      }
      if (message.details !== "") {
        writer.uint32(66).string(message.details);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): EventFinalityProviderCreated {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEventFinalityProviderCreated();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.btcPkHex = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.addr = reader.string();
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }

            message.commission = reader.string();
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }

            message.moniker = reader.string();
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }

            message.identity = reader.string();
            continue;
          case 6:
            if (tag !== 50) {
              break;
            }

            message.website = reader.string();
            continue;
          case 7:
            if (tag !== 58) {
              break;
            }

            message.securityContact = reader.string();
            continue;
          case 8:
            if (tag !== 66) {
              break;
            }

            message.details = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventFinalityProviderCreated {
      return {
        btcPkHex: isSet(object.btcPkHex)
          ? globalThis.String(object.btcPkHex)
          : "",
        addr: isSet(object.addr) ? globalThis.String(object.addr) : "",
        commission: isSet(object.commission)
          ? globalThis.String(object.commission)
          : "",
        moniker: isSet(object.moniker) ? globalThis.String(object.moniker) : "",
        identity: isSet(object.identity)
          ? globalThis.String(object.identity)
          : "",
        website: isSet(object.website) ? globalThis.String(object.website) : "",
        securityContact: isSet(object.securityContact)
          ? globalThis.String(object.securityContact)
          : "",
        details: isSet(object.details) ? globalThis.String(object.details) : "",
      };
    },

    toJSON(message: EventFinalityProviderCreated): unknown {
      const obj: any = {};
      if (message.btcPkHex !== "") {
        obj.btcPkHex = message.btcPkHex;
      }
      if (message.addr !== "") {
        obj.addr = message.addr;
      }
      if (message.commission !== "") {
        obj.commission = message.commission;
      }
      if (message.moniker !== "") {
        obj.moniker = message.moniker;
      }
      if (message.identity !== "") {
        obj.identity = message.identity;
      }
      if (message.website !== "") {
        obj.website = message.website;
      }
      if (message.securityContact !== "") {
        obj.securityContact = message.securityContact;
      }
      if (message.details !== "") {
        obj.details = message.details;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<EventFinalityProviderCreated>, I>>(
      base?: I,
    ): EventFinalityProviderCreated {
      return EventFinalityProviderCreated.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<EventFinalityProviderCreated>, I>>(
      object: I,
    ): EventFinalityProviderCreated {
      const message = createBaseEventFinalityProviderCreated();
      message.btcPkHex = object.btcPkHex ?? "";
      message.addr = object.addr ?? "";
      message.commission = object.commission ?? "";
      message.moniker = object.moniker ?? "";
      message.identity = object.identity ?? "";
      message.website = object.website ?? "";
      message.securityContact = object.securityContact ?? "";
      message.details = object.details ?? "";
      return message;
    },
  };

function createBaseEventFinalityProviderEdited(): EventFinalityProviderEdited {
  return {
    btcPkHex: "",
    commission: "",
    moniker: "",
    identity: "",
    website: "",
    securityContact: "",
    details: "",
  };
}

export const EventFinalityProviderEdited: MessageFns<EventFinalityProviderEdited> =
  {
    encode(
      message: EventFinalityProviderEdited,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.btcPkHex !== "") {
        writer.uint32(10).string(message.btcPkHex);
      }
      if (message.commission !== "") {
        writer.uint32(18).string(message.commission);
      }
      if (message.moniker !== "") {
        writer.uint32(26).string(message.moniker);
      }
      if (message.identity !== "") {
        writer.uint32(34).string(message.identity);
      }
      if (message.website !== "") {
        writer.uint32(42).string(message.website);
      }
      if (message.securityContact !== "") {
        writer.uint32(50).string(message.securityContact);
      }
      if (message.details !== "") {
        writer.uint32(58).string(message.details);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): EventFinalityProviderEdited {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEventFinalityProviderEdited();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.btcPkHex = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.commission = reader.string();
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }

            message.moniker = reader.string();
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }

            message.identity = reader.string();
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }

            message.website = reader.string();
            continue;
          case 6:
            if (tag !== 50) {
              break;
            }

            message.securityContact = reader.string();
            continue;
          case 7:
            if (tag !== 58) {
              break;
            }

            message.details = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventFinalityProviderEdited {
      return {
        btcPkHex: isSet(object.btcPkHex)
          ? globalThis.String(object.btcPkHex)
          : "",
        commission: isSet(object.commission)
          ? globalThis.String(object.commission)
          : "",
        moniker: isSet(object.moniker) ? globalThis.String(object.moniker) : "",
        identity: isSet(object.identity)
          ? globalThis.String(object.identity)
          : "",
        website: isSet(object.website) ? globalThis.String(object.website) : "",
        securityContact: isSet(object.securityContact)
          ? globalThis.String(object.securityContact)
          : "",
        details: isSet(object.details) ? globalThis.String(object.details) : "",
      };
    },

    toJSON(message: EventFinalityProviderEdited): unknown {
      const obj: any = {};
      if (message.btcPkHex !== "") {
        obj.btcPkHex = message.btcPkHex;
      }
      if (message.commission !== "") {
        obj.commission = message.commission;
      }
      if (message.moniker !== "") {
        obj.moniker = message.moniker;
      }
      if (message.identity !== "") {
        obj.identity = message.identity;
      }
      if (message.website !== "") {
        obj.website = message.website;
      }
      if (message.securityContact !== "") {
        obj.securityContact = message.securityContact;
      }
      if (message.details !== "") {
        obj.details = message.details;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<EventFinalityProviderEdited>, I>>(
      base?: I,
    ): EventFinalityProviderEdited {
      return EventFinalityProviderEdited.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<EventFinalityProviderEdited>, I>>(
      object: I,
    ): EventFinalityProviderEdited {
      const message = createBaseEventFinalityProviderEdited();
      message.btcPkHex = object.btcPkHex ?? "";
      message.commission = object.commission ?? "";
      message.moniker = object.moniker ?? "";
      message.identity = object.identity ?? "";
      message.website = object.website ?? "";
      message.securityContact = object.securityContact ?? "";
      message.details = object.details ?? "";
      return message;
    },
  };

function createBaseEventBTCDelegationStateUpdate(): EventBTCDelegationStateUpdate {
  return { stakingTxHash: "", newState: 0 };
}

export const EventBTCDelegationStateUpdate: MessageFns<EventBTCDelegationStateUpdate> =
  {
    encode(
      message: EventBTCDelegationStateUpdate,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.stakingTxHash !== "") {
        writer.uint32(10).string(message.stakingTxHash);
      }
      if (message.newState !== 0) {
        writer.uint32(16).int32(message.newState);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): EventBTCDelegationStateUpdate {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEventBTCDelegationStateUpdate();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.stakingTxHash = reader.string();
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }

            message.newState = reader.int32() as any;
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventBTCDelegationStateUpdate {
      return {
        stakingTxHash: isSet(object.stakingTxHash)
          ? globalThis.String(object.stakingTxHash)
          : "",
        newState: isSet(object.newState)
          ? bTCDelegationStatusFromJSON(object.newState)
          : 0,
      };
    },

    toJSON(message: EventBTCDelegationStateUpdate): unknown {
      const obj: any = {};
      if (message.stakingTxHash !== "") {
        obj.stakingTxHash = message.stakingTxHash;
      }
      if (message.newState !== 0) {
        obj.newState = bTCDelegationStatusToJSON(message.newState);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<EventBTCDelegationStateUpdate>, I>>(
      base?: I,
    ): EventBTCDelegationStateUpdate {
      return EventBTCDelegationStateUpdate.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<EventBTCDelegationStateUpdate>, I>>(
      object: I,
    ): EventBTCDelegationStateUpdate {
      const message = createBaseEventBTCDelegationStateUpdate();
      message.stakingTxHash = object.stakingTxHash ?? "";
      message.newState = object.newState ?? 0;
      return message;
    },
  };

function createBaseEventSelectiveSlashing(): EventSelectiveSlashing {
  return { evidence: undefined };
}

export const EventSelectiveSlashing: MessageFns<EventSelectiveSlashing> = {
  encode(
    message: EventSelectiveSlashing,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.evidence !== undefined) {
      SelectiveSlashingEvidence.encode(
        message.evidence,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): EventSelectiveSlashing {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSelectiveSlashing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.evidence = SelectiveSlashingEvidence.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSelectiveSlashing {
    return {
      evidence: isSet(object.evidence)
        ? SelectiveSlashingEvidence.fromJSON(object.evidence)
        : undefined,
    };
  },

  toJSON(message: EventSelectiveSlashing): unknown {
    const obj: any = {};
    if (message.evidence !== undefined) {
      obj.evidence = SelectiveSlashingEvidence.toJSON(message.evidence);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventSelectiveSlashing>, I>>(
    base?: I,
  ): EventSelectiveSlashing {
    return EventSelectiveSlashing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventSelectiveSlashing>, I>>(
    object: I,
  ): EventSelectiveSlashing {
    const message = createBaseEventSelectiveSlashing();
    message.evidence =
      object.evidence !== undefined && object.evidence !== null
        ? SelectiveSlashingEvidence.fromPartial(object.evidence)
        : undefined;
    return message;
  },
};

function createBaseEventPowerDistUpdate(): EventPowerDistUpdate {
  return {
    slashedFp: undefined,
    jailedFp: undefined,
    unjailedFp: undefined,
    btcDelStateUpdate: undefined,
  };
}

export const EventPowerDistUpdate: MessageFns<EventPowerDistUpdate> = {
  encode(
    message: EventPowerDistUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.slashedFp !== undefined) {
      EventPowerDistUpdate_EventSlashedFinalityProvider.encode(
        message.slashedFp,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.jailedFp !== undefined) {
      EventPowerDistUpdate_EventJailedFinalityProvider.encode(
        message.jailedFp,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.unjailedFp !== undefined) {
      EventPowerDistUpdate_EventUnjailedFinalityProvider.encode(
        message.unjailedFp,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.btcDelStateUpdate !== undefined) {
      EventBTCDelegationStateUpdate.encode(
        message.btcDelStateUpdate,
        writer.uint32(34).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): EventPowerDistUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventPowerDistUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.slashedFp =
            EventPowerDistUpdate_EventSlashedFinalityProvider.decode(
              reader,
              reader.uint32(),
            );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.jailedFp =
            EventPowerDistUpdate_EventJailedFinalityProvider.decode(
              reader,
              reader.uint32(),
            );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unjailedFp =
            EventPowerDistUpdate_EventUnjailedFinalityProvider.decode(
              reader,
              reader.uint32(),
            );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.btcDelStateUpdate = EventBTCDelegationStateUpdate.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventPowerDistUpdate {
    return {
      slashedFp: isSet(object.slashedFp)
        ? EventPowerDistUpdate_EventSlashedFinalityProvider.fromJSON(
            object.slashedFp,
          )
        : undefined,
      jailedFp: isSet(object.jailedFp)
        ? EventPowerDistUpdate_EventJailedFinalityProvider.fromJSON(
            object.jailedFp,
          )
        : undefined,
      unjailedFp: isSet(object.unjailedFp)
        ? EventPowerDistUpdate_EventUnjailedFinalityProvider.fromJSON(
            object.unjailedFp,
          )
        : undefined,
      btcDelStateUpdate: isSet(object.btcDelStateUpdate)
        ? EventBTCDelegationStateUpdate.fromJSON(object.btcDelStateUpdate)
        : undefined,
    };
  },

  toJSON(message: EventPowerDistUpdate): unknown {
    const obj: any = {};
    if (message.slashedFp !== undefined) {
      obj.slashedFp = EventPowerDistUpdate_EventSlashedFinalityProvider.toJSON(
        message.slashedFp,
      );
    }
    if (message.jailedFp !== undefined) {
      obj.jailedFp = EventPowerDistUpdate_EventJailedFinalityProvider.toJSON(
        message.jailedFp,
      );
    }
    if (message.unjailedFp !== undefined) {
      obj.unjailedFp =
        EventPowerDistUpdate_EventUnjailedFinalityProvider.toJSON(
          message.unjailedFp,
        );
    }
    if (message.btcDelStateUpdate !== undefined) {
      obj.btcDelStateUpdate = EventBTCDelegationStateUpdate.toJSON(
        message.btcDelStateUpdate,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventPowerDistUpdate>, I>>(
    base?: I,
  ): EventPowerDistUpdate {
    return EventPowerDistUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventPowerDistUpdate>, I>>(
    object: I,
  ): EventPowerDistUpdate {
    const message = createBaseEventPowerDistUpdate();
    message.slashedFp =
      object.slashedFp !== undefined && object.slashedFp !== null
        ? EventPowerDistUpdate_EventSlashedFinalityProvider.fromPartial(
            object.slashedFp,
          )
        : undefined;
    message.jailedFp =
      object.jailedFp !== undefined && object.jailedFp !== null
        ? EventPowerDistUpdate_EventJailedFinalityProvider.fromPartial(
            object.jailedFp,
          )
        : undefined;
    message.unjailedFp =
      object.unjailedFp !== undefined && object.unjailedFp !== null
        ? EventPowerDistUpdate_EventUnjailedFinalityProvider.fromPartial(
            object.unjailedFp,
          )
        : undefined;
    message.btcDelStateUpdate =
      object.btcDelStateUpdate !== undefined &&
      object.btcDelStateUpdate !== null
        ? EventBTCDelegationStateUpdate.fromPartial(object.btcDelStateUpdate)
        : undefined;
    return message;
  },
};

function createBaseEventPowerDistUpdate_EventSlashedFinalityProvider(): EventPowerDistUpdate_EventSlashedFinalityProvider {
  return { pk: new Uint8Array(0) };
}

export const EventPowerDistUpdate_EventSlashedFinalityProvider: MessageFns<EventPowerDistUpdate_EventSlashedFinalityProvider> =
  {
    encode(
      message: EventPowerDistUpdate_EventSlashedFinalityProvider,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.pk.length !== 0) {
        writer.uint32(10).bytes(message.pk);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): EventPowerDistUpdate_EventSlashedFinalityProvider {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseEventPowerDistUpdate_EventSlashedFinalityProvider();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.pk = reader.bytes();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventPowerDistUpdate_EventSlashedFinalityProvider {
      return {
        pk: isSet(object.pk) ? bytesFromBase64(object.pk) : new Uint8Array(0),
      };
    },

    toJSON(
      message: EventPowerDistUpdate_EventSlashedFinalityProvider,
    ): unknown {
      const obj: any = {};
      if (message.pk.length !== 0) {
        obj.pk = base64FromBytes(message.pk);
      }
      return obj;
    },

    create<
      I extends Exact<
        DeepPartial<EventPowerDistUpdate_EventSlashedFinalityProvider>,
        I
      >,
    >(base?: I): EventPowerDistUpdate_EventSlashedFinalityProvider {
      return EventPowerDistUpdate_EventSlashedFinalityProvider.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<
        DeepPartial<EventPowerDistUpdate_EventSlashedFinalityProvider>,
        I
      >,
    >(object: I): EventPowerDistUpdate_EventSlashedFinalityProvider {
      const message =
        createBaseEventPowerDistUpdate_EventSlashedFinalityProvider();
      message.pk = object.pk ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseEventPowerDistUpdate_EventJailedFinalityProvider(): EventPowerDistUpdate_EventJailedFinalityProvider {
  return { pk: new Uint8Array(0) };
}

export const EventPowerDistUpdate_EventJailedFinalityProvider: MessageFns<EventPowerDistUpdate_EventJailedFinalityProvider> =
  {
    encode(
      message: EventPowerDistUpdate_EventJailedFinalityProvider,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.pk.length !== 0) {
        writer.uint32(10).bytes(message.pk);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): EventPowerDistUpdate_EventJailedFinalityProvider {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseEventPowerDistUpdate_EventJailedFinalityProvider();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.pk = reader.bytes();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventPowerDistUpdate_EventJailedFinalityProvider {
      return {
        pk: isSet(object.pk) ? bytesFromBase64(object.pk) : new Uint8Array(0),
      };
    },

    toJSON(message: EventPowerDistUpdate_EventJailedFinalityProvider): unknown {
      const obj: any = {};
      if (message.pk.length !== 0) {
        obj.pk = base64FromBytes(message.pk);
      }
      return obj;
    },

    create<
      I extends Exact<
        DeepPartial<EventPowerDistUpdate_EventJailedFinalityProvider>,
        I
      >,
    >(base?: I): EventPowerDistUpdate_EventJailedFinalityProvider {
      return EventPowerDistUpdate_EventJailedFinalityProvider.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<
        DeepPartial<EventPowerDistUpdate_EventJailedFinalityProvider>,
        I
      >,
    >(object: I): EventPowerDistUpdate_EventJailedFinalityProvider {
      const message =
        createBaseEventPowerDistUpdate_EventJailedFinalityProvider();
      message.pk = object.pk ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseEventPowerDistUpdate_EventUnjailedFinalityProvider(): EventPowerDistUpdate_EventUnjailedFinalityProvider {
  return { pk: new Uint8Array(0) };
}

export const EventPowerDistUpdate_EventUnjailedFinalityProvider: MessageFns<EventPowerDistUpdate_EventUnjailedFinalityProvider> =
  {
    encode(
      message: EventPowerDistUpdate_EventUnjailedFinalityProvider,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.pk.length !== 0) {
        writer.uint32(10).bytes(message.pk);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): EventPowerDistUpdate_EventUnjailedFinalityProvider {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseEventPowerDistUpdate_EventUnjailedFinalityProvider();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.pk = reader.bytes();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventPowerDistUpdate_EventUnjailedFinalityProvider {
      return {
        pk: isSet(object.pk) ? bytesFromBase64(object.pk) : new Uint8Array(0),
      };
    },

    toJSON(
      message: EventPowerDistUpdate_EventUnjailedFinalityProvider,
    ): unknown {
      const obj: any = {};
      if (message.pk.length !== 0) {
        obj.pk = base64FromBytes(message.pk);
      }
      return obj;
    },

    create<
      I extends Exact<
        DeepPartial<EventPowerDistUpdate_EventUnjailedFinalityProvider>,
        I
      >,
    >(base?: I): EventPowerDistUpdate_EventUnjailedFinalityProvider {
      return EventPowerDistUpdate_EventUnjailedFinalityProvider.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<
        DeepPartial<EventPowerDistUpdate_EventUnjailedFinalityProvider>,
        I
      >,
    >(object: I): EventPowerDistUpdate_EventUnjailedFinalityProvider {
      const message =
        createBaseEventPowerDistUpdate_EventUnjailedFinalityProvider();
      message.pk = object.pk ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseEventFinalityProviderStatusChange(): EventFinalityProviderStatusChange {
  return { btcPk: "", newState: "" };
}

export const EventFinalityProviderStatusChange: MessageFns<EventFinalityProviderStatusChange> =
  {
    encode(
      message: EventFinalityProviderStatusChange,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.btcPk !== "") {
        writer.uint32(10).string(message.btcPk);
      }
      if (message.newState !== "") {
        writer.uint32(18).string(message.newState);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): EventFinalityProviderStatusChange {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEventFinalityProviderStatusChange();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.btcPk = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.newState = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventFinalityProviderStatusChange {
      return {
        btcPk: isSet(object.btcPk) ? globalThis.String(object.btcPk) : "",
        newState: isSet(object.newState)
          ? globalThis.String(object.newState)
          : "",
      };
    },

    toJSON(message: EventFinalityProviderStatusChange): unknown {
      const obj: any = {};
      if (message.btcPk !== "") {
        obj.btcPk = message.btcPk;
      }
      if (message.newState !== "") {
        obj.newState = message.newState;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<EventFinalityProviderStatusChange>, I>>(
      base?: I,
    ): EventFinalityProviderStatusChange {
      return EventFinalityProviderStatusChange.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<EventFinalityProviderStatusChange>, I>,
    >(object: I): EventFinalityProviderStatusChange {
      const message = createBaseEventFinalityProviderStatusChange();
      message.btcPk = object.btcPk ?? "";
      message.newState = object.newState ?? "";
      return message;
    },
  };

function createBaseEventBTCDelegationCreated(): EventBTCDelegationCreated {
  return {
    stakingTxHash: "",
    paramsVersion: "",
    finalityProviderBtcPksHex: [],
    stakerBtcPkHex: "",
    stakingTime: "",
    stakingAmount: "",
    unbondingTime: "",
    unbondingTx: "",
    newState: "",
  };
}

export const EventBTCDelegationCreated: MessageFns<EventBTCDelegationCreated> =
  {
    encode(
      message: EventBTCDelegationCreated,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.stakingTxHash !== "") {
        writer.uint32(10).string(message.stakingTxHash);
      }
      if (message.paramsVersion !== "") {
        writer.uint32(18).string(message.paramsVersion);
      }
      for (const v of message.finalityProviderBtcPksHex) {
        writer.uint32(26).string(v!);
      }
      if (message.stakerBtcPkHex !== "") {
        writer.uint32(34).string(message.stakerBtcPkHex);
      }
      if (message.stakingTime !== "") {
        writer.uint32(42).string(message.stakingTime);
      }
      if (message.stakingAmount !== "") {
        writer.uint32(50).string(message.stakingAmount);
      }
      if (message.unbondingTime !== "") {
        writer.uint32(58).string(message.unbondingTime);
      }
      if (message.unbondingTx !== "") {
        writer.uint32(66).string(message.unbondingTx);
      }
      if (message.newState !== "") {
        writer.uint32(74).string(message.newState);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): EventBTCDelegationCreated {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEventBTCDelegationCreated();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.stakingTxHash = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.paramsVersion = reader.string();
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }

            message.finalityProviderBtcPksHex.push(reader.string());
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }

            message.stakerBtcPkHex = reader.string();
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }

            message.stakingTime = reader.string();
            continue;
          case 6:
            if (tag !== 50) {
              break;
            }

            message.stakingAmount = reader.string();
            continue;
          case 7:
            if (tag !== 58) {
              break;
            }

            message.unbondingTime = reader.string();
            continue;
          case 8:
            if (tag !== 66) {
              break;
            }

            message.unbondingTx = reader.string();
            continue;
          case 9:
            if (tag !== 74) {
              break;
            }

            message.newState = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventBTCDelegationCreated {
      return {
        stakingTxHash: isSet(object.stakingTxHash)
          ? globalThis.String(object.stakingTxHash)
          : "",
        paramsVersion: isSet(object.paramsVersion)
          ? globalThis.String(object.paramsVersion)
          : "",
        finalityProviderBtcPksHex: globalThis.Array.isArray(
          object?.finalityProviderBtcPksHex,
        )
          ? object.finalityProviderBtcPksHex.map((e: any) =>
              globalThis.String(e),
            )
          : [],
        stakerBtcPkHex: isSet(object.stakerBtcPkHex)
          ? globalThis.String(object.stakerBtcPkHex)
          : "",
        stakingTime: isSet(object.stakingTime)
          ? globalThis.String(object.stakingTime)
          : "",
        stakingAmount: isSet(object.stakingAmount)
          ? globalThis.String(object.stakingAmount)
          : "",
        unbondingTime: isSet(object.unbondingTime)
          ? globalThis.String(object.unbondingTime)
          : "",
        unbondingTx: isSet(object.unbondingTx)
          ? globalThis.String(object.unbondingTx)
          : "",
        newState: isSet(object.newState)
          ? globalThis.String(object.newState)
          : "",
      };
    },

    toJSON(message: EventBTCDelegationCreated): unknown {
      const obj: any = {};
      if (message.stakingTxHash !== "") {
        obj.stakingTxHash = message.stakingTxHash;
      }
      if (message.paramsVersion !== "") {
        obj.paramsVersion = message.paramsVersion;
      }
      if (message.finalityProviderBtcPksHex?.length) {
        obj.finalityProviderBtcPksHex = message.finalityProviderBtcPksHex;
      }
      if (message.stakerBtcPkHex !== "") {
        obj.stakerBtcPkHex = message.stakerBtcPkHex;
      }
      if (message.stakingTime !== "") {
        obj.stakingTime = message.stakingTime;
      }
      if (message.stakingAmount !== "") {
        obj.stakingAmount = message.stakingAmount;
      }
      if (message.unbondingTime !== "") {
        obj.unbondingTime = message.unbondingTime;
      }
      if (message.unbondingTx !== "") {
        obj.unbondingTx = message.unbondingTx;
      }
      if (message.newState !== "") {
        obj.newState = message.newState;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<EventBTCDelegationCreated>, I>>(
      base?: I,
    ): EventBTCDelegationCreated {
      return EventBTCDelegationCreated.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<EventBTCDelegationCreated>, I>>(
      object: I,
    ): EventBTCDelegationCreated {
      const message = createBaseEventBTCDelegationCreated();
      message.stakingTxHash = object.stakingTxHash ?? "";
      message.paramsVersion = object.paramsVersion ?? "";
      message.finalityProviderBtcPksHex =
        object.finalityProviderBtcPksHex?.map((e) => e) || [];
      message.stakerBtcPkHex = object.stakerBtcPkHex ?? "";
      message.stakingTime = object.stakingTime ?? "";
      message.stakingAmount = object.stakingAmount ?? "";
      message.unbondingTime = object.unbondingTime ?? "";
      message.unbondingTx = object.unbondingTx ?? "";
      message.newState = object.newState ?? "";
      return message;
    },
  };

function createBaseEventCovenantSignatureReceived(): EventCovenantSignatureReceived {
  return {
    stakingTxHash: "",
    covenantBtcPkHex: "",
    covenantUnbondingSignatureHex: "",
  };
}

export const EventCovenantSignatureReceived: MessageFns<EventCovenantSignatureReceived> =
  {
    encode(
      message: EventCovenantSignatureReceived,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.stakingTxHash !== "") {
        writer.uint32(10).string(message.stakingTxHash);
      }
      if (message.covenantBtcPkHex !== "") {
        writer.uint32(18).string(message.covenantBtcPkHex);
      }
      if (message.covenantUnbondingSignatureHex !== "") {
        writer.uint32(26).string(message.covenantUnbondingSignatureHex);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): EventCovenantSignatureReceived {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEventCovenantSignatureReceived();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.stakingTxHash = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.covenantBtcPkHex = reader.string();
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }

            message.covenantUnbondingSignatureHex = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventCovenantSignatureReceived {
      return {
        stakingTxHash: isSet(object.stakingTxHash)
          ? globalThis.String(object.stakingTxHash)
          : "",
        covenantBtcPkHex: isSet(object.covenantBtcPkHex)
          ? globalThis.String(object.covenantBtcPkHex)
          : "",
        covenantUnbondingSignatureHex: isSet(
          object.covenantUnbondingSignatureHex,
        )
          ? globalThis.String(object.covenantUnbondingSignatureHex)
          : "",
      };
    },

    toJSON(message: EventCovenantSignatureReceived): unknown {
      const obj: any = {};
      if (message.stakingTxHash !== "") {
        obj.stakingTxHash = message.stakingTxHash;
      }
      if (message.covenantBtcPkHex !== "") {
        obj.covenantBtcPkHex = message.covenantBtcPkHex;
      }
      if (message.covenantUnbondingSignatureHex !== "") {
        obj.covenantUnbondingSignatureHex =
          message.covenantUnbondingSignatureHex;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<EventCovenantSignatureReceived>, I>>(
      base?: I,
    ): EventCovenantSignatureReceived {
      return EventCovenantSignatureReceived.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<EventCovenantSignatureReceived>, I>,
    >(object: I): EventCovenantSignatureReceived {
      const message = createBaseEventCovenantSignatureReceived();
      message.stakingTxHash = object.stakingTxHash ?? "";
      message.covenantBtcPkHex = object.covenantBtcPkHex ?? "";
      message.covenantUnbondingSignatureHex =
        object.covenantUnbondingSignatureHex ?? "";
      return message;
    },
  };

function createBaseEventCovenantQuorumReached(): EventCovenantQuorumReached {
  return { stakingTxHash: "", newState: "" };
}

export const EventCovenantQuorumReached: MessageFns<EventCovenantQuorumReached> =
  {
    encode(
      message: EventCovenantQuorumReached,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.stakingTxHash !== "") {
        writer.uint32(10).string(message.stakingTxHash);
      }
      if (message.newState !== "") {
        writer.uint32(18).string(message.newState);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): EventCovenantQuorumReached {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEventCovenantQuorumReached();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.stakingTxHash = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.newState = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventCovenantQuorumReached {
      return {
        stakingTxHash: isSet(object.stakingTxHash)
          ? globalThis.String(object.stakingTxHash)
          : "",
        newState: isSet(object.newState)
          ? globalThis.String(object.newState)
          : "",
      };
    },

    toJSON(message: EventCovenantQuorumReached): unknown {
      const obj: any = {};
      if (message.stakingTxHash !== "") {
        obj.stakingTxHash = message.stakingTxHash;
      }
      if (message.newState !== "") {
        obj.newState = message.newState;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<EventCovenantQuorumReached>, I>>(
      base?: I,
    ): EventCovenantQuorumReached {
      return EventCovenantQuorumReached.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<EventCovenantQuorumReached>, I>>(
      object: I,
    ): EventCovenantQuorumReached {
      const message = createBaseEventCovenantQuorumReached();
      message.stakingTxHash = object.stakingTxHash ?? "";
      message.newState = object.newState ?? "";
      return message;
    },
  };

function createBaseEventBTCDelegationInclusionProofReceived(): EventBTCDelegationInclusionProofReceived {
  return { stakingTxHash: "", startHeight: "", endHeight: "", newState: "" };
}

export const EventBTCDelegationInclusionProofReceived: MessageFns<EventBTCDelegationInclusionProofReceived> =
  {
    encode(
      message: EventBTCDelegationInclusionProofReceived,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.stakingTxHash !== "") {
        writer.uint32(10).string(message.stakingTxHash);
      }
      if (message.startHeight !== "") {
        writer.uint32(18).string(message.startHeight);
      }
      if (message.endHeight !== "") {
        writer.uint32(26).string(message.endHeight);
      }
      if (message.newState !== "") {
        writer.uint32(34).string(message.newState);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): EventBTCDelegationInclusionProofReceived {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEventBTCDelegationInclusionProofReceived();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.stakingTxHash = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.startHeight = reader.string();
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }

            message.endHeight = reader.string();
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }

            message.newState = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventBTCDelegationInclusionProofReceived {
      return {
        stakingTxHash: isSet(object.stakingTxHash)
          ? globalThis.String(object.stakingTxHash)
          : "",
        startHeight: isSet(object.startHeight)
          ? globalThis.String(object.startHeight)
          : "",
        endHeight: isSet(object.endHeight)
          ? globalThis.String(object.endHeight)
          : "",
        newState: isSet(object.newState)
          ? globalThis.String(object.newState)
          : "",
      };
    },

    toJSON(message: EventBTCDelegationInclusionProofReceived): unknown {
      const obj: any = {};
      if (message.stakingTxHash !== "") {
        obj.stakingTxHash = message.stakingTxHash;
      }
      if (message.startHeight !== "") {
        obj.startHeight = message.startHeight;
      }
      if (message.endHeight !== "") {
        obj.endHeight = message.endHeight;
      }
      if (message.newState !== "") {
        obj.newState = message.newState;
      }
      return obj;
    },

    create<
      I extends Exact<DeepPartial<EventBTCDelegationInclusionProofReceived>, I>,
    >(base?: I): EventBTCDelegationInclusionProofReceived {
      return EventBTCDelegationInclusionProofReceived.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<DeepPartial<EventBTCDelegationInclusionProofReceived>, I>,
    >(object: I): EventBTCDelegationInclusionProofReceived {
      const message = createBaseEventBTCDelegationInclusionProofReceived();
      message.stakingTxHash = object.stakingTxHash ?? "";
      message.startHeight = object.startHeight ?? "";
      message.endHeight = object.endHeight ?? "";
      message.newState = object.newState ?? "";
      return message;
    },
  };

function createBaseEventBTCDelgationUnbondedEarly(): EventBTCDelgationUnbondedEarly {
  return { stakingTxHash: "", newState: "" };
}

export const EventBTCDelgationUnbondedEarly: MessageFns<EventBTCDelgationUnbondedEarly> =
  {
    encode(
      message: EventBTCDelgationUnbondedEarly,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.stakingTxHash !== "") {
        writer.uint32(10).string(message.stakingTxHash);
      }
      if (message.newState !== "") {
        writer.uint32(18).string(message.newState);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): EventBTCDelgationUnbondedEarly {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEventBTCDelgationUnbondedEarly();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.stakingTxHash = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.newState = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventBTCDelgationUnbondedEarly {
      return {
        stakingTxHash: isSet(object.stakingTxHash)
          ? globalThis.String(object.stakingTxHash)
          : "",
        newState: isSet(object.newState)
          ? globalThis.String(object.newState)
          : "",
      };
    },

    toJSON(message: EventBTCDelgationUnbondedEarly): unknown {
      const obj: any = {};
      if (message.stakingTxHash !== "") {
        obj.stakingTxHash = message.stakingTxHash;
      }
      if (message.newState !== "") {
        obj.newState = message.newState;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<EventBTCDelgationUnbondedEarly>, I>>(
      base?: I,
    ): EventBTCDelgationUnbondedEarly {
      return EventBTCDelgationUnbondedEarly.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<EventBTCDelgationUnbondedEarly>, I>,
    >(object: I): EventBTCDelgationUnbondedEarly {
      const message = createBaseEventBTCDelgationUnbondedEarly();
      message.stakingTxHash = object.stakingTxHash ?? "";
      message.newState = object.newState ?? "";
      return message;
    },
  };

function createBaseEventBTCDelegationExpired(): EventBTCDelegationExpired {
  return { stakingTxHash: "", newState: "" };
}

export const EventBTCDelegationExpired: MessageFns<EventBTCDelegationExpired> =
  {
    encode(
      message: EventBTCDelegationExpired,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.stakingTxHash !== "") {
        writer.uint32(10).string(message.stakingTxHash);
      }
      if (message.newState !== "") {
        writer.uint32(18).string(message.newState);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): EventBTCDelegationExpired {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEventBTCDelegationExpired();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.stakingTxHash = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.newState = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventBTCDelegationExpired {
      return {
        stakingTxHash: isSet(object.stakingTxHash)
          ? globalThis.String(object.stakingTxHash)
          : "",
        newState: isSet(object.newState)
          ? globalThis.String(object.newState)
          : "",
      };
    },

    toJSON(message: EventBTCDelegationExpired): unknown {
      const obj: any = {};
      if (message.stakingTxHash !== "") {
        obj.stakingTxHash = message.stakingTxHash;
      }
      if (message.newState !== "") {
        obj.newState = message.newState;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<EventBTCDelegationExpired>, I>>(
      base?: I,
    ): EventBTCDelegationExpired {
      return EventBTCDelegationExpired.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<EventBTCDelegationExpired>, I>>(
      object: I,
    ): EventBTCDelegationExpired {
      const message = createBaseEventBTCDelegationExpired();
      message.stakingTxHash = object.stakingTxHash ?? "";
      message.newState = object.newState ?? "";
      return message;
    },
  };

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
