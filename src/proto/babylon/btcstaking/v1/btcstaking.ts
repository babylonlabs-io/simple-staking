// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: babylon/btcstaking/v1/btcstaking.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Description } from "../../../cosmos/staking/v1beta1/staking";
import { TransactionKey } from "../../btccheckpoint/v1/btccheckpoint";
import { ProofOfPossessionBTC } from "./pop";

export const protobufPackage = "babylon.btcstaking.v1";

/**
 * BTCDelegationStatus is the status of a delegation.
 * There are two possible valid state transition paths for a BTC delegation:
 * - PENDING -> ACTIVE -> UNBONDED
 * - PENDING -> VERIFIED -> ACTIVE -> UNBONDED
 * and one invalid state transition path:
 * - PENDING -> VERIFIED -> UNBONDED i.e the staker unbonded before
 * activating delegation on Babylon chain.
 * In valid transition paths, the delegation becomes UNBONDED when:
 * - either the staking transaction timelock expires
 * - or the staker requests early undelegation through MsgBTCUndelegate message.
 */
export enum BTCDelegationStatus {
  /** PENDING - PENDING defines a delegation that is waiting for covenant signatures. */
  PENDING = 0,
  /**
   * VERIFIED - VERIFIED defines a delegation that has covenant signatures but is not yet
   * included in the BTC chain.
   */
  VERIFIED = 1,
  /** ACTIVE - ACTIVE defines a delegation that has voting power */
  ACTIVE = 2,
  /**
   * UNBONDED - UNBONDED defines a delegation no longer has voting power:
   * - either reaching the end of staking transaction timelock
   * - or receiving unbonding tx with signatures from staker and covenant committee
   */
  UNBONDED = 3,
  /** ANY - ANY is any of the above status */
  ANY = 4,
  UNRECOGNIZED = -1,
}

export function bTCDelegationStatusFromJSON(object: any): BTCDelegationStatus {
  switch (object) {
    case 0:
    case "PENDING":
      return BTCDelegationStatus.PENDING;
    case 1:
    case "VERIFIED":
      return BTCDelegationStatus.VERIFIED;
    case 2:
    case "ACTIVE":
      return BTCDelegationStatus.ACTIVE;
    case 3:
    case "UNBONDED":
      return BTCDelegationStatus.UNBONDED;
    case 4:
    case "ANY":
      return BTCDelegationStatus.ANY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BTCDelegationStatus.UNRECOGNIZED;
  }
}

export function bTCDelegationStatusToJSON(object: BTCDelegationStatus): string {
  switch (object) {
    case BTCDelegationStatus.PENDING:
      return "PENDING";
    case BTCDelegationStatus.VERIFIED:
      return "VERIFIED";
    case BTCDelegationStatus.ACTIVE:
      return "ACTIVE";
    case BTCDelegationStatus.UNBONDED:
      return "UNBONDED";
    case BTCDelegationStatus.ANY:
      return "ANY";
    case BTCDelegationStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** FinalityProvider defines a finality provider */
export interface FinalityProvider {
  /** addr is the bech32 address identifier of the finality provider. */
  addr: string;
  /** description defines the description terms for the finality provider. */
  description: Description | undefined;
  /** commission defines the commission rate of the finality provider. */
  commission: string;
  /**
   * btc_pk is the Bitcoin secp256k1 PK of this finality provider
   * the PK follows encoding in BIP-340 spec
   */
  btcPk: Uint8Array;
  /**
   * pop is the proof of possession of the btc_pk, where the BTC
   * private key signs the bech32 bbn addr of the finality provider.
   */
  pop: ProofOfPossessionBTC | undefined;
  /**
   * slashed_babylon_height indicates the Babylon height when
   * the finality provider is slashed.
   * if it's 0 then the finality provider is not slashed
   */
  slashedBabylonHeight: number;
  /**
   * slashed_btc_height indicates the BTC height when
   * the finality provider is slashed.
   * if it's 0 then the finality provider is not slashed
   */
  slashedBtcHeight: number;
  /** jailed defines whether the finality provider is jailed */
  jailed: boolean;
}

/** FinalityProviderWithMeta wraps the FinalityProvider with metadata. */
export interface FinalityProviderWithMeta {
  /**
   * btc_pk is the Bitcoin secp256k1 PK of thisfinality provider
   * the PK follows encoding in BIP-340 spec
   */
  btcPk: Uint8Array;
  /** height is the queried Babylon height */
  height: number;
  /** voting_power is the voting power of this finality provider at the given height */
  votingPower: number;
  /**
   * slashed_babylon_height indicates the Babylon height when
   * the finality provider is slashed.
   * if it's 0 then the finality provider is not slashed
   */
  slashedBabylonHeight: number;
  /**
   * slashed_btc_height indicates the BTC height when
   * the finality provider is slashed.
   * if it's 0 then the finality provider is not slashed
   */
  slashedBtcHeight: number;
  /** jailed defines whether the finality provider is detected jailed */
  jailed: boolean;
}

/** BTCDelegation defines a BTC delegation */
export interface BTCDelegation {
  /** staker_addr is the address to receive rewards from BTC delegation. */
  stakerAddr: string;
  /**
   * btc_pk is the Bitcoin secp256k1 PK of this BTC delegation
   * the PK follows encoding in BIP-340 spec
   */
  btcPk: Uint8Array;
  /** pop is the proof of possession of babylon_pk and btc_pk */
  pop: ProofOfPossessionBTC | undefined;
  /**
   * fp_btc_pk_list is the list of BIP-340 PKs of the finality providers that
   * this BTC delegation delegates to
   * If there is more than 1 PKs, then this means the delegation is restaked
   * to multiple finality providers
   */
  fpBtcPkList: Uint8Array[];
  /** staking_time is the number of blocks for which the delegation is locked on BTC chain */
  stakingTime: number;
  /**
   * start_height is the start BTC height of the BTC delegation
   * it is the start BTC height of the timelock
   */
  startHeight: number;
  /**
   * end_height is the end height of the BTC delegation
   * it is calculated by end_height = start_height + staking_time
   */
  endHeight: number;
  /**
   * total_sat is the total amount of BTC stakes in this delegation
   * quantified in satoshi
   */
  totalSat: number;
  /** staking_tx is the staking tx */
  stakingTx: Uint8Array;
  /** staking_output_idx is the index of the staking output in the staking tx */
  stakingOutputIdx: number;
  /**
   * slashing_tx is the slashing tx
   * It is partially signed by SK corresponding to btc_pk, but not signed by
   * finality provider or covenant yet.
   */
  slashingTx: Uint8Array;
  /**
   * delegator_sig is the signature on the slashing tx
   * by the delegator (i.e., SK corresponding to btc_pk).
   * It will be a part of the witness for the staking tx output.
   */
  delegatorSig: Uint8Array;
  /**
   * covenant_sigs is a list of adaptor signatures on the slashing tx
   * by each covenant member
   * It will be a part of the witness for the staking tx output.
   */
  covenantSigs: CovenantAdaptorSignatures[];
  /**
   * unbonding_time describes how long the funds will be locked either in unbonding output
   * or slashing change output
   */
  unbondingTime: number;
  /** btc_undelegation is the information about the early unbonding path of the BTC delegation */
  btcUndelegation: BTCUndelegation | undefined;
  /** version of the params used to validate the delegation */
  paramsVersion: number;
}

/** BTCUndelegation contains the information about the early unbonding path of the BTC delegation */
export interface BTCUndelegation {
  /**
   * unbonding_tx is the transaction which will transfer the funds from staking
   * output to unbonding output. Unbonding output will usually have lower timelock
   * than staking output.
   */
  unbondingTx: Uint8Array;
  /**
   * slashing_tx is the slashing tx for unbonding transactions
   * It is partially signed by SK corresponding to btc_pk, but not signed by
   * finality provider or covenant yet.
   */
  slashingTx: Uint8Array;
  /**
   * delegator_unbonding_sig is the signature on the unbonding tx
   * by the delegator (i.e., SK corresponding to btc_pk).
   * It effectively proves that the delegator wants to unbond and thus
   * Babylon will consider this BTC delegation unbonded. Delegator's BTC
   * on Bitcoin will be unbonded after timelock
   */
  delegatorUnbondingSig: Uint8Array;
  /**
   * delegator_slashing_sig is the signature on the slashing tx
   * by the delegator (i.e., SK corresponding to btc_pk).
   * It will be a part of the witness for the unbonding tx output.
   */
  delegatorSlashingSig: Uint8Array;
  /**
   * covenant_slashing_sigs is a list of adaptor signatures on the slashing tx
   * by each covenant member
   * It will be a part of the witness for the staking tx output.
   */
  covenantSlashingSigs: CovenantAdaptorSignatures[];
  /**
   * covenant_unbonding_sig_list is the list of signatures on the unbonding tx
   * by covenant members
   * It must be provided after processing undelegate message by Babylon
   */
  covenantUnbondingSigList: SignatureInfo[];
}

/** BTCDelegatorDelegations is a collection of BTC delegations from the same delegator. */
export interface BTCDelegatorDelegations {
  dels: BTCDelegation[];
}

/** BTCDelegatorDelegationIndex is a list of staking tx hashes of BTC delegations from the same delegator. */
export interface BTCDelegatorDelegationIndex {
  stakingTxHashList: Uint8Array[];
}

/** SignatureInfo is a BIP-340 signature together with its signer's BIP-340 PK */
export interface SignatureInfo {
  pk: Uint8Array;
  sig: Uint8Array;
}

/**
 * CovenantAdaptorSignatures is a list adaptor signatures signed by the
 * covenant with different finality provider's public keys as encryption keys
 */
export interface CovenantAdaptorSignatures {
  /** cov_pk is the public key of the covenant emulator, used as the public key of the adaptor signature */
  covPk: Uint8Array;
  /** adaptor_sigs is a list of adaptor signatures, each encrypted by a restaked BTC finality provider's public key */
  adaptorSigs: Uint8Array[];
}

/**
 * SelectiveSlashingEvidence is the evidence that the finality provider
 * selectively slashed a BTC delegation
 * NOTE: it's possible that a slashed finality provider exploits the
 * SelectiveSlashingEvidence endpoint while it is actually slashed due to
 * equivocation. But such behaviour does not affect the system's security
 * or gives any benefit for the adversary
 */
export interface SelectiveSlashingEvidence {
  /**
   * staking_tx_hash is the hash of the staking tx.
   * It uniquely identifies a BTC delegation
   */
  stakingTxHash: string;
  /**
   * fp_btc_pk is the BTC PK of the finality provider who
   * launches the selective slashing offence
   */
  fpBtcPk: Uint8Array;
  /**
   * recovered_fp_btc_sk is the finality provider's BTC SK recovered from
   * the covenant adaptor/Schnorr signature pair. It is the consequence
   * of selective slashing.
   */
  recoveredFpBtcSk: Uint8Array;
}

/**
 * InclusionProof proves the existence of tx on BTC blockchain
 * including
 * - the position of the tx on BTC blockchain
 * - the Merkle proof that this tx is on the above position
 */
export interface InclusionProof {
  /** key is the position (txIdx, blockHash) of this tx on BTC blockchain */
  key: TransactionKey | undefined;
  /** proof is the Merkle proof that this tx is included in the position in `key` */
  proof: Uint8Array;
}

function createBaseFinalityProvider(): FinalityProvider {
  return {
    addr: "",
    description: undefined,
    commission: "",
    btcPk: new Uint8Array(0),
    pop: undefined,
    slashedBabylonHeight: 0,
    slashedBtcHeight: 0,
    jailed: false,
  };
}

export const FinalityProvider: MessageFns<FinalityProvider> = {
  encode(
    message: FinalityProvider,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.addr !== "") {
      writer.uint32(10).string(message.addr);
    }
    if (message.description !== undefined) {
      Description.encode(message.description, writer.uint32(18).fork()).join();
    }
    if (message.commission !== "") {
      writer.uint32(26).string(message.commission);
    }
    if (message.btcPk.length !== 0) {
      writer.uint32(34).bytes(message.btcPk);
    }
    if (message.pop !== undefined) {
      ProofOfPossessionBTC.encode(message.pop, writer.uint32(42).fork()).join();
    }
    if (message.slashedBabylonHeight !== 0) {
      writer.uint32(48).uint64(message.slashedBabylonHeight);
    }
    if (message.slashedBtcHeight !== 0) {
      writer.uint32(56).uint32(message.slashedBtcHeight);
    }
    if (message.jailed !== false) {
      writer.uint32(64).bool(message.jailed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalityProvider {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalityProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.addr = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = Description.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.commission = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.btcPk = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pop = ProofOfPossessionBTC.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.slashedBabylonHeight = longToNumber(reader.uint64());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.slashedBtcHeight = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.jailed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalityProvider {
    return {
      addr: isSet(object.addr) ? globalThis.String(object.addr) : "",
      description: isSet(object.description)
        ? Description.fromJSON(object.description)
        : undefined,
      commission: isSet(object.commission)
        ? globalThis.String(object.commission)
        : "",
      btcPk: isSet(object.btcPk)
        ? bytesFromBase64(object.btcPk)
        : new Uint8Array(0),
      pop: isSet(object.pop)
        ? ProofOfPossessionBTC.fromJSON(object.pop)
        : undefined,
      slashedBabylonHeight: isSet(object.slashedBabylonHeight)
        ? globalThis.Number(object.slashedBabylonHeight)
        : 0,
      slashedBtcHeight: isSet(object.slashedBtcHeight)
        ? globalThis.Number(object.slashedBtcHeight)
        : 0,
      jailed: isSet(object.jailed) ? globalThis.Boolean(object.jailed) : false,
    };
  },

  toJSON(message: FinalityProvider): unknown {
    const obj: any = {};
    if (message.addr !== "") {
      obj.addr = message.addr;
    }
    if (message.description !== undefined) {
      obj.description = Description.toJSON(message.description);
    }
    if (message.commission !== "") {
      obj.commission = message.commission;
    }
    if (message.btcPk.length !== 0) {
      obj.btcPk = base64FromBytes(message.btcPk);
    }
    if (message.pop !== undefined) {
      obj.pop = ProofOfPossessionBTC.toJSON(message.pop);
    }
    if (message.slashedBabylonHeight !== 0) {
      obj.slashedBabylonHeight = Math.round(message.slashedBabylonHeight);
    }
    if (message.slashedBtcHeight !== 0) {
      obj.slashedBtcHeight = Math.round(message.slashedBtcHeight);
    }
    if (message.jailed !== false) {
      obj.jailed = message.jailed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FinalityProvider>, I>>(
    base?: I,
  ): FinalityProvider {
    return FinalityProvider.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FinalityProvider>, I>>(
    object: I,
  ): FinalityProvider {
    const message = createBaseFinalityProvider();
    message.addr = object.addr ?? "";
    message.description =
      object.description !== undefined && object.description !== null
        ? Description.fromPartial(object.description)
        : undefined;
    message.commission = object.commission ?? "";
    message.btcPk = object.btcPk ?? new Uint8Array(0);
    message.pop =
      object.pop !== undefined && object.pop !== null
        ? ProofOfPossessionBTC.fromPartial(object.pop)
        : undefined;
    message.slashedBabylonHeight = object.slashedBabylonHeight ?? 0;
    message.slashedBtcHeight = object.slashedBtcHeight ?? 0;
    message.jailed = object.jailed ?? false;
    return message;
  },
};

function createBaseFinalityProviderWithMeta(): FinalityProviderWithMeta {
  return {
    btcPk: new Uint8Array(0),
    height: 0,
    votingPower: 0,
    slashedBabylonHeight: 0,
    slashedBtcHeight: 0,
    jailed: false,
  };
}

export const FinalityProviderWithMeta: MessageFns<FinalityProviderWithMeta> = {
  encode(
    message: FinalityProviderWithMeta,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.btcPk.length !== 0) {
      writer.uint32(10).bytes(message.btcPk);
    }
    if (message.height !== 0) {
      writer.uint32(16).uint64(message.height);
    }
    if (message.votingPower !== 0) {
      writer.uint32(24).uint64(message.votingPower);
    }
    if (message.slashedBabylonHeight !== 0) {
      writer.uint32(32).uint64(message.slashedBabylonHeight);
    }
    if (message.slashedBtcHeight !== 0) {
      writer.uint32(40).uint32(message.slashedBtcHeight);
    }
    if (message.jailed !== false) {
      writer.uint32(48).bool(message.jailed);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): FinalityProviderWithMeta {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalityProviderWithMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.btcPk = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.votingPower = longToNumber(reader.uint64());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.slashedBabylonHeight = longToNumber(reader.uint64());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.slashedBtcHeight = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.jailed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalityProviderWithMeta {
    return {
      btcPk: isSet(object.btcPk)
        ? bytesFromBase64(object.btcPk)
        : new Uint8Array(0),
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      votingPower: isSet(object.votingPower)
        ? globalThis.Number(object.votingPower)
        : 0,
      slashedBabylonHeight: isSet(object.slashedBabylonHeight)
        ? globalThis.Number(object.slashedBabylonHeight)
        : 0,
      slashedBtcHeight: isSet(object.slashedBtcHeight)
        ? globalThis.Number(object.slashedBtcHeight)
        : 0,
      jailed: isSet(object.jailed) ? globalThis.Boolean(object.jailed) : false,
    };
  },

  toJSON(message: FinalityProviderWithMeta): unknown {
    const obj: any = {};
    if (message.btcPk.length !== 0) {
      obj.btcPk = base64FromBytes(message.btcPk);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.votingPower !== 0) {
      obj.votingPower = Math.round(message.votingPower);
    }
    if (message.slashedBabylonHeight !== 0) {
      obj.slashedBabylonHeight = Math.round(message.slashedBabylonHeight);
    }
    if (message.slashedBtcHeight !== 0) {
      obj.slashedBtcHeight = Math.round(message.slashedBtcHeight);
    }
    if (message.jailed !== false) {
      obj.jailed = message.jailed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FinalityProviderWithMeta>, I>>(
    base?: I,
  ): FinalityProviderWithMeta {
    return FinalityProviderWithMeta.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FinalityProviderWithMeta>, I>>(
    object: I,
  ): FinalityProviderWithMeta {
    const message = createBaseFinalityProviderWithMeta();
    message.btcPk = object.btcPk ?? new Uint8Array(0);
    message.height = object.height ?? 0;
    message.votingPower = object.votingPower ?? 0;
    message.slashedBabylonHeight = object.slashedBabylonHeight ?? 0;
    message.slashedBtcHeight = object.slashedBtcHeight ?? 0;
    message.jailed = object.jailed ?? false;
    return message;
  },
};

function createBaseBTCDelegation(): BTCDelegation {
  return {
    stakerAddr: "",
    btcPk: new Uint8Array(0),
    pop: undefined,
    fpBtcPkList: [],
    stakingTime: 0,
    startHeight: 0,
    endHeight: 0,
    totalSat: 0,
    stakingTx: new Uint8Array(0),
    stakingOutputIdx: 0,
    slashingTx: new Uint8Array(0),
    delegatorSig: new Uint8Array(0),
    covenantSigs: [],
    unbondingTime: 0,
    btcUndelegation: undefined,
    paramsVersion: 0,
  };
}

export const BTCDelegation: MessageFns<BTCDelegation> = {
  encode(
    message: BTCDelegation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.stakerAddr !== "") {
      writer.uint32(10).string(message.stakerAddr);
    }
    if (message.btcPk.length !== 0) {
      writer.uint32(18).bytes(message.btcPk);
    }
    if (message.pop !== undefined) {
      ProofOfPossessionBTC.encode(message.pop, writer.uint32(26).fork()).join();
    }
    for (const v of message.fpBtcPkList) {
      writer.uint32(34).bytes(v!);
    }
    if (message.stakingTime !== 0) {
      writer.uint32(40).uint32(message.stakingTime);
    }
    if (message.startHeight !== 0) {
      writer.uint32(48).uint32(message.startHeight);
    }
    if (message.endHeight !== 0) {
      writer.uint32(56).uint32(message.endHeight);
    }
    if (message.totalSat !== 0) {
      writer.uint32(64).uint64(message.totalSat);
    }
    if (message.stakingTx.length !== 0) {
      writer.uint32(74).bytes(message.stakingTx);
    }
    if (message.stakingOutputIdx !== 0) {
      writer.uint32(80).uint32(message.stakingOutputIdx);
    }
    if (message.slashingTx.length !== 0) {
      writer.uint32(90).bytes(message.slashingTx);
    }
    if (message.delegatorSig.length !== 0) {
      writer.uint32(98).bytes(message.delegatorSig);
    }
    for (const v of message.covenantSigs) {
      CovenantAdaptorSignatures.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.unbondingTime !== 0) {
      writer.uint32(112).uint32(message.unbondingTime);
    }
    if (message.btcUndelegation !== undefined) {
      BTCUndelegation.encode(
        message.btcUndelegation,
        writer.uint32(122).fork(),
      ).join();
    }
    if (message.paramsVersion !== 0) {
      writer.uint32(128).uint32(message.paramsVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BTCDelegation {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCDelegation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stakerAddr = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.btcPk = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pop = ProofOfPossessionBTC.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fpBtcPkList.push(reader.bytes());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.stakingTime = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.startHeight = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.endHeight = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.totalSat = longToNumber(reader.uint64());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.stakingTx = reader.bytes();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.stakingOutputIdx = reader.uint32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.slashingTx = reader.bytes();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.delegatorSig = reader.bytes();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.covenantSigs.push(
            CovenantAdaptorSignatures.decode(reader, reader.uint32()),
          );
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.unbondingTime = reader.uint32();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.btcUndelegation = BTCUndelegation.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.paramsVersion = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCDelegation {
    return {
      stakerAddr: isSet(object.stakerAddr)
        ? globalThis.String(object.stakerAddr)
        : "",
      btcPk: isSet(object.btcPk)
        ? bytesFromBase64(object.btcPk)
        : new Uint8Array(0),
      pop: isSet(object.pop)
        ? ProofOfPossessionBTC.fromJSON(object.pop)
        : undefined,
      fpBtcPkList: globalThis.Array.isArray(object?.fpBtcPkList)
        ? object.fpBtcPkList.map((e: any) => bytesFromBase64(e))
        : [],
      stakingTime: isSet(object.stakingTime)
        ? globalThis.Number(object.stakingTime)
        : 0,
      startHeight: isSet(object.startHeight)
        ? globalThis.Number(object.startHeight)
        : 0,
      endHeight: isSet(object.endHeight)
        ? globalThis.Number(object.endHeight)
        : 0,
      totalSat: isSet(object.totalSat) ? globalThis.Number(object.totalSat) : 0,
      stakingTx: isSet(object.stakingTx)
        ? bytesFromBase64(object.stakingTx)
        : new Uint8Array(0),
      stakingOutputIdx: isSet(object.stakingOutputIdx)
        ? globalThis.Number(object.stakingOutputIdx)
        : 0,
      slashingTx: isSet(object.slashingTx)
        ? bytesFromBase64(object.slashingTx)
        : new Uint8Array(0),
      delegatorSig: isSet(object.delegatorSig)
        ? bytesFromBase64(object.delegatorSig)
        : new Uint8Array(0),
      covenantSigs: globalThis.Array.isArray(object?.covenantSigs)
        ? object.covenantSigs.map((e: any) =>
            CovenantAdaptorSignatures.fromJSON(e),
          )
        : [],
      unbondingTime: isSet(object.unbondingTime)
        ? globalThis.Number(object.unbondingTime)
        : 0,
      btcUndelegation: isSet(object.btcUndelegation)
        ? BTCUndelegation.fromJSON(object.btcUndelegation)
        : undefined,
      paramsVersion: isSet(object.paramsVersion)
        ? globalThis.Number(object.paramsVersion)
        : 0,
    };
  },

  toJSON(message: BTCDelegation): unknown {
    const obj: any = {};
    if (message.stakerAddr !== "") {
      obj.stakerAddr = message.stakerAddr;
    }
    if (message.btcPk.length !== 0) {
      obj.btcPk = base64FromBytes(message.btcPk);
    }
    if (message.pop !== undefined) {
      obj.pop = ProofOfPossessionBTC.toJSON(message.pop);
    }
    if (message.fpBtcPkList?.length) {
      obj.fpBtcPkList = message.fpBtcPkList.map((e) => base64FromBytes(e));
    }
    if (message.stakingTime !== 0) {
      obj.stakingTime = Math.round(message.stakingTime);
    }
    if (message.startHeight !== 0) {
      obj.startHeight = Math.round(message.startHeight);
    }
    if (message.endHeight !== 0) {
      obj.endHeight = Math.round(message.endHeight);
    }
    if (message.totalSat !== 0) {
      obj.totalSat = Math.round(message.totalSat);
    }
    if (message.stakingTx.length !== 0) {
      obj.stakingTx = base64FromBytes(message.stakingTx);
    }
    if (message.stakingOutputIdx !== 0) {
      obj.stakingOutputIdx = Math.round(message.stakingOutputIdx);
    }
    if (message.slashingTx.length !== 0) {
      obj.slashingTx = base64FromBytes(message.slashingTx);
    }
    if (message.delegatorSig.length !== 0) {
      obj.delegatorSig = base64FromBytes(message.delegatorSig);
    }
    if (message.covenantSigs?.length) {
      obj.covenantSigs = message.covenantSigs.map((e) =>
        CovenantAdaptorSignatures.toJSON(e),
      );
    }
    if (message.unbondingTime !== 0) {
      obj.unbondingTime = Math.round(message.unbondingTime);
    }
    if (message.btcUndelegation !== undefined) {
      obj.btcUndelegation = BTCUndelegation.toJSON(message.btcUndelegation);
    }
    if (message.paramsVersion !== 0) {
      obj.paramsVersion = Math.round(message.paramsVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BTCDelegation>, I>>(
    base?: I,
  ): BTCDelegation {
    return BTCDelegation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BTCDelegation>, I>>(
    object: I,
  ): BTCDelegation {
    const message = createBaseBTCDelegation();
    message.stakerAddr = object.stakerAddr ?? "";
    message.btcPk = object.btcPk ?? new Uint8Array(0);
    message.pop =
      object.pop !== undefined && object.pop !== null
        ? ProofOfPossessionBTC.fromPartial(object.pop)
        : undefined;
    message.fpBtcPkList = object.fpBtcPkList?.map((e) => e) || [];
    message.stakingTime = object.stakingTime ?? 0;
    message.startHeight = object.startHeight ?? 0;
    message.endHeight = object.endHeight ?? 0;
    message.totalSat = object.totalSat ?? 0;
    message.stakingTx = object.stakingTx ?? new Uint8Array(0);
    message.stakingOutputIdx = object.stakingOutputIdx ?? 0;
    message.slashingTx = object.slashingTx ?? new Uint8Array(0);
    message.delegatorSig = object.delegatorSig ?? new Uint8Array(0);
    message.covenantSigs =
      object.covenantSigs?.map((e) =>
        CovenantAdaptorSignatures.fromPartial(e),
      ) || [];
    message.unbondingTime = object.unbondingTime ?? 0;
    message.btcUndelegation =
      object.btcUndelegation !== undefined && object.btcUndelegation !== null
        ? BTCUndelegation.fromPartial(object.btcUndelegation)
        : undefined;
    message.paramsVersion = object.paramsVersion ?? 0;
    return message;
  },
};

function createBaseBTCUndelegation(): BTCUndelegation {
  return {
    unbondingTx: new Uint8Array(0),
    slashingTx: new Uint8Array(0),
    delegatorUnbondingSig: new Uint8Array(0),
    delegatorSlashingSig: new Uint8Array(0),
    covenantSlashingSigs: [],
    covenantUnbondingSigList: [],
  };
}

export const BTCUndelegation: MessageFns<BTCUndelegation> = {
  encode(
    message: BTCUndelegation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.unbondingTx.length !== 0) {
      writer.uint32(10).bytes(message.unbondingTx);
    }
    if (message.slashingTx.length !== 0) {
      writer.uint32(18).bytes(message.slashingTx);
    }
    if (message.delegatorUnbondingSig.length !== 0) {
      writer.uint32(26).bytes(message.delegatorUnbondingSig);
    }
    if (message.delegatorSlashingSig.length !== 0) {
      writer.uint32(34).bytes(message.delegatorSlashingSig);
    }
    for (const v of message.covenantSlashingSigs) {
      CovenantAdaptorSignatures.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.covenantUnbondingSigList) {
      SignatureInfo.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BTCUndelegation {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCUndelegation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.unbondingTx = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.slashingTx = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.delegatorUnbondingSig = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.delegatorSlashingSig = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.covenantSlashingSigs.push(
            CovenantAdaptorSignatures.decode(reader, reader.uint32()),
          );
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.covenantUnbondingSigList.push(
            SignatureInfo.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCUndelegation {
    return {
      unbondingTx: isSet(object.unbondingTx)
        ? bytesFromBase64(object.unbondingTx)
        : new Uint8Array(0),
      slashingTx: isSet(object.slashingTx)
        ? bytesFromBase64(object.slashingTx)
        : new Uint8Array(0),
      delegatorUnbondingSig: isSet(object.delegatorUnbondingSig)
        ? bytesFromBase64(object.delegatorUnbondingSig)
        : new Uint8Array(0),
      delegatorSlashingSig: isSet(object.delegatorSlashingSig)
        ? bytesFromBase64(object.delegatorSlashingSig)
        : new Uint8Array(0),
      covenantSlashingSigs: globalThis.Array.isArray(
        object?.covenantSlashingSigs,
      )
        ? object.covenantSlashingSigs.map((e: any) =>
            CovenantAdaptorSignatures.fromJSON(e),
          )
        : [],
      covenantUnbondingSigList: globalThis.Array.isArray(
        object?.covenantUnbondingSigList,
      )
        ? object.covenantUnbondingSigList.map((e: any) =>
            SignatureInfo.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: BTCUndelegation): unknown {
    const obj: any = {};
    if (message.unbondingTx.length !== 0) {
      obj.unbondingTx = base64FromBytes(message.unbondingTx);
    }
    if (message.slashingTx.length !== 0) {
      obj.slashingTx = base64FromBytes(message.slashingTx);
    }
    if (message.delegatorUnbondingSig.length !== 0) {
      obj.delegatorUnbondingSig = base64FromBytes(
        message.delegatorUnbondingSig,
      );
    }
    if (message.delegatorSlashingSig.length !== 0) {
      obj.delegatorSlashingSig = base64FromBytes(message.delegatorSlashingSig);
    }
    if (message.covenantSlashingSigs?.length) {
      obj.covenantSlashingSigs = message.covenantSlashingSigs.map((e) =>
        CovenantAdaptorSignatures.toJSON(e),
      );
    }
    if (message.covenantUnbondingSigList?.length) {
      obj.covenantUnbondingSigList = message.covenantUnbondingSigList.map((e) =>
        SignatureInfo.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BTCUndelegation>, I>>(
    base?: I,
  ): BTCUndelegation {
    return BTCUndelegation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BTCUndelegation>, I>>(
    object: I,
  ): BTCUndelegation {
    const message = createBaseBTCUndelegation();
    message.unbondingTx = object.unbondingTx ?? new Uint8Array(0);
    message.slashingTx = object.slashingTx ?? new Uint8Array(0);
    message.delegatorUnbondingSig =
      object.delegatorUnbondingSig ?? new Uint8Array(0);
    message.delegatorSlashingSig =
      object.delegatorSlashingSig ?? new Uint8Array(0);
    message.covenantSlashingSigs =
      object.covenantSlashingSigs?.map((e) =>
        CovenantAdaptorSignatures.fromPartial(e),
      ) || [];
    message.covenantUnbondingSigList =
      object.covenantUnbondingSigList?.map((e) =>
        SignatureInfo.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseBTCDelegatorDelegations(): BTCDelegatorDelegations {
  return { dels: [] };
}

export const BTCDelegatorDelegations: MessageFns<BTCDelegatorDelegations> = {
  encode(
    message: BTCDelegatorDelegations,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.dels) {
      BTCDelegation.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): BTCDelegatorDelegations {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCDelegatorDelegations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dels.push(BTCDelegation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCDelegatorDelegations {
    return {
      dels: globalThis.Array.isArray(object?.dels)
        ? object.dels.map((e: any) => BTCDelegation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BTCDelegatorDelegations): unknown {
    const obj: any = {};
    if (message.dels?.length) {
      obj.dels = message.dels.map((e) => BTCDelegation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BTCDelegatorDelegations>, I>>(
    base?: I,
  ): BTCDelegatorDelegations {
    return BTCDelegatorDelegations.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BTCDelegatorDelegations>, I>>(
    object: I,
  ): BTCDelegatorDelegations {
    const message = createBaseBTCDelegatorDelegations();
    message.dels = object.dels?.map((e) => BTCDelegation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBTCDelegatorDelegationIndex(): BTCDelegatorDelegationIndex {
  return { stakingTxHashList: [] };
}

export const BTCDelegatorDelegationIndex: MessageFns<BTCDelegatorDelegationIndex> =
  {
    encode(
      message: BTCDelegatorDelegationIndex,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.stakingTxHashList) {
        writer.uint32(10).bytes(v!);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): BTCDelegatorDelegationIndex {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseBTCDelegatorDelegationIndex();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.stakingTxHashList.push(reader.bytes());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): BTCDelegatorDelegationIndex {
      return {
        stakingTxHashList: globalThis.Array.isArray(object?.stakingTxHashList)
          ? object.stakingTxHashList.map((e: any) => bytesFromBase64(e))
          : [],
      };
    },

    toJSON(message: BTCDelegatorDelegationIndex): unknown {
      const obj: any = {};
      if (message.stakingTxHashList?.length) {
        obj.stakingTxHashList = message.stakingTxHashList.map((e) =>
          base64FromBytes(e),
        );
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<BTCDelegatorDelegationIndex>, I>>(
      base?: I,
    ): BTCDelegatorDelegationIndex {
      return BTCDelegatorDelegationIndex.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<BTCDelegatorDelegationIndex>, I>>(
      object: I,
    ): BTCDelegatorDelegationIndex {
      const message = createBaseBTCDelegatorDelegationIndex();
      message.stakingTxHashList = object.stakingTxHashList?.map((e) => e) || [];
      return message;
    },
  };

function createBaseSignatureInfo(): SignatureInfo {
  return { pk: new Uint8Array(0), sig: new Uint8Array(0) };
}

export const SignatureInfo: MessageFns<SignatureInfo> = {
  encode(
    message: SignatureInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.pk.length !== 0) {
      writer.uint32(10).bytes(message.pk);
    }
    if (message.sig.length !== 0) {
      writer.uint32(18).bytes(message.sig);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignatureInfo {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignatureInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pk = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sig = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignatureInfo {
    return {
      pk: isSet(object.pk) ? bytesFromBase64(object.pk) : new Uint8Array(0),
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : new Uint8Array(0),
    };
  },

  toJSON(message: SignatureInfo): unknown {
    const obj: any = {};
    if (message.pk.length !== 0) {
      obj.pk = base64FromBytes(message.pk);
    }
    if (message.sig.length !== 0) {
      obj.sig = base64FromBytes(message.sig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignatureInfo>, I>>(
    base?: I,
  ): SignatureInfo {
    return SignatureInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignatureInfo>, I>>(
    object: I,
  ): SignatureInfo {
    const message = createBaseSignatureInfo();
    message.pk = object.pk ?? new Uint8Array(0);
    message.sig = object.sig ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCovenantAdaptorSignatures(): CovenantAdaptorSignatures {
  return { covPk: new Uint8Array(0), adaptorSigs: [] };
}

export const CovenantAdaptorSignatures: MessageFns<CovenantAdaptorSignatures> =
  {
    encode(
      message: CovenantAdaptorSignatures,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.covPk.length !== 0) {
        writer.uint32(10).bytes(message.covPk);
      }
      for (const v of message.adaptorSigs) {
        writer.uint32(18).bytes(v!);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CovenantAdaptorSignatures {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCovenantAdaptorSignatures();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.covPk = reader.bytes();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.adaptorSigs.push(reader.bytes());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CovenantAdaptorSignatures {
      return {
        covPk: isSet(object.covPk)
          ? bytesFromBase64(object.covPk)
          : new Uint8Array(0),
        adaptorSigs: globalThis.Array.isArray(object?.adaptorSigs)
          ? object.adaptorSigs.map((e: any) => bytesFromBase64(e))
          : [],
      };
    },

    toJSON(message: CovenantAdaptorSignatures): unknown {
      const obj: any = {};
      if (message.covPk.length !== 0) {
        obj.covPk = base64FromBytes(message.covPk);
      }
      if (message.adaptorSigs?.length) {
        obj.adaptorSigs = message.adaptorSigs.map((e) => base64FromBytes(e));
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<CovenantAdaptorSignatures>, I>>(
      base?: I,
    ): CovenantAdaptorSignatures {
      return CovenantAdaptorSignatures.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<CovenantAdaptorSignatures>, I>>(
      object: I,
    ): CovenantAdaptorSignatures {
      const message = createBaseCovenantAdaptorSignatures();
      message.covPk = object.covPk ?? new Uint8Array(0);
      message.adaptorSigs = object.adaptorSigs?.map((e) => e) || [];
      return message;
    },
  };

function createBaseSelectiveSlashingEvidence(): SelectiveSlashingEvidence {
  return {
    stakingTxHash: "",
    fpBtcPk: new Uint8Array(0),
    recoveredFpBtcSk: new Uint8Array(0),
  };
}

export const SelectiveSlashingEvidence: MessageFns<SelectiveSlashingEvidence> =
  {
    encode(
      message: SelectiveSlashingEvidence,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.stakingTxHash !== "") {
        writer.uint32(10).string(message.stakingTxHash);
      }
      if (message.fpBtcPk.length !== 0) {
        writer.uint32(18).bytes(message.fpBtcPk);
      }
      if (message.recoveredFpBtcSk.length !== 0) {
        writer.uint32(26).bytes(message.recoveredFpBtcSk);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): SelectiveSlashingEvidence {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseSelectiveSlashingEvidence();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.stakingTxHash = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.fpBtcPk = reader.bytes();
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }

            message.recoveredFpBtcSk = reader.bytes();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): SelectiveSlashingEvidence {
      return {
        stakingTxHash: isSet(object.stakingTxHash)
          ? globalThis.String(object.stakingTxHash)
          : "",
        fpBtcPk: isSet(object.fpBtcPk)
          ? bytesFromBase64(object.fpBtcPk)
          : new Uint8Array(0),
        recoveredFpBtcSk: isSet(object.recoveredFpBtcSk)
          ? bytesFromBase64(object.recoveredFpBtcSk)
          : new Uint8Array(0),
      };
    },

    toJSON(message: SelectiveSlashingEvidence): unknown {
      const obj: any = {};
      if (message.stakingTxHash !== "") {
        obj.stakingTxHash = message.stakingTxHash;
      }
      if (message.fpBtcPk.length !== 0) {
        obj.fpBtcPk = base64FromBytes(message.fpBtcPk);
      }
      if (message.recoveredFpBtcSk.length !== 0) {
        obj.recoveredFpBtcSk = base64FromBytes(message.recoveredFpBtcSk);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<SelectiveSlashingEvidence>, I>>(
      base?: I,
    ): SelectiveSlashingEvidence {
      return SelectiveSlashingEvidence.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<SelectiveSlashingEvidence>, I>>(
      object: I,
    ): SelectiveSlashingEvidence {
      const message = createBaseSelectiveSlashingEvidence();
      message.stakingTxHash = object.stakingTxHash ?? "";
      message.fpBtcPk = object.fpBtcPk ?? new Uint8Array(0);
      message.recoveredFpBtcSk = object.recoveredFpBtcSk ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseInclusionProof(): InclusionProof {
  return { key: undefined, proof: new Uint8Array(0) };
}

export const InclusionProof: MessageFns<InclusionProof> = {
  encode(
    message: InclusionProof,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== undefined) {
      TransactionKey.encode(message.key, writer.uint32(10).fork()).join();
    }
    if (message.proof.length !== 0) {
      writer.uint32(18).bytes(message.proof);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InclusionProof {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInclusionProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = TransactionKey.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.proof = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InclusionProof {
    return {
      key: isSet(object.key) ? TransactionKey.fromJSON(object.key) : undefined,
      proof: isSet(object.proof)
        ? bytesFromBase64(object.proof)
        : new Uint8Array(0),
    };
  },

  toJSON(message: InclusionProof): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = TransactionKey.toJSON(message.key);
    }
    if (message.proof.length !== 0) {
      obj.proof = base64FromBytes(message.proof);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InclusionProof>, I>>(
    base?: I,
  ): InclusionProof {
    return InclusionProof.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InclusionProof>, I>>(
    object: I,
  ): InclusionProof {
    const message = createBaseInclusionProof();
    message.key =
      object.key !== undefined && object.key !== null
        ? TransactionKey.fromPartial(object.key)
        : undefined;
    message.proof = object.proof ?? new Uint8Array(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
