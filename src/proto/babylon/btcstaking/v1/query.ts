// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: babylon/btcstaking/v1/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  PageRequest,
  PageResponse,
} from "../../../cosmos/base/query/v1beta1/pagination";
import { Description } from "../../../cosmos/staking/v1beta1/staking";
import {
  BTCDelegationStatus,
  bTCDelegationStatusFromJSON,
  bTCDelegationStatusToJSON,
  CovenantAdaptorSignatures,
  SignatureInfo,
} from "./btcstaking";
import { Params } from "./params";
import { ProofOfPossessionBTC } from "./pop";

export const protobufPackage = "babylon.btcstaking.v1";

/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {}

/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
  /** params holds all the parameters of this module. */
  params: Params | undefined;
}

/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsByVersionRequest {
  version: number;
}

/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsByVersionResponse {
  /** params holds all the parameters of this module. */
  params: Params | undefined;
}

/**
 * QueryFinalityProvidersRequest is the request type for the
 * Query/FinalityProviders RPC method.
 */
export interface QueryFinalityProvidersRequest {
  /** pagination defines an optional pagination for the request. */
  pagination: PageRequest | undefined;
}

/**
 * QueryFinalityProvidersResponse is the response type for the
 * Query/FinalityProviders RPC method.
 */
export interface QueryFinalityProvidersResponse {
  /** finality_providers contains all the finality providers */
  finalityProviders: FinalityProviderResponse[];
  /** pagination defines the pagination in the response. */
  pagination: PageResponse | undefined;
}

/** QueryFinalityProviderRequest requests information about a finality provider */
export interface QueryFinalityProviderRequest {
  /** fp_btc_pk_hex is the hex str of Bitcoin secp256k1 PK of the finality provider */
  fpBtcPkHex: string;
}

/** QueryFinalityProviderResponse contains information about a finality provider */
export interface QueryFinalityProviderResponse {
  /** finality_provider contains the FinalityProvider */
  finalityProvider: FinalityProviderResponse | undefined;
}

/**
 * QueryBTCDelegationsRequest is the request type for the
 * Query/BTCDelegations RPC method.
 */
export interface QueryBTCDelegationsRequest {
  /** status is the queried status for BTC delegations */
  status: BTCDelegationStatus;
  /** pagination defines an optional pagination for the request. */
  pagination: PageRequest | undefined;
}

/**
 * QueryBTCDelegationsResponse is the response type for the
 * Query/BTCDelegations RPC method.
 */
export interface QueryBTCDelegationsResponse {
  /** btc_delegations contains all the queried BTC delegations under the given status */
  btcDelegations: BTCDelegationResponse[];
  /** pagination defines the pagination in the response. */
  pagination: PageResponse | undefined;
}

/**
 * QueryFinalityProviderPowerAtHeightRequest is the request type for the
 * Query/FinalityProviderPowerAtHeight RPC method.
 */
export interface QueryFinalityProviderPowerAtHeightRequest {
  /**
   * fp_btc_pk_hex is the hex str of Bitcoin secp256k1 PK of the finality provider that
   * this BTC delegation delegates to
   * the PK follows encoding in BIP-340 spec
   */
  fpBtcPkHex: string;
  /** height is used for querying the given finality provider's voting power at this height */
  height: number;
}

/**
 * QueryFinalityProviderPowerAtHeightResponse is the response type for the
 * Query/FinalityProviderPowerAtHeight RPC method.
 */
export interface QueryFinalityProviderPowerAtHeightResponse {
  /** voting_power is the voting power of the finality provider */
  votingPower: number;
}

/**
 * QueryFinalityProviderCurrentPowerRequest is the request type for the
 * Query/FinalityProviderCurrentPower RPC method.
 */
export interface QueryFinalityProviderCurrentPowerRequest {
  /**
   * fp_btc_pk_hex is the hex str of Bitcoin secp256k1 PK of the finality provider that
   * this BTC delegation delegates to
   * the PK follows encoding in BIP-340 spec
   */
  fpBtcPkHex: string;
}

/**
 * QueryFinalityProviderCurrentPowerResponse is the response type for the
 * Query/FinalityProviderCurrentPower RPC method.
 */
export interface QueryFinalityProviderCurrentPowerResponse {
  /** height is the current height */
  height: number;
  /** voting_power is the voting power of the finality provider */
  votingPower: number;
}

/**
 * QueryActiveFinalityProvidersAtHeightRequest is the request type for the
 * Query/ActiveFinalityProvidersAtHeight RPC method.
 */
export interface QueryActiveFinalityProvidersAtHeightRequest {
  /** height defines at which Babylon height to query the finality providers info. */
  height: number;
  /** pagination defines an optional pagination for the request. */
  pagination: PageRequest | undefined;
}

/** ActiveFinalityProvidersAtHeightResponse wraps the FinalityProvider with metadata. */
export interface ActiveFinalityProvidersAtHeightResponse {
  /**
   * btc_pk is the Bitcoin secp256k1 PK of thisfinality provider
   * the PK follows encoding in BIP-340 spec
   */
  btcPkHex: string;
  /** height is the queried Babylon height */
  height: number;
  /** voting_power is the voting power of this finality provider at the given height */
  votingPower: number;
  /**
   * slashed_babylon_height indicates the Babylon height when
   * the finality provider is slashed.
   * if it's 0 then the finality provider is not slashed
   */
  slashedBabylonHeight: number;
  /**
   * slashed_btc_height indicates the BTC height when
   * the finality provider is slashed.
   * if it's 0 then the finality provider is not slashed
   */
  slashedBtcHeight: number;
  /** jailed defines whether the finality provider is detected jailed */
  jailed: boolean;
}

/**
 * QueryActiveFinalityProvidersAtHeightResponse is the response type for the
 * Query/ActiveFinalityProvidersAtHeight RPC method.
 */
export interface QueryActiveFinalityProvidersAtHeightResponse {
  /** finality_providers contains all the queried finality providersn. */
  finalityProviders: ActiveFinalityProvidersAtHeightResponse[];
  /** pagination defines the pagination in the response. */
  pagination: PageResponse | undefined;
}

/** QueryActivatedHeightRequest is the request type for the Query/ActivatedHeight RPC method. */
export interface QueryActivatedHeightRequest {}

/** QueryActivatedHeightResponse is the response type for the Query/ActivatedHeight RPC method. */
export interface QueryActivatedHeightResponse {
  height: number;
}

/**
 * QueryFinalityProviderDelegationsRequest is the request type for the
 * Query/FinalityProviderDelegations RPC method.
 */
export interface QueryFinalityProviderDelegationsRequest {
  /**
   * fp_btc_pk_hex is the hex str of Bitcoin secp256k1 PK of the finality providerthat
   * this BTC delegation delegates to
   * the PK follows encoding in BIP-340 spec
   */
  fpBtcPkHex: string;
  /** pagination defines an optional pagination for the request. */
  pagination: PageRequest | undefined;
}

/**
 * QueryFinalityProviderDelegationsResponse is the response type for the
 * Query/FinalityProviderDelegations RPC method.
 */
export interface QueryFinalityProviderDelegationsResponse {
  /** btc_delegator_delegations contains all the queried BTC delegations. */
  btcDelegatorDelegations: BTCDelegatorDelegationsResponse[];
  /** pagination defines the pagination in the response. */
  pagination: PageResponse | undefined;
}

/**
 * QueryBTCDelegationRequest is the request type to retrieve a BTC delegation by
 * staking tx hash
 */
export interface QueryBTCDelegationRequest {
  /** Hash of staking transaction in btc format */
  stakingTxHashHex: string;
}

/**
 * QueryBTCDelegationResponse is response type matching QueryBTCDelegationRequest
 * and containing BTC delegation information
 */
export interface QueryBTCDelegationResponse {
  /** BTCDelegation represents the client needed information of an BTCDelegation. */
  btcDelegation: BTCDelegationResponse | undefined;
}

/** BTCDelegationResponse is the client needed information from a BTCDelegation with the current status based on parameters. */
export interface BTCDelegationResponse {
  /** staker_addr is the address to receive rewards from BTC delegation. */
  stakerAddr: string;
  /**
   * btc_pk is the Bitcoin secp256k1 PK of this BTC delegation
   * the PK follows encoding in BIP-340 spec
   */
  btcPk: Uint8Array;
  /**
   * fp_btc_pk_list is the list of BIP-340 PKs of the finality providers that
   * this BTC delegation delegates to
   */
  fpBtcPkList: Uint8Array[];
  /** staking_time is the number of blocks for which the delegation is locked on BTC chain */
  stakingTime: number;
  /**
   * start_height is the start BTC height of the BTC delegation
   * it is the start BTC height of the timelock
   */
  startHeight: number;
  /**
   * end_height is the end height of the BTC delegation
   * it is the end BTC height of the timelock - w
   */
  endHeight: number;
  /**
   * total_sat is the total amount of BTC stakes in this delegation
   * quantified in satoshi
   */
  totalSat: number;
  /** staking_tx_hex is the hex string of staking tx */
  stakingTxHex: string;
  /** slashing_tx_hex is the hex string of slashing tx */
  slashingTxHex: string;
  /**
   * delegator_slash_sig_hex is the signature on the slashing tx
   * by the delegator (i.e., SK corresponding to btc_pk) as string hex.
   * It will be a part of the witness for the staking tx output.
   */
  delegatorSlashSigHex: string;
  /**
   * covenant_sigs is a list of adaptor signatures on the slashing tx
   * by each covenant member
   * It will be a part of the witness for the staking tx output.
   */
  covenantSigs: CovenantAdaptorSignatures[];
  /** staking_output_idx is the index of the staking output in the staking tx */
  stakingOutputIdx: number;
  /** whether this delegation is active */
  active: boolean;
  /** descriptive status of current delegation. */
  statusDesc: string;
  /**
   * unbonding_time used in unbonding output timelock path and in slashing transactions
   * change outputs
   */
  unbondingTime: number;
  /** undelegation_response is the undelegation info of this delegation. */
  undelegationResponse: BTCUndelegationResponse | undefined;
  /** params version used to validate delegation */
  paramsVersion: number;
}

/** BTCUndelegationResponse provides all necessary info about the undeleagation */
export interface BTCUndelegationResponse {
  /**
   * unbonding_tx is the transaction which will transfer the funds from staking
   * output to unbonding output. Unbonding output will usually have lower timelock
   * than staking output. The unbonding tx as string hex.
   */
  unbondingTxHex: string;
  /**
   * delegator_unbonding_sig is the signature on the unbonding tx
   * by the delegator (i.e., SK corresponding to btc_pk).
   * It effectively proves that the delegator wants to unbond and thus
   * Babylon will consider this BTC delegation unbonded. Delegator's BTC
   * on Bitcoin will be unbonded after timelock. The unbonding delegator sig as string hex.
   */
  delegatorUnbondingSigHex: string;
  /**
   * covenant_unbonding_sig_list is the list of signatures on the unbonding tx
   * by covenant members
   */
  covenantUnbondingSigList: SignatureInfo[];
  /** slashingTxHex is the hex string of slashing tx */
  slashingTxHex: string;
  /**
   * delegator_slashing_sig is the signature on the slashing tx
   * by the delegator (i.e., SK corresponding to btc_pk).
   * It will be a part of the witness for the unbonding tx output.
   * The delegator slashing sig as string hex.
   */
  delegatorSlashingSigHex: string;
  /**
   * covenant_slashing_sigs is a list of adaptor signatures on the
   * unbonding slashing tx by each covenant member
   * It will be a part of the witness for the staking tx output.
   */
  covenantSlashingSigs: CovenantAdaptorSignatures[];
}

/** BTCDelegatorDelegationsResponse is a collection of BTC delegations responses from the same delegator. */
export interface BTCDelegatorDelegationsResponse {
  dels: BTCDelegationResponse[];
}

/** FinalityProviderResponse defines a finality provider with voting power information. */
export interface FinalityProviderResponse {
  /** description defines the description terms for the finality provider. */
  description: Description | undefined;
  /** commission defines the commission rate of the finality provider. */
  commission: string;
  /** addr is the address to receive commission from delegations. */
  addr: string;
  /**
   * btc_pk is the Bitcoin secp256k1 PK of this finality provider
   * the PK follows encoding in BIP-340 spec
   */
  btcPk: Uint8Array;
  /**
   * pop is the proof of possession of the BTC_PK by the fp addr.
   * Essentially is the signature where the BTC SK sigs the fp addr.
   */
  pop: ProofOfPossessionBTC | undefined;
  /**
   * slashed_babylon_height indicates the Babylon height when
   * the finality provider is slashed.
   * if it's 0 then the finality provider is not slashed
   */
  slashedBabylonHeight: number;
  /**
   * slashed_btc_height indicates the BTC height when
   * the finality provider is slashed.
   * if it's 0 then the finality provider is not slashed
   */
  slashedBtcHeight: number;
  /** height is the queried Babylon height */
  height: number;
  /** voting_power is the voting power of this finality provider at the given height */
  votingPower: number;
  /** jailed defines whether the finality provider is jailed */
  jailed: boolean;
}

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(
    _: QueryParamsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryParamsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(
    base?: I,
  ): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(
    _: I,
  ): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(
    message: QueryParamsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryParamsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return {
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(
    base?: I,
  ): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(
    object: I,
  ): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params =
      object.params !== undefined && object.params !== null
        ? Params.fromPartial(object.params)
        : undefined;
    return message;
  },
};

function createBaseQueryParamsByVersionRequest(): QueryParamsByVersionRequest {
  return { version: 0 };
}

export const QueryParamsByVersionRequest: MessageFns<QueryParamsByVersionRequest> =
  {
    encode(
      message: QueryParamsByVersionRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.version !== 0) {
        writer.uint32(8).uint32(message.version);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryParamsByVersionRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryParamsByVersionRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }

            message.version = reader.uint32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryParamsByVersionRequest {
      return {
        version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      };
    },

    toJSON(message: QueryParamsByVersionRequest): unknown {
      const obj: any = {};
      if (message.version !== 0) {
        obj.version = Math.round(message.version);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryParamsByVersionRequest>, I>>(
      base?: I,
    ): QueryParamsByVersionRequest {
      return QueryParamsByVersionRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryParamsByVersionRequest>, I>>(
      object: I,
    ): QueryParamsByVersionRequest {
      const message = createBaseQueryParamsByVersionRequest();
      message.version = object.version ?? 0;
      return message;
    },
  };

function createBaseQueryParamsByVersionResponse(): QueryParamsByVersionResponse {
  return { params: undefined };
}

export const QueryParamsByVersionResponse: MessageFns<QueryParamsByVersionResponse> =
  {
    encode(
      message: QueryParamsByVersionResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.params !== undefined) {
        Params.encode(message.params, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryParamsByVersionResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryParamsByVersionResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.params = Params.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryParamsByVersionResponse {
      return {
        params: isSet(object.params)
          ? Params.fromJSON(object.params)
          : undefined,
      };
    },

    toJSON(message: QueryParamsByVersionResponse): unknown {
      const obj: any = {};
      if (message.params !== undefined) {
        obj.params = Params.toJSON(message.params);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryParamsByVersionResponse>, I>>(
      base?: I,
    ): QueryParamsByVersionResponse {
      return QueryParamsByVersionResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryParamsByVersionResponse>, I>>(
      object: I,
    ): QueryParamsByVersionResponse {
      const message = createBaseQueryParamsByVersionResponse();
      message.params =
        object.params !== undefined && object.params !== null
          ? Params.fromPartial(object.params)
          : undefined;
      return message;
    },
  };

function createBaseQueryFinalityProvidersRequest(): QueryFinalityProvidersRequest {
  return { pagination: undefined };
}

export const QueryFinalityProvidersRequest: MessageFns<QueryFinalityProvidersRequest> =
  {
    encode(
      message: QueryFinalityProvidersRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.pagination !== undefined) {
        PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryFinalityProvidersRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryFinalityProvidersRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.pagination = PageRequest.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryFinalityProvidersRequest {
      return {
        pagination: isSet(object.pagination)
          ? PageRequest.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryFinalityProvidersRequest): unknown {
      const obj: any = {};
      if (message.pagination !== undefined) {
        obj.pagination = PageRequest.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryFinalityProvidersRequest>, I>>(
      base?: I,
    ): QueryFinalityProvidersRequest {
      return QueryFinalityProvidersRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryFinalityProvidersRequest>, I>>(
      object: I,
    ): QueryFinalityProvidersRequest {
      const message = createBaseQueryFinalityProvidersRequest();
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageRequest.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryFinalityProvidersResponse(): QueryFinalityProvidersResponse {
  return { finalityProviders: [], pagination: undefined };
}

export const QueryFinalityProvidersResponse: MessageFns<QueryFinalityProvidersResponse> =
  {
    encode(
      message: QueryFinalityProvidersResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.finalityProviders) {
        FinalityProviderResponse.encode(v!, writer.uint32(10).fork()).join();
      }
      if (message.pagination !== undefined) {
        PageResponse.encode(
          message.pagination,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryFinalityProvidersResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryFinalityProvidersResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.finalityProviders.push(
              FinalityProviderResponse.decode(reader, reader.uint32()),
            );
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.pagination = PageResponse.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryFinalityProvidersResponse {
      return {
        finalityProviders: globalThis.Array.isArray(object?.finalityProviders)
          ? object.finalityProviders.map((e: any) =>
              FinalityProviderResponse.fromJSON(e),
            )
          : [],
        pagination: isSet(object.pagination)
          ? PageResponse.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryFinalityProvidersResponse): unknown {
      const obj: any = {};
      if (message.finalityProviders?.length) {
        obj.finalityProviders = message.finalityProviders.map((e) =>
          FinalityProviderResponse.toJSON(e),
        );
      }
      if (message.pagination !== undefined) {
        obj.pagination = PageResponse.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryFinalityProvidersResponse>, I>>(
      base?: I,
    ): QueryFinalityProvidersResponse {
      return QueryFinalityProvidersResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryFinalityProvidersResponse>, I>,
    >(object: I): QueryFinalityProvidersResponse {
      const message = createBaseQueryFinalityProvidersResponse();
      message.finalityProviders =
        object.finalityProviders?.map((e) =>
          FinalityProviderResponse.fromPartial(e),
        ) || [];
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageResponse.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryFinalityProviderRequest(): QueryFinalityProviderRequest {
  return { fpBtcPkHex: "" };
}

export const QueryFinalityProviderRequest: MessageFns<QueryFinalityProviderRequest> =
  {
    encode(
      message: QueryFinalityProviderRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.fpBtcPkHex !== "") {
        writer.uint32(10).string(message.fpBtcPkHex);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryFinalityProviderRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryFinalityProviderRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.fpBtcPkHex = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryFinalityProviderRequest {
      return {
        fpBtcPkHex: isSet(object.fpBtcPkHex)
          ? globalThis.String(object.fpBtcPkHex)
          : "",
      };
    },

    toJSON(message: QueryFinalityProviderRequest): unknown {
      const obj: any = {};
      if (message.fpBtcPkHex !== "") {
        obj.fpBtcPkHex = message.fpBtcPkHex;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryFinalityProviderRequest>, I>>(
      base?: I,
    ): QueryFinalityProviderRequest {
      return QueryFinalityProviderRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryFinalityProviderRequest>, I>>(
      object: I,
    ): QueryFinalityProviderRequest {
      const message = createBaseQueryFinalityProviderRequest();
      message.fpBtcPkHex = object.fpBtcPkHex ?? "";
      return message;
    },
  };

function createBaseQueryFinalityProviderResponse(): QueryFinalityProviderResponse {
  return { finalityProvider: undefined };
}

export const QueryFinalityProviderResponse: MessageFns<QueryFinalityProviderResponse> =
  {
    encode(
      message: QueryFinalityProviderResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.finalityProvider !== undefined) {
        FinalityProviderResponse.encode(
          message.finalityProvider,
          writer.uint32(10).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryFinalityProviderResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryFinalityProviderResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.finalityProvider = FinalityProviderResponse.decode(
              reader,
              reader.uint32(),
            );
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryFinalityProviderResponse {
      return {
        finalityProvider: isSet(object.finalityProvider)
          ? FinalityProviderResponse.fromJSON(object.finalityProvider)
          : undefined,
      };
    },

    toJSON(message: QueryFinalityProviderResponse): unknown {
      const obj: any = {};
      if (message.finalityProvider !== undefined) {
        obj.finalityProvider = FinalityProviderResponse.toJSON(
          message.finalityProvider,
        );
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryFinalityProviderResponse>, I>>(
      base?: I,
    ): QueryFinalityProviderResponse {
      return QueryFinalityProviderResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryFinalityProviderResponse>, I>>(
      object: I,
    ): QueryFinalityProviderResponse {
      const message = createBaseQueryFinalityProviderResponse();
      message.finalityProvider =
        object.finalityProvider !== undefined &&
        object.finalityProvider !== null
          ? FinalityProviderResponse.fromPartial(object.finalityProvider)
          : undefined;
      return message;
    },
  };

function createBaseQueryBTCDelegationsRequest(): QueryBTCDelegationsRequest {
  return { status: 0, pagination: undefined };
}

export const QueryBTCDelegationsRequest: MessageFns<QueryBTCDelegationsRequest> =
  {
    encode(
      message: QueryBTCDelegationsRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.status !== 0) {
        writer.uint32(8).int32(message.status);
      }
      if (message.pagination !== undefined) {
        PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryBTCDelegationsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryBTCDelegationsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }

            message.status = reader.int32() as any;
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.pagination = PageRequest.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryBTCDelegationsRequest {
      return {
        status: isSet(object.status)
          ? bTCDelegationStatusFromJSON(object.status)
          : 0,
        pagination: isSet(object.pagination)
          ? PageRequest.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryBTCDelegationsRequest): unknown {
      const obj: any = {};
      if (message.status !== 0) {
        obj.status = bTCDelegationStatusToJSON(message.status);
      }
      if (message.pagination !== undefined) {
        obj.pagination = PageRequest.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryBTCDelegationsRequest>, I>>(
      base?: I,
    ): QueryBTCDelegationsRequest {
      return QueryBTCDelegationsRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryBTCDelegationsRequest>, I>>(
      object: I,
    ): QueryBTCDelegationsRequest {
      const message = createBaseQueryBTCDelegationsRequest();
      message.status = object.status ?? 0;
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageRequest.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryBTCDelegationsResponse(): QueryBTCDelegationsResponse {
  return { btcDelegations: [], pagination: undefined };
}

export const QueryBTCDelegationsResponse: MessageFns<QueryBTCDelegationsResponse> =
  {
    encode(
      message: QueryBTCDelegationsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.btcDelegations) {
        BTCDelegationResponse.encode(v!, writer.uint32(10).fork()).join();
      }
      if (message.pagination !== undefined) {
        PageResponse.encode(
          message.pagination,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryBTCDelegationsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryBTCDelegationsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.btcDelegations.push(
              BTCDelegationResponse.decode(reader, reader.uint32()),
            );
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.pagination = PageResponse.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryBTCDelegationsResponse {
      return {
        btcDelegations: globalThis.Array.isArray(object?.btcDelegations)
          ? object.btcDelegations.map((e: any) =>
              BTCDelegationResponse.fromJSON(e),
            )
          : [],
        pagination: isSet(object.pagination)
          ? PageResponse.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryBTCDelegationsResponse): unknown {
      const obj: any = {};
      if (message.btcDelegations?.length) {
        obj.btcDelegations = message.btcDelegations.map((e) =>
          BTCDelegationResponse.toJSON(e),
        );
      }
      if (message.pagination !== undefined) {
        obj.pagination = PageResponse.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryBTCDelegationsResponse>, I>>(
      base?: I,
    ): QueryBTCDelegationsResponse {
      return QueryBTCDelegationsResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryBTCDelegationsResponse>, I>>(
      object: I,
    ): QueryBTCDelegationsResponse {
      const message = createBaseQueryBTCDelegationsResponse();
      message.btcDelegations =
        object.btcDelegations?.map((e) =>
          BTCDelegationResponse.fromPartial(e),
        ) || [];
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageResponse.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryFinalityProviderPowerAtHeightRequest(): QueryFinalityProviderPowerAtHeightRequest {
  return { fpBtcPkHex: "", height: 0 };
}

export const QueryFinalityProviderPowerAtHeightRequest: MessageFns<QueryFinalityProviderPowerAtHeightRequest> =
  {
    encode(
      message: QueryFinalityProviderPowerAtHeightRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.fpBtcPkHex !== "") {
        writer.uint32(10).string(message.fpBtcPkHex);
      }
      if (message.height !== 0) {
        writer.uint32(16).uint64(message.height);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryFinalityProviderPowerAtHeightRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryFinalityProviderPowerAtHeightRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.fpBtcPkHex = reader.string();
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }

            message.height = longToNumber(reader.uint64());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryFinalityProviderPowerAtHeightRequest {
      return {
        fpBtcPkHex: isSet(object.fpBtcPkHex)
          ? globalThis.String(object.fpBtcPkHex)
          : "",
        height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      };
    },

    toJSON(message: QueryFinalityProviderPowerAtHeightRequest): unknown {
      const obj: any = {};
      if (message.fpBtcPkHex !== "") {
        obj.fpBtcPkHex = message.fpBtcPkHex;
      }
      if (message.height !== 0) {
        obj.height = Math.round(message.height);
      }
      return obj;
    },

    create<
      I extends Exact<
        DeepPartial<QueryFinalityProviderPowerAtHeightRequest>,
        I
      >,
    >(base?: I): QueryFinalityProviderPowerAtHeightRequest {
      return QueryFinalityProviderPowerAtHeightRequest.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<
        DeepPartial<QueryFinalityProviderPowerAtHeightRequest>,
        I
      >,
    >(object: I): QueryFinalityProviderPowerAtHeightRequest {
      const message = createBaseQueryFinalityProviderPowerAtHeightRequest();
      message.fpBtcPkHex = object.fpBtcPkHex ?? "";
      message.height = object.height ?? 0;
      return message;
    },
  };

function createBaseQueryFinalityProviderPowerAtHeightResponse(): QueryFinalityProviderPowerAtHeightResponse {
  return { votingPower: 0 };
}

export const QueryFinalityProviderPowerAtHeightResponse: MessageFns<QueryFinalityProviderPowerAtHeightResponse> =
  {
    encode(
      message: QueryFinalityProviderPowerAtHeightResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.votingPower !== 0) {
        writer.uint32(8).uint64(message.votingPower);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryFinalityProviderPowerAtHeightResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryFinalityProviderPowerAtHeightResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }

            message.votingPower = longToNumber(reader.uint64());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryFinalityProviderPowerAtHeightResponse {
      return {
        votingPower: isSet(object.votingPower)
          ? globalThis.Number(object.votingPower)
          : 0,
      };
    },

    toJSON(message: QueryFinalityProviderPowerAtHeightResponse): unknown {
      const obj: any = {};
      if (message.votingPower !== 0) {
        obj.votingPower = Math.round(message.votingPower);
      }
      return obj;
    },

    create<
      I extends Exact<
        DeepPartial<QueryFinalityProviderPowerAtHeightResponse>,
        I
      >,
    >(base?: I): QueryFinalityProviderPowerAtHeightResponse {
      return QueryFinalityProviderPowerAtHeightResponse.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<
        DeepPartial<QueryFinalityProviderPowerAtHeightResponse>,
        I
      >,
    >(object: I): QueryFinalityProviderPowerAtHeightResponse {
      const message = createBaseQueryFinalityProviderPowerAtHeightResponse();
      message.votingPower = object.votingPower ?? 0;
      return message;
    },
  };

function createBaseQueryFinalityProviderCurrentPowerRequest(): QueryFinalityProviderCurrentPowerRequest {
  return { fpBtcPkHex: "" };
}

export const QueryFinalityProviderCurrentPowerRequest: MessageFns<QueryFinalityProviderCurrentPowerRequest> =
  {
    encode(
      message: QueryFinalityProviderCurrentPowerRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.fpBtcPkHex !== "") {
        writer.uint32(10).string(message.fpBtcPkHex);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryFinalityProviderCurrentPowerRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryFinalityProviderCurrentPowerRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.fpBtcPkHex = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryFinalityProviderCurrentPowerRequest {
      return {
        fpBtcPkHex: isSet(object.fpBtcPkHex)
          ? globalThis.String(object.fpBtcPkHex)
          : "",
      };
    },

    toJSON(message: QueryFinalityProviderCurrentPowerRequest): unknown {
      const obj: any = {};
      if (message.fpBtcPkHex !== "") {
        obj.fpBtcPkHex = message.fpBtcPkHex;
      }
      return obj;
    },

    create<
      I extends Exact<DeepPartial<QueryFinalityProviderCurrentPowerRequest>, I>,
    >(base?: I): QueryFinalityProviderCurrentPowerRequest {
      return QueryFinalityProviderCurrentPowerRequest.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryFinalityProviderCurrentPowerRequest>, I>,
    >(object: I): QueryFinalityProviderCurrentPowerRequest {
      const message = createBaseQueryFinalityProviderCurrentPowerRequest();
      message.fpBtcPkHex = object.fpBtcPkHex ?? "";
      return message;
    },
  };

function createBaseQueryFinalityProviderCurrentPowerResponse(): QueryFinalityProviderCurrentPowerResponse {
  return { height: 0, votingPower: 0 };
}

export const QueryFinalityProviderCurrentPowerResponse: MessageFns<QueryFinalityProviderCurrentPowerResponse> =
  {
    encode(
      message: QueryFinalityProviderCurrentPowerResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.height !== 0) {
        writer.uint32(8).uint64(message.height);
      }
      if (message.votingPower !== 0) {
        writer.uint32(16).uint64(message.votingPower);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryFinalityProviderCurrentPowerResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryFinalityProviderCurrentPowerResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }

            message.height = longToNumber(reader.uint64());
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }

            message.votingPower = longToNumber(reader.uint64());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryFinalityProviderCurrentPowerResponse {
      return {
        height: isSet(object.height) ? globalThis.Number(object.height) : 0,
        votingPower: isSet(object.votingPower)
          ? globalThis.Number(object.votingPower)
          : 0,
      };
    },

    toJSON(message: QueryFinalityProviderCurrentPowerResponse): unknown {
      const obj: any = {};
      if (message.height !== 0) {
        obj.height = Math.round(message.height);
      }
      if (message.votingPower !== 0) {
        obj.votingPower = Math.round(message.votingPower);
      }
      return obj;
    },

    create<
      I extends Exact<
        DeepPartial<QueryFinalityProviderCurrentPowerResponse>,
        I
      >,
    >(base?: I): QueryFinalityProviderCurrentPowerResponse {
      return QueryFinalityProviderCurrentPowerResponse.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<
        DeepPartial<QueryFinalityProviderCurrentPowerResponse>,
        I
      >,
    >(object: I): QueryFinalityProviderCurrentPowerResponse {
      const message = createBaseQueryFinalityProviderCurrentPowerResponse();
      message.height = object.height ?? 0;
      message.votingPower = object.votingPower ?? 0;
      return message;
    },
  };

function createBaseQueryActiveFinalityProvidersAtHeightRequest(): QueryActiveFinalityProvidersAtHeightRequest {
  return { height: 0, pagination: undefined };
}

export const QueryActiveFinalityProvidersAtHeightRequest: MessageFns<QueryActiveFinalityProvidersAtHeightRequest> =
  {
    encode(
      message: QueryActiveFinalityProvidersAtHeightRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.height !== 0) {
        writer.uint32(8).uint64(message.height);
      }
      if (message.pagination !== undefined) {
        PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryActiveFinalityProvidersAtHeightRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryActiveFinalityProvidersAtHeightRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }

            message.height = longToNumber(reader.uint64());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.pagination = PageRequest.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryActiveFinalityProvidersAtHeightRequest {
      return {
        height: isSet(object.height) ? globalThis.Number(object.height) : 0,
        pagination: isSet(object.pagination)
          ? PageRequest.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryActiveFinalityProvidersAtHeightRequest): unknown {
      const obj: any = {};
      if (message.height !== 0) {
        obj.height = Math.round(message.height);
      }
      if (message.pagination !== undefined) {
        obj.pagination = PageRequest.toJSON(message.pagination);
      }
      return obj;
    },

    create<
      I extends Exact<
        DeepPartial<QueryActiveFinalityProvidersAtHeightRequest>,
        I
      >,
    >(base?: I): QueryActiveFinalityProvidersAtHeightRequest {
      return QueryActiveFinalityProvidersAtHeightRequest.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<
        DeepPartial<QueryActiveFinalityProvidersAtHeightRequest>,
        I
      >,
    >(object: I): QueryActiveFinalityProvidersAtHeightRequest {
      const message = createBaseQueryActiveFinalityProvidersAtHeightRequest();
      message.height = object.height ?? 0;
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageRequest.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseActiveFinalityProvidersAtHeightResponse(): ActiveFinalityProvidersAtHeightResponse {
  return {
    btcPkHex: "",
    height: 0,
    votingPower: 0,
    slashedBabylonHeight: 0,
    slashedBtcHeight: 0,
    jailed: false,
  };
}

export const ActiveFinalityProvidersAtHeightResponse: MessageFns<ActiveFinalityProvidersAtHeightResponse> =
  {
    encode(
      message: ActiveFinalityProvidersAtHeightResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.btcPkHex !== "") {
        writer.uint32(10).string(message.btcPkHex);
      }
      if (message.height !== 0) {
        writer.uint32(16).uint64(message.height);
      }
      if (message.votingPower !== 0) {
        writer.uint32(24).uint64(message.votingPower);
      }
      if (message.slashedBabylonHeight !== 0) {
        writer.uint32(32).uint64(message.slashedBabylonHeight);
      }
      if (message.slashedBtcHeight !== 0) {
        writer.uint32(40).uint32(message.slashedBtcHeight);
      }
      if (message.jailed !== false) {
        writer.uint32(48).bool(message.jailed);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ActiveFinalityProvidersAtHeightResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseActiveFinalityProvidersAtHeightResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.btcPkHex = reader.string();
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }

            message.height = longToNumber(reader.uint64());
            continue;
          case 3:
            if (tag !== 24) {
              break;
            }

            message.votingPower = longToNumber(reader.uint64());
            continue;
          case 4:
            if (tag !== 32) {
              break;
            }

            message.slashedBabylonHeight = longToNumber(reader.uint64());
            continue;
          case 5:
            if (tag !== 40) {
              break;
            }

            message.slashedBtcHeight = reader.uint32();
            continue;
          case 6:
            if (tag !== 48) {
              break;
            }

            message.jailed = reader.bool();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ActiveFinalityProvidersAtHeightResponse {
      return {
        btcPkHex: isSet(object.btcPkHex)
          ? globalThis.String(object.btcPkHex)
          : "",
        height: isSet(object.height) ? globalThis.Number(object.height) : 0,
        votingPower: isSet(object.votingPower)
          ? globalThis.Number(object.votingPower)
          : 0,
        slashedBabylonHeight: isSet(object.slashedBabylonHeight)
          ? globalThis.Number(object.slashedBabylonHeight)
          : 0,
        slashedBtcHeight: isSet(object.slashedBtcHeight)
          ? globalThis.Number(object.slashedBtcHeight)
          : 0,
        jailed: isSet(object.jailed)
          ? globalThis.Boolean(object.jailed)
          : false,
      };
    },

    toJSON(message: ActiveFinalityProvidersAtHeightResponse): unknown {
      const obj: any = {};
      if (message.btcPkHex !== "") {
        obj.btcPkHex = message.btcPkHex;
      }
      if (message.height !== 0) {
        obj.height = Math.round(message.height);
      }
      if (message.votingPower !== 0) {
        obj.votingPower = Math.round(message.votingPower);
      }
      if (message.slashedBabylonHeight !== 0) {
        obj.slashedBabylonHeight = Math.round(message.slashedBabylonHeight);
      }
      if (message.slashedBtcHeight !== 0) {
        obj.slashedBtcHeight = Math.round(message.slashedBtcHeight);
      }
      if (message.jailed !== false) {
        obj.jailed = message.jailed;
      }
      return obj;
    },

    create<
      I extends Exact<DeepPartial<ActiveFinalityProvidersAtHeightResponse>, I>,
    >(base?: I): ActiveFinalityProvidersAtHeightResponse {
      return ActiveFinalityProvidersAtHeightResponse.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<DeepPartial<ActiveFinalityProvidersAtHeightResponse>, I>,
    >(object: I): ActiveFinalityProvidersAtHeightResponse {
      const message = createBaseActiveFinalityProvidersAtHeightResponse();
      message.btcPkHex = object.btcPkHex ?? "";
      message.height = object.height ?? 0;
      message.votingPower = object.votingPower ?? 0;
      message.slashedBabylonHeight = object.slashedBabylonHeight ?? 0;
      message.slashedBtcHeight = object.slashedBtcHeight ?? 0;
      message.jailed = object.jailed ?? false;
      return message;
    },
  };

function createBaseQueryActiveFinalityProvidersAtHeightResponse(): QueryActiveFinalityProvidersAtHeightResponse {
  return { finalityProviders: [], pagination: undefined };
}

export const QueryActiveFinalityProvidersAtHeightResponse: MessageFns<QueryActiveFinalityProvidersAtHeightResponse> =
  {
    encode(
      message: QueryActiveFinalityProvidersAtHeightResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.finalityProviders) {
        ActiveFinalityProvidersAtHeightResponse.encode(
          v!,
          writer.uint32(10).fork(),
        ).join();
      }
      if (message.pagination !== undefined) {
        PageResponse.encode(
          message.pagination,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryActiveFinalityProvidersAtHeightResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryActiveFinalityProvidersAtHeightResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.finalityProviders.push(
              ActiveFinalityProvidersAtHeightResponse.decode(
                reader,
                reader.uint32(),
              ),
            );
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.pagination = PageResponse.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryActiveFinalityProvidersAtHeightResponse {
      return {
        finalityProviders: globalThis.Array.isArray(object?.finalityProviders)
          ? object.finalityProviders.map((e: any) =>
              ActiveFinalityProvidersAtHeightResponse.fromJSON(e),
            )
          : [],
        pagination: isSet(object.pagination)
          ? PageResponse.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryActiveFinalityProvidersAtHeightResponse): unknown {
      const obj: any = {};
      if (message.finalityProviders?.length) {
        obj.finalityProviders = message.finalityProviders.map((e) =>
          ActiveFinalityProvidersAtHeightResponse.toJSON(e),
        );
      }
      if (message.pagination !== undefined) {
        obj.pagination = PageResponse.toJSON(message.pagination);
      }
      return obj;
    },

    create<
      I extends Exact<
        DeepPartial<QueryActiveFinalityProvidersAtHeightResponse>,
        I
      >,
    >(base?: I): QueryActiveFinalityProvidersAtHeightResponse {
      return QueryActiveFinalityProvidersAtHeightResponse.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<
        DeepPartial<QueryActiveFinalityProvidersAtHeightResponse>,
        I
      >,
    >(object: I): QueryActiveFinalityProvidersAtHeightResponse {
      const message = createBaseQueryActiveFinalityProvidersAtHeightResponse();
      message.finalityProviders =
        object.finalityProviders?.map((e) =>
          ActiveFinalityProvidersAtHeightResponse.fromPartial(e),
        ) || [];
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageResponse.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryActivatedHeightRequest(): QueryActivatedHeightRequest {
  return {};
}

export const QueryActivatedHeightRequest: MessageFns<QueryActivatedHeightRequest> =
  {
    encode(
      _: QueryActivatedHeightRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryActivatedHeightRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryActivatedHeightRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): QueryActivatedHeightRequest {
      return {};
    },

    toJSON(_: QueryActivatedHeightRequest): unknown {
      const obj: any = {};
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryActivatedHeightRequest>, I>>(
      base?: I,
    ): QueryActivatedHeightRequest {
      return QueryActivatedHeightRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryActivatedHeightRequest>, I>>(
      _: I,
    ): QueryActivatedHeightRequest {
      const message = createBaseQueryActivatedHeightRequest();
      return message;
    },
  };

function createBaseQueryActivatedHeightResponse(): QueryActivatedHeightResponse {
  return { height: 0 };
}

export const QueryActivatedHeightResponse: MessageFns<QueryActivatedHeightResponse> =
  {
    encode(
      message: QueryActivatedHeightResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.height !== 0) {
        writer.uint32(8).uint64(message.height);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryActivatedHeightResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryActivatedHeightResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }

            message.height = longToNumber(reader.uint64());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryActivatedHeightResponse {
      return {
        height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      };
    },

    toJSON(message: QueryActivatedHeightResponse): unknown {
      const obj: any = {};
      if (message.height !== 0) {
        obj.height = Math.round(message.height);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryActivatedHeightResponse>, I>>(
      base?: I,
    ): QueryActivatedHeightResponse {
      return QueryActivatedHeightResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryActivatedHeightResponse>, I>>(
      object: I,
    ): QueryActivatedHeightResponse {
      const message = createBaseQueryActivatedHeightResponse();
      message.height = object.height ?? 0;
      return message;
    },
  };

function createBaseQueryFinalityProviderDelegationsRequest(): QueryFinalityProviderDelegationsRequest {
  return { fpBtcPkHex: "", pagination: undefined };
}

export const QueryFinalityProviderDelegationsRequest: MessageFns<QueryFinalityProviderDelegationsRequest> =
  {
    encode(
      message: QueryFinalityProviderDelegationsRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.fpBtcPkHex !== "") {
        writer.uint32(10).string(message.fpBtcPkHex);
      }
      if (message.pagination !== undefined) {
        PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryFinalityProviderDelegationsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryFinalityProviderDelegationsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.fpBtcPkHex = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.pagination = PageRequest.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryFinalityProviderDelegationsRequest {
      return {
        fpBtcPkHex: isSet(object.fpBtcPkHex)
          ? globalThis.String(object.fpBtcPkHex)
          : "",
        pagination: isSet(object.pagination)
          ? PageRequest.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryFinalityProviderDelegationsRequest): unknown {
      const obj: any = {};
      if (message.fpBtcPkHex !== "") {
        obj.fpBtcPkHex = message.fpBtcPkHex;
      }
      if (message.pagination !== undefined) {
        obj.pagination = PageRequest.toJSON(message.pagination);
      }
      return obj;
    },

    create<
      I extends Exact<DeepPartial<QueryFinalityProviderDelegationsRequest>, I>,
    >(base?: I): QueryFinalityProviderDelegationsRequest {
      return QueryFinalityProviderDelegationsRequest.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryFinalityProviderDelegationsRequest>, I>,
    >(object: I): QueryFinalityProviderDelegationsRequest {
      const message = createBaseQueryFinalityProviderDelegationsRequest();
      message.fpBtcPkHex = object.fpBtcPkHex ?? "";
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageRequest.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryFinalityProviderDelegationsResponse(): QueryFinalityProviderDelegationsResponse {
  return { btcDelegatorDelegations: [], pagination: undefined };
}

export const QueryFinalityProviderDelegationsResponse: MessageFns<QueryFinalityProviderDelegationsResponse> =
  {
    encode(
      message: QueryFinalityProviderDelegationsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.btcDelegatorDelegations) {
        BTCDelegatorDelegationsResponse.encode(
          v!,
          writer.uint32(10).fork(),
        ).join();
      }
      if (message.pagination !== undefined) {
        PageResponse.encode(
          message.pagination,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryFinalityProviderDelegationsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryFinalityProviderDelegationsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.btcDelegatorDelegations.push(
              BTCDelegatorDelegationsResponse.decode(reader, reader.uint32()),
            );
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.pagination = PageResponse.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryFinalityProviderDelegationsResponse {
      return {
        btcDelegatorDelegations: globalThis.Array.isArray(
          object?.btcDelegatorDelegations,
        )
          ? object.btcDelegatorDelegations.map((e: any) =>
              BTCDelegatorDelegationsResponse.fromJSON(e),
            )
          : [],
        pagination: isSet(object.pagination)
          ? PageResponse.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryFinalityProviderDelegationsResponse): unknown {
      const obj: any = {};
      if (message.btcDelegatorDelegations?.length) {
        obj.btcDelegatorDelegations = message.btcDelegatorDelegations.map((e) =>
          BTCDelegatorDelegationsResponse.toJSON(e),
        );
      }
      if (message.pagination !== undefined) {
        obj.pagination = PageResponse.toJSON(message.pagination);
      }
      return obj;
    },

    create<
      I extends Exact<DeepPartial<QueryFinalityProviderDelegationsResponse>, I>,
    >(base?: I): QueryFinalityProviderDelegationsResponse {
      return QueryFinalityProviderDelegationsResponse.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryFinalityProviderDelegationsResponse>, I>,
    >(object: I): QueryFinalityProviderDelegationsResponse {
      const message = createBaseQueryFinalityProviderDelegationsResponse();
      message.btcDelegatorDelegations =
        object.btcDelegatorDelegations?.map((e) =>
          BTCDelegatorDelegationsResponse.fromPartial(e),
        ) || [];
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageResponse.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryBTCDelegationRequest(): QueryBTCDelegationRequest {
  return { stakingTxHashHex: "" };
}

export const QueryBTCDelegationRequest: MessageFns<QueryBTCDelegationRequest> =
  {
    encode(
      message: QueryBTCDelegationRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.stakingTxHashHex !== "") {
        writer.uint32(10).string(message.stakingTxHashHex);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryBTCDelegationRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryBTCDelegationRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.stakingTxHashHex = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryBTCDelegationRequest {
      return {
        stakingTxHashHex: isSet(object.stakingTxHashHex)
          ? globalThis.String(object.stakingTxHashHex)
          : "",
      };
    },

    toJSON(message: QueryBTCDelegationRequest): unknown {
      const obj: any = {};
      if (message.stakingTxHashHex !== "") {
        obj.stakingTxHashHex = message.stakingTxHashHex;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryBTCDelegationRequest>, I>>(
      base?: I,
    ): QueryBTCDelegationRequest {
      return QueryBTCDelegationRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryBTCDelegationRequest>, I>>(
      object: I,
    ): QueryBTCDelegationRequest {
      const message = createBaseQueryBTCDelegationRequest();
      message.stakingTxHashHex = object.stakingTxHashHex ?? "";
      return message;
    },
  };

function createBaseQueryBTCDelegationResponse(): QueryBTCDelegationResponse {
  return { btcDelegation: undefined };
}

export const QueryBTCDelegationResponse: MessageFns<QueryBTCDelegationResponse> =
  {
    encode(
      message: QueryBTCDelegationResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.btcDelegation !== undefined) {
        BTCDelegationResponse.encode(
          message.btcDelegation,
          writer.uint32(10).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryBTCDelegationResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryBTCDelegationResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.btcDelegation = BTCDelegationResponse.decode(
              reader,
              reader.uint32(),
            );
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryBTCDelegationResponse {
      return {
        btcDelegation: isSet(object.btcDelegation)
          ? BTCDelegationResponse.fromJSON(object.btcDelegation)
          : undefined,
      };
    },

    toJSON(message: QueryBTCDelegationResponse): unknown {
      const obj: any = {};
      if (message.btcDelegation !== undefined) {
        obj.btcDelegation = BTCDelegationResponse.toJSON(message.btcDelegation);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryBTCDelegationResponse>, I>>(
      base?: I,
    ): QueryBTCDelegationResponse {
      return QueryBTCDelegationResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryBTCDelegationResponse>, I>>(
      object: I,
    ): QueryBTCDelegationResponse {
      const message = createBaseQueryBTCDelegationResponse();
      message.btcDelegation =
        object.btcDelegation !== undefined && object.btcDelegation !== null
          ? BTCDelegationResponse.fromPartial(object.btcDelegation)
          : undefined;
      return message;
    },
  };

function createBaseBTCDelegationResponse(): BTCDelegationResponse {
  return {
    stakerAddr: "",
    btcPk: new Uint8Array(0),
    fpBtcPkList: [],
    stakingTime: 0,
    startHeight: 0,
    endHeight: 0,
    totalSat: 0,
    stakingTxHex: "",
    slashingTxHex: "",
    delegatorSlashSigHex: "",
    covenantSigs: [],
    stakingOutputIdx: 0,
    active: false,
    statusDesc: "",
    unbondingTime: 0,
    undelegationResponse: undefined,
    paramsVersion: 0,
  };
}

export const BTCDelegationResponse: MessageFns<BTCDelegationResponse> = {
  encode(
    message: BTCDelegationResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.stakerAddr !== "") {
      writer.uint32(10).string(message.stakerAddr);
    }
    if (message.btcPk.length !== 0) {
      writer.uint32(18).bytes(message.btcPk);
    }
    for (const v of message.fpBtcPkList) {
      writer.uint32(26).bytes(v!);
    }
    if (message.stakingTime !== 0) {
      writer.uint32(32).uint32(message.stakingTime);
    }
    if (message.startHeight !== 0) {
      writer.uint32(40).uint32(message.startHeight);
    }
    if (message.endHeight !== 0) {
      writer.uint32(48).uint32(message.endHeight);
    }
    if (message.totalSat !== 0) {
      writer.uint32(56).uint64(message.totalSat);
    }
    if (message.stakingTxHex !== "") {
      writer.uint32(66).string(message.stakingTxHex);
    }
    if (message.slashingTxHex !== "") {
      writer.uint32(74).string(message.slashingTxHex);
    }
    if (message.delegatorSlashSigHex !== "") {
      writer.uint32(82).string(message.delegatorSlashSigHex);
    }
    for (const v of message.covenantSigs) {
      CovenantAdaptorSignatures.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.stakingOutputIdx !== 0) {
      writer.uint32(96).uint32(message.stakingOutputIdx);
    }
    if (message.active !== false) {
      writer.uint32(104).bool(message.active);
    }
    if (message.statusDesc !== "") {
      writer.uint32(114).string(message.statusDesc);
    }
    if (message.unbondingTime !== 0) {
      writer.uint32(120).uint32(message.unbondingTime);
    }
    if (message.undelegationResponse !== undefined) {
      BTCUndelegationResponse.encode(
        message.undelegationResponse,
        writer.uint32(130).fork(),
      ).join();
    }
    if (message.paramsVersion !== 0) {
      writer.uint32(136).uint32(message.paramsVersion);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): BTCDelegationResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCDelegationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stakerAddr = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.btcPk = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fpBtcPkList.push(reader.bytes());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.stakingTime = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.startHeight = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.endHeight = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.totalSat = longToNumber(reader.uint64());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.stakingTxHex = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.slashingTxHex = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.delegatorSlashSigHex = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.covenantSigs.push(
            CovenantAdaptorSignatures.decode(reader, reader.uint32()),
          );
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.stakingOutputIdx = reader.uint32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.active = reader.bool();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.statusDesc = reader.string();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.unbondingTime = reader.uint32();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.undelegationResponse = BTCUndelegationResponse.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.paramsVersion = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCDelegationResponse {
    return {
      stakerAddr: isSet(object.stakerAddr)
        ? globalThis.String(object.stakerAddr)
        : "",
      btcPk: isSet(object.btcPk)
        ? bytesFromBase64(object.btcPk)
        : new Uint8Array(0),
      fpBtcPkList: globalThis.Array.isArray(object?.fpBtcPkList)
        ? object.fpBtcPkList.map((e: any) => bytesFromBase64(e))
        : [],
      stakingTime: isSet(object.stakingTime)
        ? globalThis.Number(object.stakingTime)
        : 0,
      startHeight: isSet(object.startHeight)
        ? globalThis.Number(object.startHeight)
        : 0,
      endHeight: isSet(object.endHeight)
        ? globalThis.Number(object.endHeight)
        : 0,
      totalSat: isSet(object.totalSat) ? globalThis.Number(object.totalSat) : 0,
      stakingTxHex: isSet(object.stakingTxHex)
        ? globalThis.String(object.stakingTxHex)
        : "",
      slashingTxHex: isSet(object.slashingTxHex)
        ? globalThis.String(object.slashingTxHex)
        : "",
      delegatorSlashSigHex: isSet(object.delegatorSlashSigHex)
        ? globalThis.String(object.delegatorSlashSigHex)
        : "",
      covenantSigs: globalThis.Array.isArray(object?.covenantSigs)
        ? object.covenantSigs.map((e: any) =>
            CovenantAdaptorSignatures.fromJSON(e),
          )
        : [],
      stakingOutputIdx: isSet(object.stakingOutputIdx)
        ? globalThis.Number(object.stakingOutputIdx)
        : 0,
      active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
      statusDesc: isSet(object.statusDesc)
        ? globalThis.String(object.statusDesc)
        : "",
      unbondingTime: isSet(object.unbondingTime)
        ? globalThis.Number(object.unbondingTime)
        : 0,
      undelegationResponse: isSet(object.undelegationResponse)
        ? BTCUndelegationResponse.fromJSON(object.undelegationResponse)
        : undefined,
      paramsVersion: isSet(object.paramsVersion)
        ? globalThis.Number(object.paramsVersion)
        : 0,
    };
  },

  toJSON(message: BTCDelegationResponse): unknown {
    const obj: any = {};
    if (message.stakerAddr !== "") {
      obj.stakerAddr = message.stakerAddr;
    }
    if (message.btcPk.length !== 0) {
      obj.btcPk = base64FromBytes(message.btcPk);
    }
    if (message.fpBtcPkList?.length) {
      obj.fpBtcPkList = message.fpBtcPkList.map((e) => base64FromBytes(e));
    }
    if (message.stakingTime !== 0) {
      obj.stakingTime = Math.round(message.stakingTime);
    }
    if (message.startHeight !== 0) {
      obj.startHeight = Math.round(message.startHeight);
    }
    if (message.endHeight !== 0) {
      obj.endHeight = Math.round(message.endHeight);
    }
    if (message.totalSat !== 0) {
      obj.totalSat = Math.round(message.totalSat);
    }
    if (message.stakingTxHex !== "") {
      obj.stakingTxHex = message.stakingTxHex;
    }
    if (message.slashingTxHex !== "") {
      obj.slashingTxHex = message.slashingTxHex;
    }
    if (message.delegatorSlashSigHex !== "") {
      obj.delegatorSlashSigHex = message.delegatorSlashSigHex;
    }
    if (message.covenantSigs?.length) {
      obj.covenantSigs = message.covenantSigs.map((e) =>
        CovenantAdaptorSignatures.toJSON(e),
      );
    }
    if (message.stakingOutputIdx !== 0) {
      obj.stakingOutputIdx = Math.round(message.stakingOutputIdx);
    }
    if (message.active !== false) {
      obj.active = message.active;
    }
    if (message.statusDesc !== "") {
      obj.statusDesc = message.statusDesc;
    }
    if (message.unbondingTime !== 0) {
      obj.unbondingTime = Math.round(message.unbondingTime);
    }
    if (message.undelegationResponse !== undefined) {
      obj.undelegationResponse = BTCUndelegationResponse.toJSON(
        message.undelegationResponse,
      );
    }
    if (message.paramsVersion !== 0) {
      obj.paramsVersion = Math.round(message.paramsVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BTCDelegationResponse>, I>>(
    base?: I,
  ): BTCDelegationResponse {
    return BTCDelegationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BTCDelegationResponse>, I>>(
    object: I,
  ): BTCDelegationResponse {
    const message = createBaseBTCDelegationResponse();
    message.stakerAddr = object.stakerAddr ?? "";
    message.btcPk = object.btcPk ?? new Uint8Array(0);
    message.fpBtcPkList = object.fpBtcPkList?.map((e) => e) || [];
    message.stakingTime = object.stakingTime ?? 0;
    message.startHeight = object.startHeight ?? 0;
    message.endHeight = object.endHeight ?? 0;
    message.totalSat = object.totalSat ?? 0;
    message.stakingTxHex = object.stakingTxHex ?? "";
    message.slashingTxHex = object.slashingTxHex ?? "";
    message.delegatorSlashSigHex = object.delegatorSlashSigHex ?? "";
    message.covenantSigs =
      object.covenantSigs?.map((e) =>
        CovenantAdaptorSignatures.fromPartial(e),
      ) || [];
    message.stakingOutputIdx = object.stakingOutputIdx ?? 0;
    message.active = object.active ?? false;
    message.statusDesc = object.statusDesc ?? "";
    message.unbondingTime = object.unbondingTime ?? 0;
    message.undelegationResponse =
      object.undelegationResponse !== undefined &&
      object.undelegationResponse !== null
        ? BTCUndelegationResponse.fromPartial(object.undelegationResponse)
        : undefined;
    message.paramsVersion = object.paramsVersion ?? 0;
    return message;
  },
};

function createBaseBTCUndelegationResponse(): BTCUndelegationResponse {
  return {
    unbondingTxHex: "",
    delegatorUnbondingSigHex: "",
    covenantUnbondingSigList: [],
    slashingTxHex: "",
    delegatorSlashingSigHex: "",
    covenantSlashingSigs: [],
  };
}

export const BTCUndelegationResponse: MessageFns<BTCUndelegationResponse> = {
  encode(
    message: BTCUndelegationResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.unbondingTxHex !== "") {
      writer.uint32(10).string(message.unbondingTxHex);
    }
    if (message.delegatorUnbondingSigHex !== "") {
      writer.uint32(18).string(message.delegatorUnbondingSigHex);
    }
    for (const v of message.covenantUnbondingSigList) {
      SignatureInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.slashingTxHex !== "") {
      writer.uint32(34).string(message.slashingTxHex);
    }
    if (message.delegatorSlashingSigHex !== "") {
      writer.uint32(42).string(message.delegatorSlashingSigHex);
    }
    for (const v of message.covenantSlashingSigs) {
      CovenantAdaptorSignatures.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): BTCUndelegationResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCUndelegationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.unbondingTxHex = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.delegatorUnbondingSigHex = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.covenantUnbondingSigList.push(
            SignatureInfo.decode(reader, reader.uint32()),
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.slashingTxHex = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.delegatorSlashingSigHex = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.covenantSlashingSigs.push(
            CovenantAdaptorSignatures.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCUndelegationResponse {
    return {
      unbondingTxHex: isSet(object.unbondingTxHex)
        ? globalThis.String(object.unbondingTxHex)
        : "",
      delegatorUnbondingSigHex: isSet(object.delegatorUnbondingSigHex)
        ? globalThis.String(object.delegatorUnbondingSigHex)
        : "",
      covenantUnbondingSigList: globalThis.Array.isArray(
        object?.covenantUnbondingSigList,
      )
        ? object.covenantUnbondingSigList.map((e: any) =>
            SignatureInfo.fromJSON(e),
          )
        : [],
      slashingTxHex: isSet(object.slashingTxHex)
        ? globalThis.String(object.slashingTxHex)
        : "",
      delegatorSlashingSigHex: isSet(object.delegatorSlashingSigHex)
        ? globalThis.String(object.delegatorSlashingSigHex)
        : "",
      covenantSlashingSigs: globalThis.Array.isArray(
        object?.covenantSlashingSigs,
      )
        ? object.covenantSlashingSigs.map((e: any) =>
            CovenantAdaptorSignatures.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: BTCUndelegationResponse): unknown {
    const obj: any = {};
    if (message.unbondingTxHex !== "") {
      obj.unbondingTxHex = message.unbondingTxHex;
    }
    if (message.delegatorUnbondingSigHex !== "") {
      obj.delegatorUnbondingSigHex = message.delegatorUnbondingSigHex;
    }
    if (message.covenantUnbondingSigList?.length) {
      obj.covenantUnbondingSigList = message.covenantUnbondingSigList.map((e) =>
        SignatureInfo.toJSON(e),
      );
    }
    if (message.slashingTxHex !== "") {
      obj.slashingTxHex = message.slashingTxHex;
    }
    if (message.delegatorSlashingSigHex !== "") {
      obj.delegatorSlashingSigHex = message.delegatorSlashingSigHex;
    }
    if (message.covenantSlashingSigs?.length) {
      obj.covenantSlashingSigs = message.covenantSlashingSigs.map((e) =>
        CovenantAdaptorSignatures.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BTCUndelegationResponse>, I>>(
    base?: I,
  ): BTCUndelegationResponse {
    return BTCUndelegationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BTCUndelegationResponse>, I>>(
    object: I,
  ): BTCUndelegationResponse {
    const message = createBaseBTCUndelegationResponse();
    message.unbondingTxHex = object.unbondingTxHex ?? "";
    message.delegatorUnbondingSigHex = object.delegatorUnbondingSigHex ?? "";
    message.covenantUnbondingSigList =
      object.covenantUnbondingSigList?.map((e) =>
        SignatureInfo.fromPartial(e),
      ) || [];
    message.slashingTxHex = object.slashingTxHex ?? "";
    message.delegatorSlashingSigHex = object.delegatorSlashingSigHex ?? "";
    message.covenantSlashingSigs =
      object.covenantSlashingSigs?.map((e) =>
        CovenantAdaptorSignatures.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseBTCDelegatorDelegationsResponse(): BTCDelegatorDelegationsResponse {
  return { dels: [] };
}

export const BTCDelegatorDelegationsResponse: MessageFns<BTCDelegatorDelegationsResponse> =
  {
    encode(
      message: BTCDelegatorDelegationsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.dels) {
        BTCDelegationResponse.encode(v!, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): BTCDelegatorDelegationsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseBTCDelegatorDelegationsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.dels.push(
              BTCDelegationResponse.decode(reader, reader.uint32()),
            );
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): BTCDelegatorDelegationsResponse {
      return {
        dels: globalThis.Array.isArray(object?.dels)
          ? object.dels.map((e: any) => BTCDelegationResponse.fromJSON(e))
          : [],
      };
    },

    toJSON(message: BTCDelegatorDelegationsResponse): unknown {
      const obj: any = {};
      if (message.dels?.length) {
        obj.dels = message.dels.map((e) => BTCDelegationResponse.toJSON(e));
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<BTCDelegatorDelegationsResponse>, I>>(
      base?: I,
    ): BTCDelegatorDelegationsResponse {
      return BTCDelegatorDelegationsResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<BTCDelegatorDelegationsResponse>, I>,
    >(object: I): BTCDelegatorDelegationsResponse {
      const message = createBaseBTCDelegatorDelegationsResponse();
      message.dels =
        object.dels?.map((e) => BTCDelegationResponse.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseFinalityProviderResponse(): FinalityProviderResponse {
  return {
    description: undefined,
    commission: "",
    addr: "",
    btcPk: new Uint8Array(0),
    pop: undefined,
    slashedBabylonHeight: 0,
    slashedBtcHeight: 0,
    height: 0,
    votingPower: 0,
    jailed: false,
  };
}

export const FinalityProviderResponse: MessageFns<FinalityProviderResponse> = {
  encode(
    message: FinalityProviderResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.description !== undefined) {
      Description.encode(message.description, writer.uint32(10).fork()).join();
    }
    if (message.commission !== "") {
      writer.uint32(18).string(message.commission);
    }
    if (message.addr !== "") {
      writer.uint32(26).string(message.addr);
    }
    if (message.btcPk.length !== 0) {
      writer.uint32(34).bytes(message.btcPk);
    }
    if (message.pop !== undefined) {
      ProofOfPossessionBTC.encode(message.pop, writer.uint32(42).fork()).join();
    }
    if (message.slashedBabylonHeight !== 0) {
      writer.uint32(48).uint64(message.slashedBabylonHeight);
    }
    if (message.slashedBtcHeight !== 0) {
      writer.uint32(56).uint32(message.slashedBtcHeight);
    }
    if (message.height !== 0) {
      writer.uint32(64).uint64(message.height);
    }
    if (message.votingPower !== 0) {
      writer.uint32(72).uint64(message.votingPower);
    }
    if (message.jailed !== false) {
      writer.uint32(80).bool(message.jailed);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): FinalityProviderResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalityProviderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = Description.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.commission = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.addr = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.btcPk = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pop = ProofOfPossessionBTC.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.slashedBabylonHeight = longToNumber(reader.uint64());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.slashedBtcHeight = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.votingPower = longToNumber(reader.uint64());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.jailed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalityProviderResponse {
    return {
      description: isSet(object.description)
        ? Description.fromJSON(object.description)
        : undefined,
      commission: isSet(object.commission)
        ? globalThis.String(object.commission)
        : "",
      addr: isSet(object.addr) ? globalThis.String(object.addr) : "",
      btcPk: isSet(object.btcPk)
        ? bytesFromBase64(object.btcPk)
        : new Uint8Array(0),
      pop: isSet(object.pop)
        ? ProofOfPossessionBTC.fromJSON(object.pop)
        : undefined,
      slashedBabylonHeight: isSet(object.slashedBabylonHeight)
        ? globalThis.Number(object.slashedBabylonHeight)
        : 0,
      slashedBtcHeight: isSet(object.slashedBtcHeight)
        ? globalThis.Number(object.slashedBtcHeight)
        : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      votingPower: isSet(object.votingPower)
        ? globalThis.Number(object.votingPower)
        : 0,
      jailed: isSet(object.jailed) ? globalThis.Boolean(object.jailed) : false,
    };
  },

  toJSON(message: FinalityProviderResponse): unknown {
    const obj: any = {};
    if (message.description !== undefined) {
      obj.description = Description.toJSON(message.description);
    }
    if (message.commission !== "") {
      obj.commission = message.commission;
    }
    if (message.addr !== "") {
      obj.addr = message.addr;
    }
    if (message.btcPk.length !== 0) {
      obj.btcPk = base64FromBytes(message.btcPk);
    }
    if (message.pop !== undefined) {
      obj.pop = ProofOfPossessionBTC.toJSON(message.pop);
    }
    if (message.slashedBabylonHeight !== 0) {
      obj.slashedBabylonHeight = Math.round(message.slashedBabylonHeight);
    }
    if (message.slashedBtcHeight !== 0) {
      obj.slashedBtcHeight = Math.round(message.slashedBtcHeight);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.votingPower !== 0) {
      obj.votingPower = Math.round(message.votingPower);
    }
    if (message.jailed !== false) {
      obj.jailed = message.jailed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FinalityProviderResponse>, I>>(
    base?: I,
  ): FinalityProviderResponse {
    return FinalityProviderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FinalityProviderResponse>, I>>(
    object: I,
  ): FinalityProviderResponse {
    const message = createBaseFinalityProviderResponse();
    message.description =
      object.description !== undefined && object.description !== null
        ? Description.fromPartial(object.description)
        : undefined;
    message.commission = object.commission ?? "";
    message.addr = object.addr ?? "";
    message.btcPk = object.btcPk ?? new Uint8Array(0);
    message.pop =
      object.pop !== undefined && object.pop !== null
        ? ProofOfPossessionBTC.fromPartial(object.pop)
        : undefined;
    message.slashedBabylonHeight = object.slashedBabylonHeight ?? 0;
    message.slashedBtcHeight = object.slashedBtcHeight ?? 0;
    message.height = object.height ?? 0;
    message.votingPower = object.votingPower ?? 0;
    message.jailed = object.jailed ?? false;
    return message;
  },
};

/** Query defines the gRPC querier service. */
export interface Query {
  /** Parameters queries the parameters of the module. */
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
  /** ParamsByVersion queries the parameters of the module for a specific version of past params. */
  ParamsByVersion(
    request: QueryParamsByVersionRequest,
  ): Promise<QueryParamsByVersionResponse>;
  /** FinalityProviders queries all finality providers */
  FinalityProviders(
    request: QueryFinalityProvidersRequest,
  ): Promise<QueryFinalityProvidersResponse>;
  /** FinalityProvider info about one finality provider */
  FinalityProvider(
    request: QueryFinalityProviderRequest,
  ): Promise<QueryFinalityProviderResponse>;
  /** BTCDelegations queries all BTC delegations under a given status */
  BTCDelegations(
    request: QueryBTCDelegationsRequest,
  ): Promise<QueryBTCDelegationsResponse>;
  /** ActiveFinalityProvidersAtHeight queries finality providers with non zero voting power at given height. */
  ActiveFinalityProvidersAtHeight(
    request: QueryActiveFinalityProvidersAtHeightRequest,
  ): Promise<QueryActiveFinalityProvidersAtHeightResponse>;
  /** FinalityProviderPowerAtHeight queries the voting power of a finality provider at a given height */
  FinalityProviderPowerAtHeight(
    request: QueryFinalityProviderPowerAtHeightRequest,
  ): Promise<QueryFinalityProviderPowerAtHeightResponse>;
  /** FinalityProviderCurrentPower queries the voting power of a finality provider at the current height */
  FinalityProviderCurrentPower(
    request: QueryFinalityProviderCurrentPowerRequest,
  ): Promise<QueryFinalityProviderCurrentPowerResponse>;
  /**
   * ActivatedHeight queries the height when BTC staking protocol is activated, i.e., the first height when
   * there exists 1 finality provider with voting power
   */
  ActivatedHeight(
    request: QueryActivatedHeightRequest,
  ): Promise<QueryActivatedHeightResponse>;
  /** FinalityProviderDelegations queries all BTC delegations of the given finality provider */
  FinalityProviderDelegations(
    request: QueryFinalityProviderDelegationsRequest,
  ): Promise<QueryFinalityProviderDelegationsResponse>;
  /** BTCDelegation retrieves delegation by corresponding staking tx hash */
  BTCDelegation(
    request: QueryBTCDelegationRequest,
  ): Promise<QueryBTCDelegationResponse>;
}

export const QueryServiceName = "babylon.btcstaking.v1.Query";
export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceName;
    this.rpc = rpc;
    this.Params = this.Params.bind(this);
    this.ParamsByVersion = this.ParamsByVersion.bind(this);
    this.FinalityProviders = this.FinalityProviders.bind(this);
    this.FinalityProvider = this.FinalityProvider.bind(this);
    this.BTCDelegations = this.BTCDelegations.bind(this);
    this.ActiveFinalityProvidersAtHeight =
      this.ActiveFinalityProvidersAtHeight.bind(this);
    this.FinalityProviderPowerAtHeight =
      this.FinalityProviderPowerAtHeight.bind(this);
    this.FinalityProviderCurrentPower =
      this.FinalityProviderCurrentPower.bind(this);
    this.ActivatedHeight = this.ActivatedHeight.bind(this);
    this.FinalityProviderDelegations =
      this.FinalityProviderDelegations.bind(this);
    this.BTCDelegation = this.BTCDelegation.bind(this);
  }
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse> {
    const data = QueryParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Params", data);
    return promise.then((data) =>
      QueryParamsResponse.decode(new BinaryReader(data)),
    );
  }

  ParamsByVersion(
    request: QueryParamsByVersionRequest,
  ): Promise<QueryParamsByVersionResponse> {
    const data = QueryParamsByVersionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ParamsByVersion", data);
    return promise.then((data) =>
      QueryParamsByVersionResponse.decode(new BinaryReader(data)),
    );
  }

  FinalityProviders(
    request: QueryFinalityProvidersRequest,
  ): Promise<QueryFinalityProvidersResponse> {
    const data = QueryFinalityProvidersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FinalityProviders", data);
    return promise.then((data) =>
      QueryFinalityProvidersResponse.decode(new BinaryReader(data)),
    );
  }

  FinalityProvider(
    request: QueryFinalityProviderRequest,
  ): Promise<QueryFinalityProviderResponse> {
    const data = QueryFinalityProviderRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FinalityProvider", data);
    return promise.then((data) =>
      QueryFinalityProviderResponse.decode(new BinaryReader(data)),
    );
  }

  BTCDelegations(
    request: QueryBTCDelegationsRequest,
  ): Promise<QueryBTCDelegationsResponse> {
    const data = QueryBTCDelegationsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BTCDelegations", data);
    return promise.then((data) =>
      QueryBTCDelegationsResponse.decode(new BinaryReader(data)),
    );
  }

  ActiveFinalityProvidersAtHeight(
    request: QueryActiveFinalityProvidersAtHeightRequest,
  ): Promise<QueryActiveFinalityProvidersAtHeightResponse> {
    const data =
      QueryActiveFinalityProvidersAtHeightRequest.encode(request).finish();
    const promise = this.rpc.request(
      this.service,
      "ActiveFinalityProvidersAtHeight",
      data,
    );
    return promise.then((data) =>
      QueryActiveFinalityProvidersAtHeightResponse.decode(
        new BinaryReader(data),
      ),
    );
  }

  FinalityProviderPowerAtHeight(
    request: QueryFinalityProviderPowerAtHeightRequest,
  ): Promise<QueryFinalityProviderPowerAtHeightResponse> {
    const data =
      QueryFinalityProviderPowerAtHeightRequest.encode(request).finish();
    const promise = this.rpc.request(
      this.service,
      "FinalityProviderPowerAtHeight",
      data,
    );
    return promise.then((data) =>
      QueryFinalityProviderPowerAtHeightResponse.decode(new BinaryReader(data)),
    );
  }

  FinalityProviderCurrentPower(
    request: QueryFinalityProviderCurrentPowerRequest,
  ): Promise<QueryFinalityProviderCurrentPowerResponse> {
    const data =
      QueryFinalityProviderCurrentPowerRequest.encode(request).finish();
    const promise = this.rpc.request(
      this.service,
      "FinalityProviderCurrentPower",
      data,
    );
    return promise.then((data) =>
      QueryFinalityProviderCurrentPowerResponse.decode(new BinaryReader(data)),
    );
  }

  ActivatedHeight(
    request: QueryActivatedHeightRequest,
  ): Promise<QueryActivatedHeightResponse> {
    const data = QueryActivatedHeightRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ActivatedHeight", data);
    return promise.then((data) =>
      QueryActivatedHeightResponse.decode(new BinaryReader(data)),
    );
  }

  FinalityProviderDelegations(
    request: QueryFinalityProviderDelegationsRequest,
  ): Promise<QueryFinalityProviderDelegationsResponse> {
    const data =
      QueryFinalityProviderDelegationsRequest.encode(request).finish();
    const promise = this.rpc.request(
      this.service,
      "FinalityProviderDelegations",
      data,
    );
    return promise.then((data) =>
      QueryFinalityProviderDelegationsResponse.decode(new BinaryReader(data)),
    );
  }

  BTCDelegation(
    request: QueryBTCDelegationRequest,
  ): Promise<QueryBTCDelegationResponse> {
    const data = QueryBTCDelegationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BTCDelegation", data);
    return promise.then((data) =>
      QueryBTCDelegationResponse.decode(new BinaryReader(data)),
    );
  }
}

interface Rpc {
  request(
    service: string,
    method: string,
    data: Uint8Array,
  ): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
