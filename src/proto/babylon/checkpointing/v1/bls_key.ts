// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: babylon/checkpointing/v1/bls_key.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "babylon.checkpointing.v1";

/** BlsKey wraps BLS public key with PoP */
export interface BlsKey {
  /** pubkey is the BLS public key of a validator */
  pubkey: Uint8Array;
  /** pop is the proof-of-possession of the BLS key */
  pop: ProofOfPossession | undefined;
}

/**
 * ProofOfPossession defines proof for the ownership of Ed25519 and BLS private
 * keys
 */
export interface ProofOfPossession {
  /**
   * ed25519_sig is used for verification, ed25519_sig = sign(key = Ed25519_sk,
   * data = BLS_pk)
   */
  ed25519Sig: Uint8Array;
  /**
   * bls_sig is the result of PoP, bls_sig = sign(key = BLS_sk, data =
   * ed25519_sig)
   */
  blsSig: Uint8Array;
}

/** ValidatorWithBLSSet defines a set of validators with their BLS public keys */
export interface ValidatorWithBlsKeySet {
  valSet: ValidatorWithBlsKey[];
}

/**
 * ValidatorWithBlsKey couples validator address, voting power, and its bls
 * public key
 */
export interface ValidatorWithBlsKey {
  /** validator_address is the address of the validator */
  validatorAddress: string;
  /** bls_pub_key is the BLS public key of the validator */
  blsPubKey: Uint8Array;
  /** voting_power is the voting power of the validator at the given epoch */
  votingPower: number;
}

/** VoteExtension defines the structure used to create a BLS vote extension. */
export interface VoteExtension {
  /** signer is the address of the vote extension signer */
  signer: string;
  /** validator_address is the address of the validator */
  validatorAddress: string;
  /** block_hash is the hash of the block that the vote extension is signed over */
  blockHash: Uint8Array;
  /** epoch_num is the epoch number of the vote extension */
  epochNum: number;
  /** height is the height of the vote extension */
  height: number;
  /** bls_sig is the BLS signature */
  blsSig: Uint8Array;
}

function createBaseBlsKey(): BlsKey {
  return { pubkey: new Uint8Array(0), pop: undefined };
}

export const BlsKey: MessageFns<BlsKey> = {
  encode(
    message: BlsKey,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.pubkey.length !== 0) {
      writer.uint32(10).bytes(message.pubkey);
    }
    if (message.pop !== undefined) {
      ProofOfPossession.encode(message.pop, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlsKey {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlsKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pubkey = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pop = ProofOfPossession.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlsKey {
    return {
      pubkey: isSet(object.pubkey)
        ? bytesFromBase64(object.pubkey)
        : new Uint8Array(0),
      pop: isSet(object.pop)
        ? ProofOfPossession.fromJSON(object.pop)
        : undefined,
    };
  },

  toJSON(message: BlsKey): unknown {
    const obj: any = {};
    if (message.pubkey.length !== 0) {
      obj.pubkey = base64FromBytes(message.pubkey);
    }
    if (message.pop !== undefined) {
      obj.pop = ProofOfPossession.toJSON(message.pop);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlsKey>, I>>(base?: I): BlsKey {
    return BlsKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlsKey>, I>>(object: I): BlsKey {
    const message = createBaseBlsKey();
    message.pubkey = object.pubkey ?? new Uint8Array(0);
    message.pop =
      object.pop !== undefined && object.pop !== null
        ? ProofOfPossession.fromPartial(object.pop)
        : undefined;
    return message;
  },
};

function createBaseProofOfPossession(): ProofOfPossession {
  return { ed25519Sig: new Uint8Array(0), blsSig: new Uint8Array(0) };
}

export const ProofOfPossession: MessageFns<ProofOfPossession> = {
  encode(
    message: ProofOfPossession,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.ed25519Sig.length !== 0) {
      writer.uint32(10).bytes(message.ed25519Sig);
    }
    if (message.blsSig.length !== 0) {
      writer.uint32(18).bytes(message.blsSig);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProofOfPossession {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProofOfPossession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ed25519Sig = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blsSig = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProofOfPossession {
    return {
      ed25519Sig: isSet(object.ed25519Sig)
        ? bytesFromBase64(object.ed25519Sig)
        : new Uint8Array(0),
      blsSig: isSet(object.blsSig)
        ? bytesFromBase64(object.blsSig)
        : new Uint8Array(0),
    };
  },

  toJSON(message: ProofOfPossession): unknown {
    const obj: any = {};
    if (message.ed25519Sig.length !== 0) {
      obj.ed25519Sig = base64FromBytes(message.ed25519Sig);
    }
    if (message.blsSig.length !== 0) {
      obj.blsSig = base64FromBytes(message.blsSig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProofOfPossession>, I>>(
    base?: I,
  ): ProofOfPossession {
    return ProofOfPossession.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProofOfPossession>, I>>(
    object: I,
  ): ProofOfPossession {
    const message = createBaseProofOfPossession();
    message.ed25519Sig = object.ed25519Sig ?? new Uint8Array(0);
    message.blsSig = object.blsSig ?? new Uint8Array(0);
    return message;
  },
};

function createBaseValidatorWithBlsKeySet(): ValidatorWithBlsKeySet {
  return { valSet: [] };
}

export const ValidatorWithBlsKeySet: MessageFns<ValidatorWithBlsKeySet> = {
  encode(
    message: ValidatorWithBlsKeySet,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.valSet) {
      ValidatorWithBlsKey.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ValidatorWithBlsKeySet {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatorWithBlsKeySet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.valSet.push(
            ValidatorWithBlsKey.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatorWithBlsKeySet {
    return {
      valSet: globalThis.Array.isArray(object?.valSet)
        ? object.valSet.map((e: any) => ValidatorWithBlsKey.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ValidatorWithBlsKeySet): unknown {
    const obj: any = {};
    if (message.valSet?.length) {
      obj.valSet = message.valSet.map((e) => ValidatorWithBlsKey.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidatorWithBlsKeySet>, I>>(
    base?: I,
  ): ValidatorWithBlsKeySet {
    return ValidatorWithBlsKeySet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidatorWithBlsKeySet>, I>>(
    object: I,
  ): ValidatorWithBlsKeySet {
    const message = createBaseValidatorWithBlsKeySet();
    message.valSet =
      object.valSet?.map((e) => ValidatorWithBlsKey.fromPartial(e)) || [];
    return message;
  },
};

function createBaseValidatorWithBlsKey(): ValidatorWithBlsKey {
  return { validatorAddress: "", blsPubKey: new Uint8Array(0), votingPower: 0 };
}

export const ValidatorWithBlsKey: MessageFns<ValidatorWithBlsKey> = {
  encode(
    message: ValidatorWithBlsKey,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    if (message.blsPubKey.length !== 0) {
      writer.uint32(18).bytes(message.blsPubKey);
    }
    if (message.votingPower !== 0) {
      writer.uint32(24).uint64(message.votingPower);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ValidatorWithBlsKey {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatorWithBlsKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blsPubKey = reader.bytes();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.votingPower = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatorWithBlsKey {
    return {
      validatorAddress: isSet(object.validatorAddress)
        ? globalThis.String(object.validatorAddress)
        : "",
      blsPubKey: isSet(object.blsPubKey)
        ? bytesFromBase64(object.blsPubKey)
        : new Uint8Array(0),
      votingPower: isSet(object.votingPower)
        ? globalThis.Number(object.votingPower)
        : 0,
    };
  },

  toJSON(message: ValidatorWithBlsKey): unknown {
    const obj: any = {};
    if (message.validatorAddress !== "") {
      obj.validatorAddress = message.validatorAddress;
    }
    if (message.blsPubKey.length !== 0) {
      obj.blsPubKey = base64FromBytes(message.blsPubKey);
    }
    if (message.votingPower !== 0) {
      obj.votingPower = Math.round(message.votingPower);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidatorWithBlsKey>, I>>(
    base?: I,
  ): ValidatorWithBlsKey {
    return ValidatorWithBlsKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidatorWithBlsKey>, I>>(
    object: I,
  ): ValidatorWithBlsKey {
    const message = createBaseValidatorWithBlsKey();
    message.validatorAddress = object.validatorAddress ?? "";
    message.blsPubKey = object.blsPubKey ?? new Uint8Array(0);
    message.votingPower = object.votingPower ?? 0;
    return message;
  },
};

function createBaseVoteExtension(): VoteExtension {
  return {
    signer: "",
    validatorAddress: "",
    blockHash: new Uint8Array(0),
    epochNum: 0,
    height: 0,
    blsSig: new Uint8Array(0),
  };
}

export const VoteExtension: MessageFns<VoteExtension> = {
  encode(
    message: VoteExtension,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.signer !== "") {
      writer.uint32(10).string(message.signer);
    }
    if (message.validatorAddress !== "") {
      writer.uint32(18).string(message.validatorAddress);
    }
    if (message.blockHash.length !== 0) {
      writer.uint32(26).bytes(message.blockHash);
    }
    if (message.epochNum !== 0) {
      writer.uint32(32).uint64(message.epochNum);
    }
    if (message.height !== 0) {
      writer.uint32(40).uint64(message.height);
    }
    if (message.blsSig.length !== 0) {
      writer.uint32(50).bytes(message.blsSig);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VoteExtension {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoteExtension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signer = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.blockHash = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.epochNum = longToNumber(reader.uint64());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.blsSig = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoteExtension {
    return {
      signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
      validatorAddress: isSet(object.validatorAddress)
        ? globalThis.String(object.validatorAddress)
        : "",
      blockHash: isSet(object.blockHash)
        ? bytesFromBase64(object.blockHash)
        : new Uint8Array(0),
      epochNum: isSet(object.epochNum) ? globalThis.Number(object.epochNum) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      blsSig: isSet(object.blsSig)
        ? bytesFromBase64(object.blsSig)
        : new Uint8Array(0),
    };
  },

  toJSON(message: VoteExtension): unknown {
    const obj: any = {};
    if (message.signer !== "") {
      obj.signer = message.signer;
    }
    if (message.validatorAddress !== "") {
      obj.validatorAddress = message.validatorAddress;
    }
    if (message.blockHash.length !== 0) {
      obj.blockHash = base64FromBytes(message.blockHash);
    }
    if (message.epochNum !== 0) {
      obj.epochNum = Math.round(message.epochNum);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.blsSig.length !== 0) {
      obj.blsSig = base64FromBytes(message.blsSig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VoteExtension>, I>>(
    base?: I,
  ): VoteExtension {
    return VoteExtension.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VoteExtension>, I>>(
    object: I,
  ): VoteExtension {
    const message = createBaseVoteExtension();
    message.signer = object.signer ?? "";
    message.validatorAddress = object.validatorAddress ?? "";
    message.blockHash = object.blockHash ?? new Uint8Array(0);
    message.epochNum = object.epochNum ?? 0;
    message.height = object.height ?? 0;
    message.blsSig = object.blsSig ?? new Uint8Array(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
