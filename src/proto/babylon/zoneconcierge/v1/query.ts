// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: babylon/zoneconcierge/v1/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  PageRequest,
  PageResponse,
} from "../../../cosmos/base/query/v1beta1/pagination";
import { SubmissionKey } from "../../btccheckpoint/v1/btccheckpoint";
import { RawCheckpoint } from "../../checkpointing/v1/checkpoint";
import { Epoch } from "../../epoching/v1/epoching";
import { Params } from "./params";
import {
  ChainInfo,
  FinalizedChainInfo,
  Forks,
  IndexedHeader,
  ProofFinalizedChainInfo,
} from "./zoneconcierge";

export const protobufPackage = "babylon.zoneconcierge.v1";

/** QueryParamsRequest is the request type for the Query/Params RPC method. */
export interface QueryParamsRequest {}

/** QueryParamsResponse is the response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
  /** params holds all the parameters of this module. */
  params: Params | undefined;
}

/** QueryHeaderRequest is request type for the Query/Header RPC method. */
export interface QueryHeaderRequest {
  chainId: string;
  height: number;
}

/** QueryHeaderResponse is response type for the Query/Header RPC method. */
export interface QueryHeaderResponse {
  header: IndexedHeader | undefined;
  forkHeaders: Forks | undefined;
}

/** QueryChainListRequest is request type for the Query/ChainList RPC method */
export interface QueryChainListRequest {
  /** pagination defines whether to have the pagination in the request */
  pagination: PageRequest | undefined;
}

/** QueryChainListResponse is response type for the Query/ChainList RPC method */
export interface QueryChainListResponse {
  /** chain_ids are IDs of the chains in ascending alphabetical order */
  chainIds: string[];
  /** pagination defines the pagination in the response */
  pagination: PageResponse | undefined;
}

/** QueryChainsInfoRequest is request type for the Query/ChainsInfo RPC method. */
export interface QueryChainsInfoRequest {
  chainIds: string[];
}

/** QueryChainsInfoResponse is response type for the Query/ChainsInfo RPC method. */
export interface QueryChainsInfoResponse {
  chainsInfo: ChainInfo[];
}

/**
 * QueryEpochChainsInfoRequest is request type for the Query/EpochChainsInfo RPC
 * method.
 */
export interface QueryEpochChainsInfoRequest {
  epochNum: number;
  chainIds: string[];
}

/**
 * QueryEpochChainsInfoResponse is response type for the Query/EpochChainsInfo RPC
 * method.
 */
export interface QueryEpochChainsInfoResponse {
  /** chain_info is the info of the CZ */
  chainsInfo: ChainInfo[];
}

/** QueryListHeadersRequest is request type for the Query/ListHeaders RPC method. */
export interface QueryListHeadersRequest {
  chainId: string;
  /** pagination defines whether to have the pagination in the request */
  pagination: PageRequest | undefined;
}

/**
 * QueryListHeadersResponse is response type for the Query/ListHeaders RPC
 * method.
 */
export interface QueryListHeadersResponse {
  /** headers is the list of headers */
  headers: IndexedHeader[];
  /** pagination defines the pagination in the response */
  pagination: PageResponse | undefined;
}

/**
 * QueryListEpochHeadersRequest is request type for the Query/ListEpochHeaders
 * RPC method.
 */
export interface QueryListEpochHeadersRequest {
  epochNum: number;
  chainId: string;
}

/**
 * QueryListEpochHeadersResponse is response type for the Query/ListEpochHeaders
 * RPC method.
 */
export interface QueryListEpochHeadersResponse {
  /** headers is the list of headers */
  headers: IndexedHeader[];
}

/**
 * QueryFinalizedChainsInfoRequest is request type for the
 * Query/FinalizedChainsInfo RPC method.
 */
export interface QueryFinalizedChainsInfoRequest {
  /** chain_ids is the list of ids of CZs */
  chainIds: string[];
  /** prove indicates whether the querier wants to get proofs of this timestamp */
  prove: boolean;
}

/**
 * QueryFinalizedChainsInfoResponse is response type for the
 * Query/FinalizedChainsInfo RPC method.
 */
export interface QueryFinalizedChainsInfoResponse {
  finalizedChainsInfo: FinalizedChainInfo[];
}

/**
 * QueryFinalizedChainInfoUntilHeightRequest is request type for the
 * Query/FinalizedChainInfoUntilHeight RPC method.
 */
export interface QueryFinalizedChainInfoUntilHeightRequest {
  /** chain_id is the ID of the CZ */
  chainId: string;
  /**
   * height is the height of the CZ chain
   * such that the returned finalised chain info will be no later than this
   * height
   */
  height: number;
  /** prove indicates whether the querier wants to get proofs of this timestamp */
  prove: boolean;
}

/**
 * QueryFinalizedChainInfoUntilHeightResponse is response type for the
 * Query/FinalizedChainInfoUntilHeight RPC method.
 */
export interface QueryFinalizedChainInfoUntilHeightResponse {
  /** finalized_chain_info is the info of the CZ */
  finalizedChainInfo: ChainInfo | undefined;
  /** epoch_info is the metadata of the last BTC-finalised epoch */
  epochInfo: Epoch | undefined;
  /** raw_checkpoint is the raw checkpoint of this epoch */
  rawCheckpoint: RawCheckpoint | undefined;
  /**
   * btc_submission_key is position of two BTC txs that include the raw
   * checkpoint of this epoch
   */
  btcSubmissionKey: SubmissionKey | undefined;
  /** proof is the proof that the chain info is finalized */
  proof: ProofFinalizedChainInfo | undefined;
}

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(
    _: QueryParamsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryParamsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(
    base?: I,
  ): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(
    _: I,
  ): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(
    message: QueryParamsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryParamsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return {
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(
    base?: I,
  ): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(
    object: I,
  ): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params =
      object.params !== undefined && object.params !== null
        ? Params.fromPartial(object.params)
        : undefined;
    return message;
  },
};

function createBaseQueryHeaderRequest(): QueryHeaderRequest {
  return { chainId: "", height: 0 };
}

export const QueryHeaderRequest: MessageFns<QueryHeaderRequest> = {
  encode(
    message: QueryHeaderRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.height !== 0) {
      writer.uint32(16).uint64(message.height);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryHeaderRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryHeaderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryHeaderRequest {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: QueryHeaderRequest): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryHeaderRequest>, I>>(
    base?: I,
  ): QueryHeaderRequest {
    return QueryHeaderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryHeaderRequest>, I>>(
    object: I,
  ): QueryHeaderRequest {
    const message = createBaseQueryHeaderRequest();
    message.chainId = object.chainId ?? "";
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseQueryHeaderResponse(): QueryHeaderResponse {
  return { header: undefined, forkHeaders: undefined };
}

export const QueryHeaderResponse: MessageFns<QueryHeaderResponse> = {
  encode(
    message: QueryHeaderResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.header !== undefined) {
      IndexedHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.forkHeaders !== undefined) {
      Forks.encode(message.forkHeaders, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryHeaderResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryHeaderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = IndexedHeader.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.forkHeaders = Forks.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryHeaderResponse {
    return {
      header: isSet(object.header)
        ? IndexedHeader.fromJSON(object.header)
        : undefined,
      forkHeaders: isSet(object.forkHeaders)
        ? Forks.fromJSON(object.forkHeaders)
        : undefined,
    };
  },

  toJSON(message: QueryHeaderResponse): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = IndexedHeader.toJSON(message.header);
    }
    if (message.forkHeaders !== undefined) {
      obj.forkHeaders = Forks.toJSON(message.forkHeaders);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryHeaderResponse>, I>>(
    base?: I,
  ): QueryHeaderResponse {
    return QueryHeaderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryHeaderResponse>, I>>(
    object: I,
  ): QueryHeaderResponse {
    const message = createBaseQueryHeaderResponse();
    message.header =
      object.header !== undefined && object.header !== null
        ? IndexedHeader.fromPartial(object.header)
        : undefined;
    message.forkHeaders =
      object.forkHeaders !== undefined && object.forkHeaders !== null
        ? Forks.fromPartial(object.forkHeaders)
        : undefined;
    return message;
  },
};

function createBaseQueryChainListRequest(): QueryChainListRequest {
  return { pagination: undefined };
}

export const QueryChainListRequest: MessageFns<QueryChainListRequest> = {
  encode(
    message: QueryChainListRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryChainListRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryChainListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryChainListRequest {
    return {
      pagination: isSet(object.pagination)
        ? PageRequest.fromJSON(object.pagination)
        : undefined,
    };
  },

  toJSON(message: QueryChainListRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryChainListRequest>, I>>(
    base?: I,
  ): QueryChainListRequest {
    return QueryChainListRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryChainListRequest>, I>>(
    object: I,
  ): QueryChainListRequest {
    const message = createBaseQueryChainListRequest();
    message.pagination =
      object.pagination !== undefined && object.pagination !== null
        ? PageRequest.fromPartial(object.pagination)
        : undefined;
    return message;
  },
};

function createBaseQueryChainListResponse(): QueryChainListResponse {
  return { chainIds: [], pagination: undefined };
}

export const QueryChainListResponse: MessageFns<QueryChainListResponse> = {
  encode(
    message: QueryChainListResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.chainIds) {
      writer.uint32(10).string(v!);
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryChainListResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryChainListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryChainListResponse {
    return {
      chainIds: globalThis.Array.isArray(object?.chainIds)
        ? object.chainIds.map((e: any) => globalThis.String(e))
        : [],
      pagination: isSet(object.pagination)
        ? PageResponse.fromJSON(object.pagination)
        : undefined,
    };
  },

  toJSON(message: QueryChainListResponse): unknown {
    const obj: any = {};
    if (message.chainIds?.length) {
      obj.chainIds = message.chainIds;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryChainListResponse>, I>>(
    base?: I,
  ): QueryChainListResponse {
    return QueryChainListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryChainListResponse>, I>>(
    object: I,
  ): QueryChainListResponse {
    const message = createBaseQueryChainListResponse();
    message.chainIds = object.chainIds?.map((e) => e) || [];
    message.pagination =
      object.pagination !== undefined && object.pagination !== null
        ? PageResponse.fromPartial(object.pagination)
        : undefined;
    return message;
  },
};

function createBaseQueryChainsInfoRequest(): QueryChainsInfoRequest {
  return { chainIds: [] };
}

export const QueryChainsInfoRequest: MessageFns<QueryChainsInfoRequest> = {
  encode(
    message: QueryChainsInfoRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.chainIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryChainsInfoRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryChainsInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryChainsInfoRequest {
    return {
      chainIds: globalThis.Array.isArray(object?.chainIds)
        ? object.chainIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: QueryChainsInfoRequest): unknown {
    const obj: any = {};
    if (message.chainIds?.length) {
      obj.chainIds = message.chainIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryChainsInfoRequest>, I>>(
    base?: I,
  ): QueryChainsInfoRequest {
    return QueryChainsInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryChainsInfoRequest>, I>>(
    object: I,
  ): QueryChainsInfoRequest {
    const message = createBaseQueryChainsInfoRequest();
    message.chainIds = object.chainIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryChainsInfoResponse(): QueryChainsInfoResponse {
  return { chainsInfo: [] };
}

export const QueryChainsInfoResponse: MessageFns<QueryChainsInfoResponse> = {
  encode(
    message: QueryChainsInfoResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.chainsInfo) {
      ChainInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryChainsInfoResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryChainsInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainsInfo.push(ChainInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryChainsInfoResponse {
    return {
      chainsInfo: globalThis.Array.isArray(object?.chainsInfo)
        ? object.chainsInfo.map((e: any) => ChainInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryChainsInfoResponse): unknown {
    const obj: any = {};
    if (message.chainsInfo?.length) {
      obj.chainsInfo = message.chainsInfo.map((e) => ChainInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryChainsInfoResponse>, I>>(
    base?: I,
  ): QueryChainsInfoResponse {
    return QueryChainsInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryChainsInfoResponse>, I>>(
    object: I,
  ): QueryChainsInfoResponse {
    const message = createBaseQueryChainsInfoResponse();
    message.chainsInfo =
      object.chainsInfo?.map((e) => ChainInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryEpochChainsInfoRequest(): QueryEpochChainsInfoRequest {
  return { epochNum: 0, chainIds: [] };
}

export const QueryEpochChainsInfoRequest: MessageFns<QueryEpochChainsInfoRequest> =
  {
    encode(
      message: QueryEpochChainsInfoRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.epochNum !== 0) {
        writer.uint32(8).uint64(message.epochNum);
      }
      for (const v of message.chainIds) {
        writer.uint32(18).string(v!);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryEpochChainsInfoRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryEpochChainsInfoRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }

            message.epochNum = longToNumber(reader.uint64());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.chainIds.push(reader.string());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryEpochChainsInfoRequest {
      return {
        epochNum: isSet(object.epochNum)
          ? globalThis.Number(object.epochNum)
          : 0,
        chainIds: globalThis.Array.isArray(object?.chainIds)
          ? object.chainIds.map((e: any) => globalThis.String(e))
          : [],
      };
    },

    toJSON(message: QueryEpochChainsInfoRequest): unknown {
      const obj: any = {};
      if (message.epochNum !== 0) {
        obj.epochNum = Math.round(message.epochNum);
      }
      if (message.chainIds?.length) {
        obj.chainIds = message.chainIds;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryEpochChainsInfoRequest>, I>>(
      base?: I,
    ): QueryEpochChainsInfoRequest {
      return QueryEpochChainsInfoRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryEpochChainsInfoRequest>, I>>(
      object: I,
    ): QueryEpochChainsInfoRequest {
      const message = createBaseQueryEpochChainsInfoRequest();
      message.epochNum = object.epochNum ?? 0;
      message.chainIds = object.chainIds?.map((e) => e) || [];
      return message;
    },
  };

function createBaseQueryEpochChainsInfoResponse(): QueryEpochChainsInfoResponse {
  return { chainsInfo: [] };
}

export const QueryEpochChainsInfoResponse: MessageFns<QueryEpochChainsInfoResponse> =
  {
    encode(
      message: QueryEpochChainsInfoResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.chainsInfo) {
        ChainInfo.encode(v!, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryEpochChainsInfoResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryEpochChainsInfoResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.chainsInfo.push(ChainInfo.decode(reader, reader.uint32()));
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryEpochChainsInfoResponse {
      return {
        chainsInfo: globalThis.Array.isArray(object?.chainsInfo)
          ? object.chainsInfo.map((e: any) => ChainInfo.fromJSON(e))
          : [],
      };
    },

    toJSON(message: QueryEpochChainsInfoResponse): unknown {
      const obj: any = {};
      if (message.chainsInfo?.length) {
        obj.chainsInfo = message.chainsInfo.map((e) => ChainInfo.toJSON(e));
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryEpochChainsInfoResponse>, I>>(
      base?: I,
    ): QueryEpochChainsInfoResponse {
      return QueryEpochChainsInfoResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryEpochChainsInfoResponse>, I>>(
      object: I,
    ): QueryEpochChainsInfoResponse {
      const message = createBaseQueryEpochChainsInfoResponse();
      message.chainsInfo =
        object.chainsInfo?.map((e) => ChainInfo.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseQueryListHeadersRequest(): QueryListHeadersRequest {
  return { chainId: "", pagination: undefined };
}

export const QueryListHeadersRequest: MessageFns<QueryListHeadersRequest> = {
  encode(
    message: QueryListHeadersRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryListHeadersRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryListHeadersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryListHeadersRequest {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      pagination: isSet(object.pagination)
        ? PageRequest.fromJSON(object.pagination)
        : undefined,
    };
  },

  toJSON(message: QueryListHeadersRequest): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryListHeadersRequest>, I>>(
    base?: I,
  ): QueryListHeadersRequest {
    return QueryListHeadersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryListHeadersRequest>, I>>(
    object: I,
  ): QueryListHeadersRequest {
    const message = createBaseQueryListHeadersRequest();
    message.chainId = object.chainId ?? "";
    message.pagination =
      object.pagination !== undefined && object.pagination !== null
        ? PageRequest.fromPartial(object.pagination)
        : undefined;
    return message;
  },
};

function createBaseQueryListHeadersResponse(): QueryListHeadersResponse {
  return { headers: [], pagination: undefined };
}

export const QueryListHeadersResponse: MessageFns<QueryListHeadersResponse> = {
  encode(
    message: QueryListHeadersResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.headers) {
      IndexedHeader.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryListHeadersResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryListHeadersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.headers.push(IndexedHeader.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryListHeadersResponse {
    return {
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => IndexedHeader.fromJSON(e))
        : [],
      pagination: isSet(object.pagination)
        ? PageResponse.fromJSON(object.pagination)
        : undefined,
    };
  },

  toJSON(message: QueryListHeadersResponse): unknown {
    const obj: any = {};
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => IndexedHeader.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryListHeadersResponse>, I>>(
    base?: I,
  ): QueryListHeadersResponse {
    return QueryListHeadersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryListHeadersResponse>, I>>(
    object: I,
  ): QueryListHeadersResponse {
    const message = createBaseQueryListHeadersResponse();
    message.headers =
      object.headers?.map((e) => IndexedHeader.fromPartial(e)) || [];
    message.pagination =
      object.pagination !== undefined && object.pagination !== null
        ? PageResponse.fromPartial(object.pagination)
        : undefined;
    return message;
  },
};

function createBaseQueryListEpochHeadersRequest(): QueryListEpochHeadersRequest {
  return { epochNum: 0, chainId: "" };
}

export const QueryListEpochHeadersRequest: MessageFns<QueryListEpochHeadersRequest> =
  {
    encode(
      message: QueryListEpochHeadersRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.epochNum !== 0) {
        writer.uint32(8).uint64(message.epochNum);
      }
      if (message.chainId !== "") {
        writer.uint32(18).string(message.chainId);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryListEpochHeadersRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryListEpochHeadersRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }

            message.epochNum = longToNumber(reader.uint64());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.chainId = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryListEpochHeadersRequest {
      return {
        epochNum: isSet(object.epochNum)
          ? globalThis.Number(object.epochNum)
          : 0,
        chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      };
    },

    toJSON(message: QueryListEpochHeadersRequest): unknown {
      const obj: any = {};
      if (message.epochNum !== 0) {
        obj.epochNum = Math.round(message.epochNum);
      }
      if (message.chainId !== "") {
        obj.chainId = message.chainId;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryListEpochHeadersRequest>, I>>(
      base?: I,
    ): QueryListEpochHeadersRequest {
      return QueryListEpochHeadersRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryListEpochHeadersRequest>, I>>(
      object: I,
    ): QueryListEpochHeadersRequest {
      const message = createBaseQueryListEpochHeadersRequest();
      message.epochNum = object.epochNum ?? 0;
      message.chainId = object.chainId ?? "";
      return message;
    },
  };

function createBaseQueryListEpochHeadersResponse(): QueryListEpochHeadersResponse {
  return { headers: [] };
}

export const QueryListEpochHeadersResponse: MessageFns<QueryListEpochHeadersResponse> =
  {
    encode(
      message: QueryListEpochHeadersResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.headers) {
        IndexedHeader.encode(v!, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryListEpochHeadersResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryListEpochHeadersResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.headers.push(IndexedHeader.decode(reader, reader.uint32()));
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryListEpochHeadersResponse {
      return {
        headers: globalThis.Array.isArray(object?.headers)
          ? object.headers.map((e: any) => IndexedHeader.fromJSON(e))
          : [],
      };
    },

    toJSON(message: QueryListEpochHeadersResponse): unknown {
      const obj: any = {};
      if (message.headers?.length) {
        obj.headers = message.headers.map((e) => IndexedHeader.toJSON(e));
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryListEpochHeadersResponse>, I>>(
      base?: I,
    ): QueryListEpochHeadersResponse {
      return QueryListEpochHeadersResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryListEpochHeadersResponse>, I>>(
      object: I,
    ): QueryListEpochHeadersResponse {
      const message = createBaseQueryListEpochHeadersResponse();
      message.headers =
        object.headers?.map((e) => IndexedHeader.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseQueryFinalizedChainsInfoRequest(): QueryFinalizedChainsInfoRequest {
  return { chainIds: [], prove: false };
}

export const QueryFinalizedChainsInfoRequest: MessageFns<QueryFinalizedChainsInfoRequest> =
  {
    encode(
      message: QueryFinalizedChainsInfoRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.chainIds) {
        writer.uint32(10).string(v!);
      }
      if (message.prove !== false) {
        writer.uint32(16).bool(message.prove);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryFinalizedChainsInfoRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryFinalizedChainsInfoRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.chainIds.push(reader.string());
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }

            message.prove = reader.bool();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryFinalizedChainsInfoRequest {
      return {
        chainIds: globalThis.Array.isArray(object?.chainIds)
          ? object.chainIds.map((e: any) => globalThis.String(e))
          : [],
        prove: isSet(object.prove) ? globalThis.Boolean(object.prove) : false,
      };
    },

    toJSON(message: QueryFinalizedChainsInfoRequest): unknown {
      const obj: any = {};
      if (message.chainIds?.length) {
        obj.chainIds = message.chainIds;
      }
      if (message.prove !== false) {
        obj.prove = message.prove;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryFinalizedChainsInfoRequest>, I>>(
      base?: I,
    ): QueryFinalizedChainsInfoRequest {
      return QueryFinalizedChainsInfoRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryFinalizedChainsInfoRequest>, I>,
    >(object: I): QueryFinalizedChainsInfoRequest {
      const message = createBaseQueryFinalizedChainsInfoRequest();
      message.chainIds = object.chainIds?.map((e) => e) || [];
      message.prove = object.prove ?? false;
      return message;
    },
  };

function createBaseQueryFinalizedChainsInfoResponse(): QueryFinalizedChainsInfoResponse {
  return { finalizedChainsInfo: [] };
}

export const QueryFinalizedChainsInfoResponse: MessageFns<QueryFinalizedChainsInfoResponse> =
  {
    encode(
      message: QueryFinalizedChainsInfoResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.finalizedChainsInfo) {
        FinalizedChainInfo.encode(v!, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryFinalizedChainsInfoResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryFinalizedChainsInfoResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.finalizedChainsInfo.push(
              FinalizedChainInfo.decode(reader, reader.uint32()),
            );
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryFinalizedChainsInfoResponse {
      return {
        finalizedChainsInfo: globalThis.Array.isArray(
          object?.finalizedChainsInfo,
        )
          ? object.finalizedChainsInfo.map((e: any) =>
              FinalizedChainInfo.fromJSON(e),
            )
          : [],
      };
    },

    toJSON(message: QueryFinalizedChainsInfoResponse): unknown {
      const obj: any = {};
      if (message.finalizedChainsInfo?.length) {
        obj.finalizedChainsInfo = message.finalizedChainsInfo.map((e) =>
          FinalizedChainInfo.toJSON(e),
        );
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryFinalizedChainsInfoResponse>, I>>(
      base?: I,
    ): QueryFinalizedChainsInfoResponse {
      return QueryFinalizedChainsInfoResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryFinalizedChainsInfoResponse>, I>,
    >(object: I): QueryFinalizedChainsInfoResponse {
      const message = createBaseQueryFinalizedChainsInfoResponse();
      message.finalizedChainsInfo =
        object.finalizedChainsInfo?.map((e) =>
          FinalizedChainInfo.fromPartial(e),
        ) || [];
      return message;
    },
  };

function createBaseQueryFinalizedChainInfoUntilHeightRequest(): QueryFinalizedChainInfoUntilHeightRequest {
  return { chainId: "", height: 0, prove: false };
}

export const QueryFinalizedChainInfoUntilHeightRequest: MessageFns<QueryFinalizedChainInfoUntilHeightRequest> =
  {
    encode(
      message: QueryFinalizedChainInfoUntilHeightRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.chainId !== "") {
        writer.uint32(10).string(message.chainId);
      }
      if (message.height !== 0) {
        writer.uint32(16).uint64(message.height);
      }
      if (message.prove !== false) {
        writer.uint32(24).bool(message.prove);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryFinalizedChainInfoUntilHeightRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryFinalizedChainInfoUntilHeightRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.chainId = reader.string();
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }

            message.height = longToNumber(reader.uint64());
            continue;
          case 3:
            if (tag !== 24) {
              break;
            }

            message.prove = reader.bool();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryFinalizedChainInfoUntilHeightRequest {
      return {
        chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
        height: isSet(object.height) ? globalThis.Number(object.height) : 0,
        prove: isSet(object.prove) ? globalThis.Boolean(object.prove) : false,
      };
    },

    toJSON(message: QueryFinalizedChainInfoUntilHeightRequest): unknown {
      const obj: any = {};
      if (message.chainId !== "") {
        obj.chainId = message.chainId;
      }
      if (message.height !== 0) {
        obj.height = Math.round(message.height);
      }
      if (message.prove !== false) {
        obj.prove = message.prove;
      }
      return obj;
    },

    create<
      I extends Exact<
        DeepPartial<QueryFinalizedChainInfoUntilHeightRequest>,
        I
      >,
    >(base?: I): QueryFinalizedChainInfoUntilHeightRequest {
      return QueryFinalizedChainInfoUntilHeightRequest.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<
        DeepPartial<QueryFinalizedChainInfoUntilHeightRequest>,
        I
      >,
    >(object: I): QueryFinalizedChainInfoUntilHeightRequest {
      const message = createBaseQueryFinalizedChainInfoUntilHeightRequest();
      message.chainId = object.chainId ?? "";
      message.height = object.height ?? 0;
      message.prove = object.prove ?? false;
      return message;
    },
  };

function createBaseQueryFinalizedChainInfoUntilHeightResponse(): QueryFinalizedChainInfoUntilHeightResponse {
  return {
    finalizedChainInfo: undefined,
    epochInfo: undefined,
    rawCheckpoint: undefined,
    btcSubmissionKey: undefined,
    proof: undefined,
  };
}

export const QueryFinalizedChainInfoUntilHeightResponse: MessageFns<QueryFinalizedChainInfoUntilHeightResponse> =
  {
    encode(
      message: QueryFinalizedChainInfoUntilHeightResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.finalizedChainInfo !== undefined) {
        ChainInfo.encode(
          message.finalizedChainInfo,
          writer.uint32(10).fork(),
        ).join();
      }
      if (message.epochInfo !== undefined) {
        Epoch.encode(message.epochInfo, writer.uint32(18).fork()).join();
      }
      if (message.rawCheckpoint !== undefined) {
        RawCheckpoint.encode(
          message.rawCheckpoint,
          writer.uint32(26).fork(),
        ).join();
      }
      if (message.btcSubmissionKey !== undefined) {
        SubmissionKey.encode(
          message.btcSubmissionKey,
          writer.uint32(34).fork(),
        ).join();
      }
      if (message.proof !== undefined) {
        ProofFinalizedChainInfo.encode(
          message.proof,
          writer.uint32(42).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryFinalizedChainInfoUntilHeightResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryFinalizedChainInfoUntilHeightResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.finalizedChainInfo = ChainInfo.decode(
              reader,
              reader.uint32(),
            );
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.epochInfo = Epoch.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }

            message.rawCheckpoint = RawCheckpoint.decode(
              reader,
              reader.uint32(),
            );
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }

            message.btcSubmissionKey = SubmissionKey.decode(
              reader,
              reader.uint32(),
            );
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }

            message.proof = ProofFinalizedChainInfo.decode(
              reader,
              reader.uint32(),
            );
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryFinalizedChainInfoUntilHeightResponse {
      return {
        finalizedChainInfo: isSet(object.finalizedChainInfo)
          ? ChainInfo.fromJSON(object.finalizedChainInfo)
          : undefined,
        epochInfo: isSet(object.epochInfo)
          ? Epoch.fromJSON(object.epochInfo)
          : undefined,
        rawCheckpoint: isSet(object.rawCheckpoint)
          ? RawCheckpoint.fromJSON(object.rawCheckpoint)
          : undefined,
        btcSubmissionKey: isSet(object.btcSubmissionKey)
          ? SubmissionKey.fromJSON(object.btcSubmissionKey)
          : undefined,
        proof: isSet(object.proof)
          ? ProofFinalizedChainInfo.fromJSON(object.proof)
          : undefined,
      };
    },

    toJSON(message: QueryFinalizedChainInfoUntilHeightResponse): unknown {
      const obj: any = {};
      if (message.finalizedChainInfo !== undefined) {
        obj.finalizedChainInfo = ChainInfo.toJSON(message.finalizedChainInfo);
      }
      if (message.epochInfo !== undefined) {
        obj.epochInfo = Epoch.toJSON(message.epochInfo);
      }
      if (message.rawCheckpoint !== undefined) {
        obj.rawCheckpoint = RawCheckpoint.toJSON(message.rawCheckpoint);
      }
      if (message.btcSubmissionKey !== undefined) {
        obj.btcSubmissionKey = SubmissionKey.toJSON(message.btcSubmissionKey);
      }
      if (message.proof !== undefined) {
        obj.proof = ProofFinalizedChainInfo.toJSON(message.proof);
      }
      return obj;
    },

    create<
      I extends Exact<
        DeepPartial<QueryFinalizedChainInfoUntilHeightResponse>,
        I
      >,
    >(base?: I): QueryFinalizedChainInfoUntilHeightResponse {
      return QueryFinalizedChainInfoUntilHeightResponse.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<
        DeepPartial<QueryFinalizedChainInfoUntilHeightResponse>,
        I
      >,
    >(object: I): QueryFinalizedChainInfoUntilHeightResponse {
      const message = createBaseQueryFinalizedChainInfoUntilHeightResponse();
      message.finalizedChainInfo =
        object.finalizedChainInfo !== undefined &&
        object.finalizedChainInfo !== null
          ? ChainInfo.fromPartial(object.finalizedChainInfo)
          : undefined;
      message.epochInfo =
        object.epochInfo !== undefined && object.epochInfo !== null
          ? Epoch.fromPartial(object.epochInfo)
          : undefined;
      message.rawCheckpoint =
        object.rawCheckpoint !== undefined && object.rawCheckpoint !== null
          ? RawCheckpoint.fromPartial(object.rawCheckpoint)
          : undefined;
      message.btcSubmissionKey =
        object.btcSubmissionKey !== undefined &&
        object.btcSubmissionKey !== null
          ? SubmissionKey.fromPartial(object.btcSubmissionKey)
          : undefined;
      message.proof =
        object.proof !== undefined && object.proof !== null
          ? ProofFinalizedChainInfo.fromPartial(object.proof)
          : undefined;
      return message;
    },
  };

/** Query defines the gRPC querier service. */
export interface Query {
  /** Params queries the parameters of the module. */
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
  /** Header queries the CZ header and fork headers at a given height. */
  Header(request: QueryHeaderRequest): Promise<QueryHeaderResponse>;
  /** ChainList queries the list of chains that checkpoint to Babylon */
  ChainList(request: QueryChainListRequest): Promise<QueryChainListResponse>;
  /** ChainsInfo queries the latest info for a given list of chains in Babylon's view */
  ChainsInfo(request: QueryChainsInfoRequest): Promise<QueryChainsInfoResponse>;
  /**
   * EpochChainsInfo queries the latest info for a list of chains
   * in a given epoch in Babylon's view
   */
  EpochChainsInfo(
    request: QueryEpochChainsInfoRequest,
  ): Promise<QueryEpochChainsInfoResponse>;
  /**
   * ListHeaders queries the headers of a chain in Babylon's view, with
   * pagination support
   */
  ListHeaders(
    request: QueryListHeadersRequest,
  ): Promise<QueryListHeadersResponse>;
  /**
   * ListEpochHeaders queries the headers of a chain timestamped in a given
   * epoch of Babylon, with pagination support
   */
  ListEpochHeaders(
    request: QueryListEpochHeadersRequest,
  ): Promise<QueryListEpochHeadersResponse>;
  /** FinalizedChainsInfo queries the BTC-finalised info of chains with given IDs, with proofs */
  FinalizedChainsInfo(
    request: QueryFinalizedChainsInfoRequest,
  ): Promise<QueryFinalizedChainsInfoResponse>;
  /**
   * FinalizedChainInfoUntilHeight queries the BTC-finalised info no later than
   * the provided CZ height, with proofs
   */
  FinalizedChainInfoUntilHeight(
    request: QueryFinalizedChainInfoUntilHeightRequest,
  ): Promise<QueryFinalizedChainInfoUntilHeightResponse>;
}

export const QueryServiceName = "babylon.zoneconcierge.v1.Query";
export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceName;
    this.rpc = rpc;
    this.Params = this.Params.bind(this);
    this.Header = this.Header.bind(this);
    this.ChainList = this.ChainList.bind(this);
    this.ChainsInfo = this.ChainsInfo.bind(this);
    this.EpochChainsInfo = this.EpochChainsInfo.bind(this);
    this.ListHeaders = this.ListHeaders.bind(this);
    this.ListEpochHeaders = this.ListEpochHeaders.bind(this);
    this.FinalizedChainsInfo = this.FinalizedChainsInfo.bind(this);
    this.FinalizedChainInfoUntilHeight =
      this.FinalizedChainInfoUntilHeight.bind(this);
  }
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse> {
    const data = QueryParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Params", data);
    return promise.then((data) =>
      QueryParamsResponse.decode(new BinaryReader(data)),
    );
  }

  Header(request: QueryHeaderRequest): Promise<QueryHeaderResponse> {
    const data = QueryHeaderRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Header", data);
    return promise.then((data) =>
      QueryHeaderResponse.decode(new BinaryReader(data)),
    );
  }

  ChainList(request: QueryChainListRequest): Promise<QueryChainListResponse> {
    const data = QueryChainListRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ChainList", data);
    return promise.then((data) =>
      QueryChainListResponse.decode(new BinaryReader(data)),
    );
  }

  ChainsInfo(
    request: QueryChainsInfoRequest,
  ): Promise<QueryChainsInfoResponse> {
    const data = QueryChainsInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ChainsInfo", data);
    return promise.then((data) =>
      QueryChainsInfoResponse.decode(new BinaryReader(data)),
    );
  }

  EpochChainsInfo(
    request: QueryEpochChainsInfoRequest,
  ): Promise<QueryEpochChainsInfoResponse> {
    const data = QueryEpochChainsInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EpochChainsInfo", data);
    return promise.then((data) =>
      QueryEpochChainsInfoResponse.decode(new BinaryReader(data)),
    );
  }

  ListHeaders(
    request: QueryListHeadersRequest,
  ): Promise<QueryListHeadersResponse> {
    const data = QueryListHeadersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListHeaders", data);
    return promise.then((data) =>
      QueryListHeadersResponse.decode(new BinaryReader(data)),
    );
  }

  ListEpochHeaders(
    request: QueryListEpochHeadersRequest,
  ): Promise<QueryListEpochHeadersResponse> {
    const data = QueryListEpochHeadersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListEpochHeaders", data);
    return promise.then((data) =>
      QueryListEpochHeadersResponse.decode(new BinaryReader(data)),
    );
  }

  FinalizedChainsInfo(
    request: QueryFinalizedChainsInfoRequest,
  ): Promise<QueryFinalizedChainsInfoResponse> {
    const data = QueryFinalizedChainsInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FinalizedChainsInfo", data);
    return promise.then((data) =>
      QueryFinalizedChainsInfoResponse.decode(new BinaryReader(data)),
    );
  }

  FinalizedChainInfoUntilHeight(
    request: QueryFinalizedChainInfoUntilHeightRequest,
  ): Promise<QueryFinalizedChainInfoUntilHeightResponse> {
    const data =
      QueryFinalizedChainInfoUntilHeightRequest.encode(request).finish();
    const promise = this.rpc.request(
      this.service,
      "FinalizedChainInfoUntilHeight",
      data,
    );
    return promise.then((data) =>
      QueryFinalizedChainInfoUntilHeightResponse.decode(new BinaryReader(data)),
    );
  }
}

interface Rpc {
  request(
    service: string,
    method: string,
    data: Uint8Array,
  ): Promise<Uint8Array>;
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
