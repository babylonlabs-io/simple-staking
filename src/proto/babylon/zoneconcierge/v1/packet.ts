// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: babylon/zoneconcierge/v1/packet.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { SubmissionKey } from "../../btccheckpoint/v1/btccheckpoint";
import { BTCHeaderInfo } from "../../btclightclient/v1/btclightclient";
import { RawCheckpoint } from "../../checkpointing/v1/checkpoint";
import { Epoch } from "../../epoching/v1/epoching";
import { IndexedHeader, ProofFinalizedChainInfo } from "./zoneconcierge";

export const protobufPackage = "babylon.zoneconcierge.v1";

/**
 * ZoneconciergePacketData is the message that defines the IBC packets of
 * ZoneConcierge
 */
export interface ZoneconciergePacketData {
  btcTimestamp?: BTCTimestamp | undefined;
}

/**
 * BTCTimestamp is a BTC timestamp that carries information of a BTC-finalised epoch
 * It includes a number of BTC headers, a raw checkpoint, an epoch metadata, and
 * a CZ header if there exists CZ headers checkpointed to this epoch.
 * Upon a newly finalised epoch in Babylon, Babylon will send a BTC timestamp to each
 * Cosmos zone that has phase-2 integration with Babylon via IBC.
 */
export interface BTCTimestamp {
  /** header is the last CZ header in the finalized Babylon epoch */
  header: IndexedHeader | undefined;
  /**
   * btc_headers is BTC headers between
   * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
   * - BTC tip at epoch `lastFinalizedEpoch`
   * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
   */
  btcHeaders: BTCHeaderInfo[];
  /** epoch_info is the metadata of the sealed epoch */
  epochInfo: Epoch | undefined;
  /** raw_checkpoint is the raw checkpoint that seals this epoch */
  rawCheckpoint: RawCheckpoint | undefined;
  /** btc_submission_key is position of two BTC txs that include the raw checkpoint of this epoch */
  btcSubmissionKey: SubmissionKey | undefined;
  /** Proofs that the header is finalized */
  proof: ProofFinalizedChainInfo | undefined;
}

function createBaseZoneconciergePacketData(): ZoneconciergePacketData {
  return { btcTimestamp: undefined };
}

export const ZoneconciergePacketData: MessageFns<ZoneconciergePacketData> = {
  encode(
    message: ZoneconciergePacketData,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.btcTimestamp !== undefined) {
      BTCTimestamp.encode(
        message.btcTimestamp,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ZoneconciergePacketData {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZoneconciergePacketData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.btcTimestamp = BTCTimestamp.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ZoneconciergePacketData {
    return {
      btcTimestamp: isSet(object.btcTimestamp)
        ? BTCTimestamp.fromJSON(object.btcTimestamp)
        : undefined,
    };
  },

  toJSON(message: ZoneconciergePacketData): unknown {
    const obj: any = {};
    if (message.btcTimestamp !== undefined) {
      obj.btcTimestamp = BTCTimestamp.toJSON(message.btcTimestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ZoneconciergePacketData>, I>>(
    base?: I,
  ): ZoneconciergePacketData {
    return ZoneconciergePacketData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ZoneconciergePacketData>, I>>(
    object: I,
  ): ZoneconciergePacketData {
    const message = createBaseZoneconciergePacketData();
    message.btcTimestamp =
      object.btcTimestamp !== undefined && object.btcTimestamp !== null
        ? BTCTimestamp.fromPartial(object.btcTimestamp)
        : undefined;
    return message;
  },
};

function createBaseBTCTimestamp(): BTCTimestamp {
  return {
    header: undefined,
    btcHeaders: [],
    epochInfo: undefined,
    rawCheckpoint: undefined,
    btcSubmissionKey: undefined,
    proof: undefined,
  };
}

export const BTCTimestamp: MessageFns<BTCTimestamp> = {
  encode(
    message: BTCTimestamp,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.header !== undefined) {
      IndexedHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    for (const v of message.btcHeaders) {
      BTCHeaderInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.epochInfo !== undefined) {
      Epoch.encode(message.epochInfo, writer.uint32(26).fork()).join();
    }
    if (message.rawCheckpoint !== undefined) {
      RawCheckpoint.encode(
        message.rawCheckpoint,
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.btcSubmissionKey !== undefined) {
      SubmissionKey.encode(
        message.btcSubmissionKey,
        writer.uint32(42).fork(),
      ).join();
    }
    if (message.proof !== undefined) {
      ProofFinalizedChainInfo.encode(
        message.proof,
        writer.uint32(50).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BTCTimestamp {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = IndexedHeader.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.btcHeaders.push(
            BTCHeaderInfo.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.epochInfo = Epoch.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rawCheckpoint = RawCheckpoint.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.btcSubmissionKey = SubmissionKey.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.proof = ProofFinalizedChainInfo.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCTimestamp {
    return {
      header: isSet(object.header)
        ? IndexedHeader.fromJSON(object.header)
        : undefined,
      btcHeaders: globalThis.Array.isArray(object?.btcHeaders)
        ? object.btcHeaders.map((e: any) => BTCHeaderInfo.fromJSON(e))
        : [],
      epochInfo: isSet(object.epochInfo)
        ? Epoch.fromJSON(object.epochInfo)
        : undefined,
      rawCheckpoint: isSet(object.rawCheckpoint)
        ? RawCheckpoint.fromJSON(object.rawCheckpoint)
        : undefined,
      btcSubmissionKey: isSet(object.btcSubmissionKey)
        ? SubmissionKey.fromJSON(object.btcSubmissionKey)
        : undefined,
      proof: isSet(object.proof)
        ? ProofFinalizedChainInfo.fromJSON(object.proof)
        : undefined,
    };
  },

  toJSON(message: BTCTimestamp): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = IndexedHeader.toJSON(message.header);
    }
    if (message.btcHeaders?.length) {
      obj.btcHeaders = message.btcHeaders.map((e) => BTCHeaderInfo.toJSON(e));
    }
    if (message.epochInfo !== undefined) {
      obj.epochInfo = Epoch.toJSON(message.epochInfo);
    }
    if (message.rawCheckpoint !== undefined) {
      obj.rawCheckpoint = RawCheckpoint.toJSON(message.rawCheckpoint);
    }
    if (message.btcSubmissionKey !== undefined) {
      obj.btcSubmissionKey = SubmissionKey.toJSON(message.btcSubmissionKey);
    }
    if (message.proof !== undefined) {
      obj.proof = ProofFinalizedChainInfo.toJSON(message.proof);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BTCTimestamp>, I>>(
    base?: I,
  ): BTCTimestamp {
    return BTCTimestamp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BTCTimestamp>, I>>(
    object: I,
  ): BTCTimestamp {
    const message = createBaseBTCTimestamp();
    message.header =
      object.header !== undefined && object.header !== null
        ? IndexedHeader.fromPartial(object.header)
        : undefined;
    message.btcHeaders =
      object.btcHeaders?.map((e) => BTCHeaderInfo.fromPartial(e)) || [];
    message.epochInfo =
      object.epochInfo !== undefined && object.epochInfo !== null
        ? Epoch.fromPartial(object.epochInfo)
        : undefined;
    message.rawCheckpoint =
      object.rawCheckpoint !== undefined && object.rawCheckpoint !== null
        ? RawCheckpoint.fromPartial(object.rawCheckpoint)
        : undefined;
    message.btcSubmissionKey =
      object.btcSubmissionKey !== undefined && object.btcSubmissionKey !== null
        ? SubmissionKey.fromPartial(object.btcSubmissionKey)
        : undefined;
    message.proof =
      object.proof !== undefined && object.proof !== null
        ? ProofFinalizedChainInfo.fromPartial(object.proof)
        : undefined;
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
