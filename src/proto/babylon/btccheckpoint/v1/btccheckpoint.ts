// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: babylon/btccheckpoint/v1/btccheckpoint.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "babylon.btccheckpoint.v1";

/** BtcStatus is an enum describing the current btc status of the checkpoint */
export enum BtcStatus {
  /**
   * EPOCH_STATUS_SUBMITTED - SUBMITTED Epoch has Submitted btc status if there ever was at least one
   * known submission on btc main chain
   */
  EPOCH_STATUS_SUBMITTED = 0,
  /**
   * EPOCH_STATUS_CONFIRMED - CONFIRMED Epoch has Confirmed btc status if there ever was at least one
   * known submission on btc main chain which was k-deep
   */
  EPOCH_STATUS_CONFIRMED = 1,
  /**
   * EPOCH_STATUS_FINALIZED - CONFIRMED Epoch has Finalized btc status if there is was at exactly one
   * knon submission on btc main chain which is w-deep
   */
  EPOCH_STATUS_FINALIZED = 2,
  UNRECOGNIZED = -1,
}

export function btcStatusFromJSON(object: any): BtcStatus {
  switch (object) {
    case 0:
    case "EPOCH_STATUS_SUBMITTED":
      return BtcStatus.EPOCH_STATUS_SUBMITTED;
    case 1:
    case "EPOCH_STATUS_CONFIRMED":
      return BtcStatus.EPOCH_STATUS_CONFIRMED;
    case 2:
    case "EPOCH_STATUS_FINALIZED":
      return BtcStatus.EPOCH_STATUS_FINALIZED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BtcStatus.UNRECOGNIZED;
  }
}

export function btcStatusToJSON(object: BtcStatus): string {
  switch (object) {
    case BtcStatus.EPOCH_STATUS_SUBMITTED:
      return "EPOCH_STATUS_SUBMITTED";
    case BtcStatus.EPOCH_STATUS_CONFIRMED:
      return "EPOCH_STATUS_CONFIRMED";
    case BtcStatus.EPOCH_STATUS_FINALIZED:
      return "EPOCH_STATUS_FINALIZED";
    case BtcStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Consider we have a Merkle tree with following structure:
 *            ROOT
 *           /    \
 *      H1234      H5555
 *     /     \       \
 *   H12     H34      H55
 *  /  \    /  \     /
 * H1  H2  H3  H4  H5
 * L1  L2  L3  L4  L5
 * To prove L3 was part of ROOT we need:
 * - btc_transaction_index = 2 which in binary is 010
 * (where 0 means going left, 1 means going right in the tree)
 * - merkle_nodes we'd have H4 || H12 || H5555
 * By looking at 010 we would know that H4 is a right sibling,
 * H12 is left, H5555 is right again.
 */
export interface BTCSpvProof {
  /** Valid bitcoin transaction containing OP_RETURN opcode. */
  btcTransaction: Uint8Array;
  /**
   * Index of transaction within the block. Index is needed to determine if
   * currently hashed node is left or right.
   */
  btcTransactionIndex: number;
  /**
   * List of concatenated intermediate merkle tree nodes, without root node and
   * leaf node against which we calculate the proof. Each node has 32 byte
   * length. Example proof can look like: 32_bytes_of_node1 || 32_bytes_of_node2
   * ||  32_bytes_of_node3 so the length of the proof will always be divisible
   * by 32.
   */
  merkleNodes: Uint8Array;
  /**
   * Valid btc header which confirms btc_transaction.
   * Should have exactly 80 bytes
   */
  confirmingBtcHeader: Uint8Array;
}

/**
 * Each provided OP_RETURN transaction can be identified by hash of block in
 * which transaction was included and transaction index in the block
 */
export interface TransactionKey {
  index: number;
  hash: Uint8Array;
}

/**
 * Checkpoint can be composed from multiple transactions, so to identify whole
 * submission we need list of transaction keys.
 * Each submission can generally be identified by this list of (txIdx,
 * blockHash) tuples. Note: this could possibly be optimized as if transactions
 * were in one block they would have the same block hash and different indexes,
 * but each blockhash is only 33 (1  byte for prefix encoding and 32 byte hash),
 * so there should be other strong arguments for this optimization
 */
export interface SubmissionKey {
  key: TransactionKey[];
}

/**
 * TransactionInfo is the info of a tx on Bitcoin,
 * including
 * - the position of the tx on BTC blockchain
 * - the full tx content
 * - the Merkle proof that this tx is on the above position
 */
export interface TransactionInfo {
  /**
   * key is the position (txIdx, blockHash) of this tx on BTC blockchain
   * Although it is already a part of SubmissionKey, we store it here again
   * to make TransactionInfo self-contained.
   * For example, storing the key allows TransactionInfo to not relay on
   * the fact that TransactionInfo will be ordered in the same order as
   * TransactionKeys in SubmissionKey.
   */
  key: TransactionKey | undefined;
  /** transaction is the full transaction in bytes */
  transaction: Uint8Array;
  /**
   * proof is the Merkle proof that this tx is included in the position in `key`
   * TODO: maybe it could use here better format as we already processed and
   * validated the proof?
   */
  proof: Uint8Array;
}

/**
 * TODO: Determine if we should keep any block number or depth info.
 * On one hand it may be useful to determine if block is stable or not, on
 * other depth/block number info, without context (i.e info about chain) is
 * pretty useless and blockhash in enough to retrieve is from lightclient
 */
export interface SubmissionData {
  /** address of the submitter and reporter */
  vigilanteAddresses: CheckpointAddresses | undefined;
  /**
   * txs_info is the two `TransactionInfo`s corresponding to the submission
   * It is used for
   * - recovering address of sender of btc transaction to payup the reward.
   * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
   * BTC
   */
  txsInfo: TransactionInfo[];
  epoch: number;
}

/**
 * Data stored in db and indexed by epoch number
 * TODO: Add btc blockheight at epoch end, when adding handling of epoching
 * callbacks
 */
export interface EpochData {
  /**
   * keys is the list of all received checkpoints during this epoch, sorted by
   * order of submission.
   */
  keys: SubmissionKey[];
  /** status is the current btc status of the epoch */
  status: BtcStatus;
}

/**
 * CheckpointAddresses contains the addresses of the submitter and reporter of a
 * given checkpoint
 */
export interface CheckpointAddresses {
  /**
   * TODO: this could probably be better typed
   * submitter is the address of the checkpoint submitter to BTC, extracted from
   * the checkpoint itself.
   */
  submitter: Uint8Array;
  /**
   * reporter is the address of the reporter who reported the submissions,
   * calculated from submission message MsgInsertBTCSpvProof itself
   */
  reporter: Uint8Array;
}

/**
 * BTCCheckpointInfo contains all data about best submission of checkpoint for
 * given epoch. Best submission is the submission which is deeper in btc ledger
 */
export interface BTCCheckpointInfo {
  /** epoch number of this checkpoint */
  epochNumber: number;
  /** btc height of the best submission of the epoch */
  bestSubmissionBtcBlockHeight: number;
  /**
   * hash of the btc block which determines checkpoint btc block height i.e.
   * youngest block of best submission
   */
  bestSubmissionBtcBlockHash: Uint8Array;
  /** the BTC checkpoint transactions of the best submission */
  bestSubmissionTransactions: TransactionInfo[];
  /** list of vigilantes' addresses of the best submission */
  bestSubmissionVigilanteAddressList: CheckpointAddresses[];
}

function createBaseBTCSpvProof(): BTCSpvProof {
  return {
    btcTransaction: new Uint8Array(0),
    btcTransactionIndex: 0,
    merkleNodes: new Uint8Array(0),
    confirmingBtcHeader: new Uint8Array(0),
  };
}

export const BTCSpvProof: MessageFns<BTCSpvProof> = {
  encode(
    message: BTCSpvProof,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.btcTransaction.length !== 0) {
      writer.uint32(10).bytes(message.btcTransaction);
    }
    if (message.btcTransactionIndex !== 0) {
      writer.uint32(16).uint32(message.btcTransactionIndex);
    }
    if (message.merkleNodes.length !== 0) {
      writer.uint32(26).bytes(message.merkleNodes);
    }
    if (message.confirmingBtcHeader.length !== 0) {
      writer.uint32(34).bytes(message.confirmingBtcHeader);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BTCSpvProof {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCSpvProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.btcTransaction = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.btcTransactionIndex = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.merkleNodes = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.confirmingBtcHeader = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCSpvProof {
    return {
      btcTransaction: isSet(object.btcTransaction)
        ? bytesFromBase64(object.btcTransaction)
        : new Uint8Array(0),
      btcTransactionIndex: isSet(object.btcTransactionIndex)
        ? globalThis.Number(object.btcTransactionIndex)
        : 0,
      merkleNodes: isSet(object.merkleNodes)
        ? bytesFromBase64(object.merkleNodes)
        : new Uint8Array(0),
      confirmingBtcHeader: isSet(object.confirmingBtcHeader)
        ? bytesFromBase64(object.confirmingBtcHeader)
        : new Uint8Array(0),
    };
  },

  toJSON(message: BTCSpvProof): unknown {
    const obj: any = {};
    if (message.btcTransaction.length !== 0) {
      obj.btcTransaction = base64FromBytes(message.btcTransaction);
    }
    if (message.btcTransactionIndex !== 0) {
      obj.btcTransactionIndex = Math.round(message.btcTransactionIndex);
    }
    if (message.merkleNodes.length !== 0) {
      obj.merkleNodes = base64FromBytes(message.merkleNodes);
    }
    if (message.confirmingBtcHeader.length !== 0) {
      obj.confirmingBtcHeader = base64FromBytes(message.confirmingBtcHeader);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BTCSpvProof>, I>>(base?: I): BTCSpvProof {
    return BTCSpvProof.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BTCSpvProof>, I>>(
    object: I,
  ): BTCSpvProof {
    const message = createBaseBTCSpvProof();
    message.btcTransaction = object.btcTransaction ?? new Uint8Array(0);
    message.btcTransactionIndex = object.btcTransactionIndex ?? 0;
    message.merkleNodes = object.merkleNodes ?? new Uint8Array(0);
    message.confirmingBtcHeader =
      object.confirmingBtcHeader ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTransactionKey(): TransactionKey {
  return { index: 0, hash: new Uint8Array(0) };
}

export const TransactionKey: MessageFns<TransactionKey> = {
  encode(
    message: TransactionKey,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).uint32(message.index);
    }
    if (message.hash.length !== 0) {
      writer.uint32(18).bytes(message.hash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionKey {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hash = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionKey {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      hash: isSet(object.hash)
        ? bytesFromBase64(object.hash)
        : new Uint8Array(0),
    };
  },

  toJSON(message: TransactionKey): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionKey>, I>>(
    base?: I,
  ): TransactionKey {
    return TransactionKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionKey>, I>>(
    object: I,
  ): TransactionKey {
    const message = createBaseTransactionKey();
    message.index = object.index ?? 0;
    message.hash = object.hash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubmissionKey(): SubmissionKey {
  return { key: [] };
}

export const SubmissionKey: MessageFns<SubmissionKey> = {
  encode(
    message: SubmissionKey,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.key) {
      TransactionKey.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmissionKey {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmissionKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key.push(TransactionKey.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmissionKey {
    return {
      key: globalThis.Array.isArray(object?.key)
        ? object.key.map((e: any) => TransactionKey.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SubmissionKey): unknown {
    const obj: any = {};
    if (message.key?.length) {
      obj.key = message.key.map((e) => TransactionKey.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmissionKey>, I>>(
    base?: I,
  ): SubmissionKey {
    return SubmissionKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmissionKey>, I>>(
    object: I,
  ): SubmissionKey {
    const message = createBaseSubmissionKey();
    message.key = object.key?.map((e) => TransactionKey.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransactionInfo(): TransactionInfo {
  return {
    key: undefined,
    transaction: new Uint8Array(0),
    proof: new Uint8Array(0),
  };
}

export const TransactionInfo: MessageFns<TransactionInfo> = {
  encode(
    message: TransactionInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== undefined) {
      TransactionKey.encode(message.key, writer.uint32(10).fork()).join();
    }
    if (message.transaction.length !== 0) {
      writer.uint32(18).bytes(message.transaction);
    }
    if (message.proof.length !== 0) {
      writer.uint32(26).bytes(message.proof);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionInfo {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = TransactionKey.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transaction = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.proof = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionInfo {
    return {
      key: isSet(object.key) ? TransactionKey.fromJSON(object.key) : undefined,
      transaction: isSet(object.transaction)
        ? bytesFromBase64(object.transaction)
        : new Uint8Array(0),
      proof: isSet(object.proof)
        ? bytesFromBase64(object.proof)
        : new Uint8Array(0),
    };
  },

  toJSON(message: TransactionInfo): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = TransactionKey.toJSON(message.key);
    }
    if (message.transaction.length !== 0) {
      obj.transaction = base64FromBytes(message.transaction);
    }
    if (message.proof.length !== 0) {
      obj.proof = base64FromBytes(message.proof);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionInfo>, I>>(
    base?: I,
  ): TransactionInfo {
    return TransactionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionInfo>, I>>(
    object: I,
  ): TransactionInfo {
    const message = createBaseTransactionInfo();
    message.key =
      object.key !== undefined && object.key !== null
        ? TransactionKey.fromPartial(object.key)
        : undefined;
    message.transaction = object.transaction ?? new Uint8Array(0);
    message.proof = object.proof ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubmissionData(): SubmissionData {
  return { vigilanteAddresses: undefined, txsInfo: [], epoch: 0 };
}

export const SubmissionData: MessageFns<SubmissionData> = {
  encode(
    message: SubmissionData,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.vigilanteAddresses !== undefined) {
      CheckpointAddresses.encode(
        message.vigilanteAddresses,
        writer.uint32(10).fork(),
      ).join();
    }
    for (const v of message.txsInfo) {
      TransactionInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.epoch !== 0) {
      writer.uint32(24).uint64(message.epoch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmissionData {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmissionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vigilanteAddresses = CheckpointAddresses.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.txsInfo.push(TransactionInfo.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.epoch = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmissionData {
    return {
      vigilanteAddresses: isSet(object.vigilanteAddresses)
        ? CheckpointAddresses.fromJSON(object.vigilanteAddresses)
        : undefined,
      txsInfo: globalThis.Array.isArray(object?.txsInfo)
        ? object.txsInfo.map((e: any) => TransactionInfo.fromJSON(e))
        : [],
      epoch: isSet(object.epoch) ? globalThis.Number(object.epoch) : 0,
    };
  },

  toJSON(message: SubmissionData): unknown {
    const obj: any = {};
    if (message.vigilanteAddresses !== undefined) {
      obj.vigilanteAddresses = CheckpointAddresses.toJSON(
        message.vigilanteAddresses,
      );
    }
    if (message.txsInfo?.length) {
      obj.txsInfo = message.txsInfo.map((e) => TransactionInfo.toJSON(e));
    }
    if (message.epoch !== 0) {
      obj.epoch = Math.round(message.epoch);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmissionData>, I>>(
    base?: I,
  ): SubmissionData {
    return SubmissionData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmissionData>, I>>(
    object: I,
  ): SubmissionData {
    const message = createBaseSubmissionData();
    message.vigilanteAddresses =
      object.vigilanteAddresses !== undefined &&
      object.vigilanteAddresses !== null
        ? CheckpointAddresses.fromPartial(object.vigilanteAddresses)
        : undefined;
    message.txsInfo =
      object.txsInfo?.map((e) => TransactionInfo.fromPartial(e)) || [];
    message.epoch = object.epoch ?? 0;
    return message;
  },
};

function createBaseEpochData(): EpochData {
  return { keys: [], status: 0 };
}

export const EpochData: MessageFns<EpochData> = {
  encode(
    message: EpochData,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.keys) {
      SubmissionKey.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EpochData {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEpochData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keys.push(SubmissionKey.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EpochData {
    return {
      keys: globalThis.Array.isArray(object?.keys)
        ? object.keys.map((e: any) => SubmissionKey.fromJSON(e))
        : [],
      status: isSet(object.status) ? btcStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: EpochData): unknown {
    const obj: any = {};
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => SubmissionKey.toJSON(e));
    }
    if (message.status !== 0) {
      obj.status = btcStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EpochData>, I>>(base?: I): EpochData {
    return EpochData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EpochData>, I>>(
    object: I,
  ): EpochData {
    const message = createBaseEpochData();
    message.keys = object.keys?.map((e) => SubmissionKey.fromPartial(e)) || [];
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseCheckpointAddresses(): CheckpointAddresses {
  return { submitter: new Uint8Array(0), reporter: new Uint8Array(0) };
}

export const CheckpointAddresses: MessageFns<CheckpointAddresses> = {
  encode(
    message: CheckpointAddresses,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.submitter.length !== 0) {
      writer.uint32(10).bytes(message.submitter);
    }
    if (message.reporter.length !== 0) {
      writer.uint32(18).bytes(message.reporter);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CheckpointAddresses {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckpointAddresses();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.submitter = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reporter = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckpointAddresses {
    return {
      submitter: isSet(object.submitter)
        ? bytesFromBase64(object.submitter)
        : new Uint8Array(0),
      reporter: isSet(object.reporter)
        ? bytesFromBase64(object.reporter)
        : new Uint8Array(0),
    };
  },

  toJSON(message: CheckpointAddresses): unknown {
    const obj: any = {};
    if (message.submitter.length !== 0) {
      obj.submitter = base64FromBytes(message.submitter);
    }
    if (message.reporter.length !== 0) {
      obj.reporter = base64FromBytes(message.reporter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckpointAddresses>, I>>(
    base?: I,
  ): CheckpointAddresses {
    return CheckpointAddresses.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckpointAddresses>, I>>(
    object: I,
  ): CheckpointAddresses {
    const message = createBaseCheckpointAddresses();
    message.submitter = object.submitter ?? new Uint8Array(0);
    message.reporter = object.reporter ?? new Uint8Array(0);
    return message;
  },
};

function createBaseBTCCheckpointInfo(): BTCCheckpointInfo {
  return {
    epochNumber: 0,
    bestSubmissionBtcBlockHeight: 0,
    bestSubmissionBtcBlockHash: new Uint8Array(0),
    bestSubmissionTransactions: [],
    bestSubmissionVigilanteAddressList: [],
  };
}

export const BTCCheckpointInfo: MessageFns<BTCCheckpointInfo> = {
  encode(
    message: BTCCheckpointInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.epochNumber !== 0) {
      writer.uint32(8).uint64(message.epochNumber);
    }
    if (message.bestSubmissionBtcBlockHeight !== 0) {
      writer.uint32(16).uint32(message.bestSubmissionBtcBlockHeight);
    }
    if (message.bestSubmissionBtcBlockHash.length !== 0) {
      writer.uint32(26).bytes(message.bestSubmissionBtcBlockHash);
    }
    for (const v of message.bestSubmissionTransactions) {
      TransactionInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.bestSubmissionVigilanteAddressList) {
      CheckpointAddresses.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BTCCheckpointInfo {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCCheckpointInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.epochNumber = longToNumber(reader.uint64());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.bestSubmissionBtcBlockHeight = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bestSubmissionBtcBlockHash = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.bestSubmissionTransactions.push(
            TransactionInfo.decode(reader, reader.uint32()),
          );
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.bestSubmissionVigilanteAddressList.push(
            CheckpointAddresses.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCCheckpointInfo {
    return {
      epochNumber: isSet(object.epochNumber)
        ? globalThis.Number(object.epochNumber)
        : 0,
      bestSubmissionBtcBlockHeight: isSet(object.bestSubmissionBtcBlockHeight)
        ? globalThis.Number(object.bestSubmissionBtcBlockHeight)
        : 0,
      bestSubmissionBtcBlockHash: isSet(object.bestSubmissionBtcBlockHash)
        ? bytesFromBase64(object.bestSubmissionBtcBlockHash)
        : new Uint8Array(0),
      bestSubmissionTransactions: globalThis.Array.isArray(
        object?.bestSubmissionTransactions,
      )
        ? object.bestSubmissionTransactions.map((e: any) =>
            TransactionInfo.fromJSON(e),
          )
        : [],
      bestSubmissionVigilanteAddressList: globalThis.Array.isArray(
        object?.bestSubmissionVigilanteAddressList,
      )
        ? object.bestSubmissionVigilanteAddressList.map((e: any) =>
            CheckpointAddresses.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: BTCCheckpointInfo): unknown {
    const obj: any = {};
    if (message.epochNumber !== 0) {
      obj.epochNumber = Math.round(message.epochNumber);
    }
    if (message.bestSubmissionBtcBlockHeight !== 0) {
      obj.bestSubmissionBtcBlockHeight = Math.round(
        message.bestSubmissionBtcBlockHeight,
      );
    }
    if (message.bestSubmissionBtcBlockHash.length !== 0) {
      obj.bestSubmissionBtcBlockHash = base64FromBytes(
        message.bestSubmissionBtcBlockHash,
      );
    }
    if (message.bestSubmissionTransactions?.length) {
      obj.bestSubmissionTransactions = message.bestSubmissionTransactions.map(
        (e) => TransactionInfo.toJSON(e),
      );
    }
    if (message.bestSubmissionVigilanteAddressList?.length) {
      obj.bestSubmissionVigilanteAddressList =
        message.bestSubmissionVigilanteAddressList.map((e) =>
          CheckpointAddresses.toJSON(e),
        );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BTCCheckpointInfo>, I>>(
    base?: I,
  ): BTCCheckpointInfo {
    return BTCCheckpointInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BTCCheckpointInfo>, I>>(
    object: I,
  ): BTCCheckpointInfo {
    const message = createBaseBTCCheckpointInfo();
    message.epochNumber = object.epochNumber ?? 0;
    message.bestSubmissionBtcBlockHeight =
      object.bestSubmissionBtcBlockHeight ?? 0;
    message.bestSubmissionBtcBlockHash =
      object.bestSubmissionBtcBlockHash ?? new Uint8Array(0);
    message.bestSubmissionTransactions =
      object.bestSubmissionTransactions?.map((e) =>
        TransactionInfo.fromPartial(e),
      ) || [];
    message.bestSubmissionVigilanteAddressList =
      object.bestSubmissionVigilanteAddressList?.map((e) =>
        CheckpointAddresses.fromPartial(e),
      ) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
