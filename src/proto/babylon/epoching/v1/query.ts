// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: babylon/epoching/v1/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  PageRequest,
  PageResponse,
} from "../../../cosmos/base/query/v1beta1/pagination";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { DelegationLifecycle, Validator } from "./epoching";
import { Params } from "./params";

export const protobufPackage = "babylon.epoching.v1";

/** QueryParamsRequest is the request type for the Query/Params RPC method. */
export interface QueryParamsRequest {}

/** QueryParamsResponse is the response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
  /** params holds all the parameters of this module. */
  params: Params | undefined;
}

/** QueryEpochInfoRequest is the request type for the Query/EpochInfo method */
export interface QueryEpochInfoRequest {
  epochNum: number;
}

/** QueryEpochInfoRequest is the response type for the Query/EpochInfo method */
export interface QueryEpochInfoResponse {
  epoch: EpochResponse | undefined;
}

/** QueryEpochInfosRequest is the request type for the Query/EpochInfos method */
export interface QueryEpochsInfoRequest {
  /** pagination defines whether to have the pagination in the request */
  pagination: PageRequest | undefined;
}

/** QueryEpochsInfoResponse is the response type for the Query/EpochInfos method */
export interface QueryEpochsInfoResponse {
  epochs: EpochResponse[];
  /** pagination defines the pagination in the response */
  pagination: PageResponse | undefined;
}

/**
 * QueryCurrentEpochRequest is the request type for the Query/CurrentEpoch RPC
 * method
 */
export interface QueryCurrentEpochRequest {}

/**
 * QueryCurrentEpochResponse is the response type for the Query/CurrentEpoch RPC
 * method
 */
export interface QueryCurrentEpochResponse {
  /** current_epoch is the current epoch number */
  currentEpoch: number;
  /** epoch_boundary is the height of this epoch's last block */
  epochBoundary: number;
}

/** QueryEpochMsgsRequest is the request type for the Query/EpochMsgs RPC method */
export interface QueryEpochMsgsRequest {
  /** epoch_num is the number of epoch of the requested msg queue */
  epochNum: number;
  /** pagination defines whether to have the pagination in the request */
  pagination: PageRequest | undefined;
}

/**
 * QueryEpochMsgsResponse is the response type for the Query/EpochMsgs RPC
 * method
 */
export interface QueryEpochMsgsResponse {
  /** msgs is the list of messages queued in the current epoch */
  msgs: QueuedMessageResponse[];
  /** pagination defines the pagination in the response */
  pagination: PageResponse | undefined;
}

/**
 * QueryLatestEpochMsgsRequest is the request type for the Query/LatestEpochMsgs
 * RPC method it returns epoch msgs within epoch [max(1,
 * end_epoch-epoch_count+1), end_epoch]
 */
export interface QueryLatestEpochMsgsRequest {
  /** end_epoch is the number of the last epoch to query */
  endEpoch: number;
  /** epoch_count is the number of epochs to query */
  epochCount: number;
  pagination: PageRequest | undefined;
}

/**
 * QueryLatestEpochMsgsResponse is the response type for the
 * Query/LatestEpochMsgs RPC method
 */
export interface QueryLatestEpochMsgsResponse {
  /**
   * latest_epoch_msgs is a list of QueuedMessageList
   * each QueuedMessageList has a field identifying the epoch number
   */
  latestEpochMsgs: QueuedMessageList[];
  pagination: PageResponse | undefined;
}

/**
 * QueryValidatorLifecycleRequest is the request type for the
 * Query/ValidatorLifecycle RPC method
 */
export interface QueryValidatorLifecycleRequest {
  valAddr: string;
}

/**
 * QueryValidatorLifecycleResponse is the response type for the
 * Query/ValidatorLifecycle RPC method
 */
export interface QueryValidatorLifecycleResponse {
  valAddr: string;
  valLife: ValStateUpdateResponse[];
}

/**
 * QueryDelegationLifecycleRequest is the request type for the
 * Query/DelegationLifecycle RPC method
 */
export interface QueryDelegationLifecycleRequest {
  delAddr: string;
}

/**
 * QueryDelegationLifecycleRequest is the response type for the
 * Query/DelegationLifecycle RPC method
 */
export interface QueryDelegationLifecycleResponse {
  delLife: DelegationLifecycle | undefined;
}

/**
 * QueryEpochValSetRequest is the request type for the Query/EpochValSet RPC
 * method
 */
export interface QueryEpochValSetRequest {
  epochNum: number;
  pagination: PageRequest | undefined;
}

/**
 * QueryEpochValSetRequest is the response type for the Query/EpochValSet RPC
 * method
 */
export interface QueryEpochValSetResponse {
  validators: Validator[];
  totalVotingPower: number;
  pagination: PageResponse | undefined;
}

/** EpochResponse is a structure that contains the metadata of an epoch */
export interface EpochResponse {
  /** epoch_number is the number of this epoch */
  epochNumber: number;
  /** current_epoch_interval is the epoch interval at the time of this epoch */
  currentEpochInterval: number;
  /** first_block_height is the height of the first block in this epoch */
  firstBlockHeight: number;
  /**
   * last_block_time is the time of the last block in this epoch.
   * Babylon needs to remember the last header's time of each epoch to complete
   * unbonding validators/delegations when a previous epoch's checkpoint is
   * finalised. The last_block_time field is nil in the epoch's beginning, and
   * is set upon the end of this epoch.
   */
  lastBlockTime: Date | undefined;
  /**
   * sealer is the last block of the sealed epoch
   * sealer_app_hash points to the sealer but stored in the 1st header
   * of the next epoch as hex string.
   */
  sealerAppHashHex: string;
  /**
   * sealer_block_hash is the hash of the sealer
   * the validator set has generated a BLS multisig on the hash,
   * i.e., hash of the last block in the epoch as hex string.
   */
  sealerBlockHash: string;
}

/**
 * QueuedMessageResponse is a message that can change the validator set and is delayed
 * to the end of an epoch
 */
export interface QueuedMessageResponse {
  /** tx_id is the ID of the tx that contains the message as hex. */
  txId: string;
  /** msg_id is the original message ID, i.e., hash of the marshaled message as hex. */
  msgId: string;
  /** block_height is the height when this msg is submitted to Babylon */
  blockHeight: number;
  /** block_time is the timestamp when this msg is submitted to Babylon */
  blockTime: Date | undefined;
  /**
   * msg is the actual message that is sent by a user and is queued by the
   * epoching module as string.
   */
  msg: string;
}

/**
 * QueuedMessageList is a message that contains a list of staking-related
 * messages queued for an epoch
 */
export interface QueuedMessageList {
  epochNumber: number;
  msgs: QueuedMessageResponse[];
}

/** ValStateUpdateResponse is a message response that records a state update of a validator. */
export interface ValStateUpdateResponse {
  /** StateDesc defines the descriptive state. */
  stateDesc: string;
  blockHeight: number;
  blockTime: Date | undefined;
}

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(
    _: QueryParamsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryParamsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(
    base?: I,
  ): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(
    _: I,
  ): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(
    message: QueryParamsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryParamsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return {
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(
    base?: I,
  ): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(
    object: I,
  ): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params =
      object.params !== undefined && object.params !== null
        ? Params.fromPartial(object.params)
        : undefined;
    return message;
  },
};

function createBaseQueryEpochInfoRequest(): QueryEpochInfoRequest {
  return { epochNum: 0 };
}

export const QueryEpochInfoRequest: MessageFns<QueryEpochInfoRequest> = {
  encode(
    message: QueryEpochInfoRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.epochNum !== 0) {
      writer.uint32(8).uint64(message.epochNum);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryEpochInfoRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEpochInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.epochNum = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEpochInfoRequest {
    return {
      epochNum: isSet(object.epochNum) ? globalThis.Number(object.epochNum) : 0,
    };
  },

  toJSON(message: QueryEpochInfoRequest): unknown {
    const obj: any = {};
    if (message.epochNum !== 0) {
      obj.epochNum = Math.round(message.epochNum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEpochInfoRequest>, I>>(
    base?: I,
  ): QueryEpochInfoRequest {
    return QueryEpochInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEpochInfoRequest>, I>>(
    object: I,
  ): QueryEpochInfoRequest {
    const message = createBaseQueryEpochInfoRequest();
    message.epochNum = object.epochNum ?? 0;
    return message;
  },
};

function createBaseQueryEpochInfoResponse(): QueryEpochInfoResponse {
  return { epoch: undefined };
}

export const QueryEpochInfoResponse: MessageFns<QueryEpochInfoResponse> = {
  encode(
    message: QueryEpochInfoResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.epoch !== undefined) {
      EpochResponse.encode(message.epoch, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryEpochInfoResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEpochInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.epoch = EpochResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEpochInfoResponse {
    return {
      epoch: isSet(object.epoch)
        ? EpochResponse.fromJSON(object.epoch)
        : undefined,
    };
  },

  toJSON(message: QueryEpochInfoResponse): unknown {
    const obj: any = {};
    if (message.epoch !== undefined) {
      obj.epoch = EpochResponse.toJSON(message.epoch);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEpochInfoResponse>, I>>(
    base?: I,
  ): QueryEpochInfoResponse {
    return QueryEpochInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEpochInfoResponse>, I>>(
    object: I,
  ): QueryEpochInfoResponse {
    const message = createBaseQueryEpochInfoResponse();
    message.epoch =
      object.epoch !== undefined && object.epoch !== null
        ? EpochResponse.fromPartial(object.epoch)
        : undefined;
    return message;
  },
};

function createBaseQueryEpochsInfoRequest(): QueryEpochsInfoRequest {
  return { pagination: undefined };
}

export const QueryEpochsInfoRequest: MessageFns<QueryEpochsInfoRequest> = {
  encode(
    message: QueryEpochsInfoRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryEpochsInfoRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEpochsInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEpochsInfoRequest {
    return {
      pagination: isSet(object.pagination)
        ? PageRequest.fromJSON(object.pagination)
        : undefined,
    };
  },

  toJSON(message: QueryEpochsInfoRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEpochsInfoRequest>, I>>(
    base?: I,
  ): QueryEpochsInfoRequest {
    return QueryEpochsInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEpochsInfoRequest>, I>>(
    object: I,
  ): QueryEpochsInfoRequest {
    const message = createBaseQueryEpochsInfoRequest();
    message.pagination =
      object.pagination !== undefined && object.pagination !== null
        ? PageRequest.fromPartial(object.pagination)
        : undefined;
    return message;
  },
};

function createBaseQueryEpochsInfoResponse(): QueryEpochsInfoResponse {
  return { epochs: [], pagination: undefined };
}

export const QueryEpochsInfoResponse: MessageFns<QueryEpochsInfoResponse> = {
  encode(
    message: QueryEpochsInfoResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.epochs) {
      EpochResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryEpochsInfoResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEpochsInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.epochs.push(EpochResponse.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEpochsInfoResponse {
    return {
      epochs: globalThis.Array.isArray(object?.epochs)
        ? object.epochs.map((e: any) => EpochResponse.fromJSON(e))
        : [],
      pagination: isSet(object.pagination)
        ? PageResponse.fromJSON(object.pagination)
        : undefined,
    };
  },

  toJSON(message: QueryEpochsInfoResponse): unknown {
    const obj: any = {};
    if (message.epochs?.length) {
      obj.epochs = message.epochs.map((e) => EpochResponse.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEpochsInfoResponse>, I>>(
    base?: I,
  ): QueryEpochsInfoResponse {
    return QueryEpochsInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEpochsInfoResponse>, I>>(
    object: I,
  ): QueryEpochsInfoResponse {
    const message = createBaseQueryEpochsInfoResponse();
    message.epochs =
      object.epochs?.map((e) => EpochResponse.fromPartial(e)) || [];
    message.pagination =
      object.pagination !== undefined && object.pagination !== null
        ? PageResponse.fromPartial(object.pagination)
        : undefined;
    return message;
  },
};

function createBaseQueryCurrentEpochRequest(): QueryCurrentEpochRequest {
  return {};
}

export const QueryCurrentEpochRequest: MessageFns<QueryCurrentEpochRequest> = {
  encode(
    _: QueryCurrentEpochRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryCurrentEpochRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCurrentEpochRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryCurrentEpochRequest {
    return {};
  },

  toJSON(_: QueryCurrentEpochRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCurrentEpochRequest>, I>>(
    base?: I,
  ): QueryCurrentEpochRequest {
    return QueryCurrentEpochRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCurrentEpochRequest>, I>>(
    _: I,
  ): QueryCurrentEpochRequest {
    const message = createBaseQueryCurrentEpochRequest();
    return message;
  },
};

function createBaseQueryCurrentEpochResponse(): QueryCurrentEpochResponse {
  return { currentEpoch: 0, epochBoundary: 0 };
}

export const QueryCurrentEpochResponse: MessageFns<QueryCurrentEpochResponse> =
  {
    encode(
      message: QueryCurrentEpochResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.currentEpoch !== 0) {
        writer.uint32(8).uint64(message.currentEpoch);
      }
      if (message.epochBoundary !== 0) {
        writer.uint32(16).uint64(message.epochBoundary);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryCurrentEpochResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryCurrentEpochResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }

            message.currentEpoch = longToNumber(reader.uint64());
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }

            message.epochBoundary = longToNumber(reader.uint64());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryCurrentEpochResponse {
      return {
        currentEpoch: isSet(object.currentEpoch)
          ? globalThis.Number(object.currentEpoch)
          : 0,
        epochBoundary: isSet(object.epochBoundary)
          ? globalThis.Number(object.epochBoundary)
          : 0,
      };
    },

    toJSON(message: QueryCurrentEpochResponse): unknown {
      const obj: any = {};
      if (message.currentEpoch !== 0) {
        obj.currentEpoch = Math.round(message.currentEpoch);
      }
      if (message.epochBoundary !== 0) {
        obj.epochBoundary = Math.round(message.epochBoundary);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryCurrentEpochResponse>, I>>(
      base?: I,
    ): QueryCurrentEpochResponse {
      return QueryCurrentEpochResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryCurrentEpochResponse>, I>>(
      object: I,
    ): QueryCurrentEpochResponse {
      const message = createBaseQueryCurrentEpochResponse();
      message.currentEpoch = object.currentEpoch ?? 0;
      message.epochBoundary = object.epochBoundary ?? 0;
      return message;
    },
  };

function createBaseQueryEpochMsgsRequest(): QueryEpochMsgsRequest {
  return { epochNum: 0, pagination: undefined };
}

export const QueryEpochMsgsRequest: MessageFns<QueryEpochMsgsRequest> = {
  encode(
    message: QueryEpochMsgsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.epochNum !== 0) {
      writer.uint32(8).uint64(message.epochNum);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryEpochMsgsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEpochMsgsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.epochNum = longToNumber(reader.uint64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEpochMsgsRequest {
    return {
      epochNum: isSet(object.epochNum) ? globalThis.Number(object.epochNum) : 0,
      pagination: isSet(object.pagination)
        ? PageRequest.fromJSON(object.pagination)
        : undefined,
    };
  },

  toJSON(message: QueryEpochMsgsRequest): unknown {
    const obj: any = {};
    if (message.epochNum !== 0) {
      obj.epochNum = Math.round(message.epochNum);
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEpochMsgsRequest>, I>>(
    base?: I,
  ): QueryEpochMsgsRequest {
    return QueryEpochMsgsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEpochMsgsRequest>, I>>(
    object: I,
  ): QueryEpochMsgsRequest {
    const message = createBaseQueryEpochMsgsRequest();
    message.epochNum = object.epochNum ?? 0;
    message.pagination =
      object.pagination !== undefined && object.pagination !== null
        ? PageRequest.fromPartial(object.pagination)
        : undefined;
    return message;
  },
};

function createBaseQueryEpochMsgsResponse(): QueryEpochMsgsResponse {
  return { msgs: [], pagination: undefined };
}

export const QueryEpochMsgsResponse: MessageFns<QueryEpochMsgsResponse> = {
  encode(
    message: QueryEpochMsgsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.msgs) {
      QueuedMessageResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryEpochMsgsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEpochMsgsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.msgs.push(
            QueuedMessageResponse.decode(reader, reader.uint32()),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEpochMsgsResponse {
    return {
      msgs: globalThis.Array.isArray(object?.msgs)
        ? object.msgs.map((e: any) => QueuedMessageResponse.fromJSON(e))
        : [],
      pagination: isSet(object.pagination)
        ? PageResponse.fromJSON(object.pagination)
        : undefined,
    };
  },

  toJSON(message: QueryEpochMsgsResponse): unknown {
    const obj: any = {};
    if (message.msgs?.length) {
      obj.msgs = message.msgs.map((e) => QueuedMessageResponse.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEpochMsgsResponse>, I>>(
    base?: I,
  ): QueryEpochMsgsResponse {
    return QueryEpochMsgsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEpochMsgsResponse>, I>>(
    object: I,
  ): QueryEpochMsgsResponse {
    const message = createBaseQueryEpochMsgsResponse();
    message.msgs =
      object.msgs?.map((e) => QueuedMessageResponse.fromPartial(e)) || [];
    message.pagination =
      object.pagination !== undefined && object.pagination !== null
        ? PageResponse.fromPartial(object.pagination)
        : undefined;
    return message;
  },
};

function createBaseQueryLatestEpochMsgsRequest(): QueryLatestEpochMsgsRequest {
  return { endEpoch: 0, epochCount: 0, pagination: undefined };
}

export const QueryLatestEpochMsgsRequest: MessageFns<QueryLatestEpochMsgsRequest> =
  {
    encode(
      message: QueryLatestEpochMsgsRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.endEpoch !== 0) {
        writer.uint32(8).uint64(message.endEpoch);
      }
      if (message.epochCount !== 0) {
        writer.uint32(16).uint64(message.epochCount);
      }
      if (message.pagination !== undefined) {
        PageRequest.encode(message.pagination, writer.uint32(26).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryLatestEpochMsgsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryLatestEpochMsgsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }

            message.endEpoch = longToNumber(reader.uint64());
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }

            message.epochCount = longToNumber(reader.uint64());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }

            message.pagination = PageRequest.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryLatestEpochMsgsRequest {
      return {
        endEpoch: isSet(object.endEpoch)
          ? globalThis.Number(object.endEpoch)
          : 0,
        epochCount: isSet(object.epochCount)
          ? globalThis.Number(object.epochCount)
          : 0,
        pagination: isSet(object.pagination)
          ? PageRequest.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryLatestEpochMsgsRequest): unknown {
      const obj: any = {};
      if (message.endEpoch !== 0) {
        obj.endEpoch = Math.round(message.endEpoch);
      }
      if (message.epochCount !== 0) {
        obj.epochCount = Math.round(message.epochCount);
      }
      if (message.pagination !== undefined) {
        obj.pagination = PageRequest.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryLatestEpochMsgsRequest>, I>>(
      base?: I,
    ): QueryLatestEpochMsgsRequest {
      return QueryLatestEpochMsgsRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryLatestEpochMsgsRequest>, I>>(
      object: I,
    ): QueryLatestEpochMsgsRequest {
      const message = createBaseQueryLatestEpochMsgsRequest();
      message.endEpoch = object.endEpoch ?? 0;
      message.epochCount = object.epochCount ?? 0;
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageRequest.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryLatestEpochMsgsResponse(): QueryLatestEpochMsgsResponse {
  return { latestEpochMsgs: [], pagination: undefined };
}

export const QueryLatestEpochMsgsResponse: MessageFns<QueryLatestEpochMsgsResponse> =
  {
    encode(
      message: QueryLatestEpochMsgsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.latestEpochMsgs) {
        QueuedMessageList.encode(v!, writer.uint32(10).fork()).join();
      }
      if (message.pagination !== undefined) {
        PageResponse.encode(
          message.pagination,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryLatestEpochMsgsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryLatestEpochMsgsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.latestEpochMsgs.push(
              QueuedMessageList.decode(reader, reader.uint32()),
            );
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.pagination = PageResponse.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryLatestEpochMsgsResponse {
      return {
        latestEpochMsgs: globalThis.Array.isArray(object?.latestEpochMsgs)
          ? object.latestEpochMsgs.map((e: any) =>
              QueuedMessageList.fromJSON(e),
            )
          : [],
        pagination: isSet(object.pagination)
          ? PageResponse.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryLatestEpochMsgsResponse): unknown {
      const obj: any = {};
      if (message.latestEpochMsgs?.length) {
        obj.latestEpochMsgs = message.latestEpochMsgs.map((e) =>
          QueuedMessageList.toJSON(e),
        );
      }
      if (message.pagination !== undefined) {
        obj.pagination = PageResponse.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryLatestEpochMsgsResponse>, I>>(
      base?: I,
    ): QueryLatestEpochMsgsResponse {
      return QueryLatestEpochMsgsResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryLatestEpochMsgsResponse>, I>>(
      object: I,
    ): QueryLatestEpochMsgsResponse {
      const message = createBaseQueryLatestEpochMsgsResponse();
      message.latestEpochMsgs =
        object.latestEpochMsgs?.map((e) => QueuedMessageList.fromPartial(e)) ||
        [];
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageResponse.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryValidatorLifecycleRequest(): QueryValidatorLifecycleRequest {
  return { valAddr: "" };
}

export const QueryValidatorLifecycleRequest: MessageFns<QueryValidatorLifecycleRequest> =
  {
    encode(
      message: QueryValidatorLifecycleRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.valAddr !== "") {
        writer.uint32(10).string(message.valAddr);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryValidatorLifecycleRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryValidatorLifecycleRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.valAddr = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryValidatorLifecycleRequest {
      return {
        valAddr: isSet(object.valAddr) ? globalThis.String(object.valAddr) : "",
      };
    },

    toJSON(message: QueryValidatorLifecycleRequest): unknown {
      const obj: any = {};
      if (message.valAddr !== "") {
        obj.valAddr = message.valAddr;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryValidatorLifecycleRequest>, I>>(
      base?: I,
    ): QueryValidatorLifecycleRequest {
      return QueryValidatorLifecycleRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryValidatorLifecycleRequest>, I>,
    >(object: I): QueryValidatorLifecycleRequest {
      const message = createBaseQueryValidatorLifecycleRequest();
      message.valAddr = object.valAddr ?? "";
      return message;
    },
  };

function createBaseQueryValidatorLifecycleResponse(): QueryValidatorLifecycleResponse {
  return { valAddr: "", valLife: [] };
}

export const QueryValidatorLifecycleResponse: MessageFns<QueryValidatorLifecycleResponse> =
  {
    encode(
      message: QueryValidatorLifecycleResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.valAddr !== "") {
        writer.uint32(10).string(message.valAddr);
      }
      for (const v of message.valLife) {
        ValStateUpdateResponse.encode(v!, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryValidatorLifecycleResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryValidatorLifecycleResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.valAddr = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.valLife.push(
              ValStateUpdateResponse.decode(reader, reader.uint32()),
            );
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryValidatorLifecycleResponse {
      return {
        valAddr: isSet(object.valAddr) ? globalThis.String(object.valAddr) : "",
        valLife: globalThis.Array.isArray(object?.valLife)
          ? object.valLife.map((e: any) => ValStateUpdateResponse.fromJSON(e))
          : [],
      };
    },

    toJSON(message: QueryValidatorLifecycleResponse): unknown {
      const obj: any = {};
      if (message.valAddr !== "") {
        obj.valAddr = message.valAddr;
      }
      if (message.valLife?.length) {
        obj.valLife = message.valLife.map((e) =>
          ValStateUpdateResponse.toJSON(e),
        );
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryValidatorLifecycleResponse>, I>>(
      base?: I,
    ): QueryValidatorLifecycleResponse {
      return QueryValidatorLifecycleResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryValidatorLifecycleResponse>, I>,
    >(object: I): QueryValidatorLifecycleResponse {
      const message = createBaseQueryValidatorLifecycleResponse();
      message.valAddr = object.valAddr ?? "";
      message.valLife =
        object.valLife?.map((e) => ValStateUpdateResponse.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseQueryDelegationLifecycleRequest(): QueryDelegationLifecycleRequest {
  return { delAddr: "" };
}

export const QueryDelegationLifecycleRequest: MessageFns<QueryDelegationLifecycleRequest> =
  {
    encode(
      message: QueryDelegationLifecycleRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.delAddr !== "") {
        writer.uint32(10).string(message.delAddr);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryDelegationLifecycleRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryDelegationLifecycleRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.delAddr = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryDelegationLifecycleRequest {
      return {
        delAddr: isSet(object.delAddr) ? globalThis.String(object.delAddr) : "",
      };
    },

    toJSON(message: QueryDelegationLifecycleRequest): unknown {
      const obj: any = {};
      if (message.delAddr !== "") {
        obj.delAddr = message.delAddr;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryDelegationLifecycleRequest>, I>>(
      base?: I,
    ): QueryDelegationLifecycleRequest {
      return QueryDelegationLifecycleRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryDelegationLifecycleRequest>, I>,
    >(object: I): QueryDelegationLifecycleRequest {
      const message = createBaseQueryDelegationLifecycleRequest();
      message.delAddr = object.delAddr ?? "";
      return message;
    },
  };

function createBaseQueryDelegationLifecycleResponse(): QueryDelegationLifecycleResponse {
  return { delLife: undefined };
}

export const QueryDelegationLifecycleResponse: MessageFns<QueryDelegationLifecycleResponse> =
  {
    encode(
      message: QueryDelegationLifecycleResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.delLife !== undefined) {
        DelegationLifecycle.encode(
          message.delLife,
          writer.uint32(10).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryDelegationLifecycleResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryDelegationLifecycleResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.delLife = DelegationLifecycle.decode(
              reader,
              reader.uint32(),
            );
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryDelegationLifecycleResponse {
      return {
        delLife: isSet(object.delLife)
          ? DelegationLifecycle.fromJSON(object.delLife)
          : undefined,
      };
    },

    toJSON(message: QueryDelegationLifecycleResponse): unknown {
      const obj: any = {};
      if (message.delLife !== undefined) {
        obj.delLife = DelegationLifecycle.toJSON(message.delLife);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryDelegationLifecycleResponse>, I>>(
      base?: I,
    ): QueryDelegationLifecycleResponse {
      return QueryDelegationLifecycleResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryDelegationLifecycleResponse>, I>,
    >(object: I): QueryDelegationLifecycleResponse {
      const message = createBaseQueryDelegationLifecycleResponse();
      message.delLife =
        object.delLife !== undefined && object.delLife !== null
          ? DelegationLifecycle.fromPartial(object.delLife)
          : undefined;
      return message;
    },
  };

function createBaseQueryEpochValSetRequest(): QueryEpochValSetRequest {
  return { epochNum: 0, pagination: undefined };
}

export const QueryEpochValSetRequest: MessageFns<QueryEpochValSetRequest> = {
  encode(
    message: QueryEpochValSetRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.epochNum !== 0) {
      writer.uint32(8).uint64(message.epochNum);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryEpochValSetRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEpochValSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.epochNum = longToNumber(reader.uint64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEpochValSetRequest {
    return {
      epochNum: isSet(object.epochNum) ? globalThis.Number(object.epochNum) : 0,
      pagination: isSet(object.pagination)
        ? PageRequest.fromJSON(object.pagination)
        : undefined,
    };
  },

  toJSON(message: QueryEpochValSetRequest): unknown {
    const obj: any = {};
    if (message.epochNum !== 0) {
      obj.epochNum = Math.round(message.epochNum);
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEpochValSetRequest>, I>>(
    base?: I,
  ): QueryEpochValSetRequest {
    return QueryEpochValSetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEpochValSetRequest>, I>>(
    object: I,
  ): QueryEpochValSetRequest {
    const message = createBaseQueryEpochValSetRequest();
    message.epochNum = object.epochNum ?? 0;
    message.pagination =
      object.pagination !== undefined && object.pagination !== null
        ? PageRequest.fromPartial(object.pagination)
        : undefined;
    return message;
  },
};

function createBaseQueryEpochValSetResponse(): QueryEpochValSetResponse {
  return { validators: [], totalVotingPower: 0, pagination: undefined };
}

export const QueryEpochValSetResponse: MessageFns<QueryEpochValSetResponse> = {
  encode(
    message: QueryEpochValSetResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.validators) {
      Validator.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalVotingPower !== 0) {
      writer.uint32(16).int64(message.totalVotingPower);
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryEpochValSetResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEpochValSetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.validators.push(Validator.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalVotingPower = longToNumber(reader.int64());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEpochValSetResponse {
    return {
      validators: globalThis.Array.isArray(object?.validators)
        ? object.validators.map((e: any) => Validator.fromJSON(e))
        : [],
      totalVotingPower: isSet(object.totalVotingPower)
        ? globalThis.Number(object.totalVotingPower)
        : 0,
      pagination: isSet(object.pagination)
        ? PageResponse.fromJSON(object.pagination)
        : undefined,
    };
  },

  toJSON(message: QueryEpochValSetResponse): unknown {
    const obj: any = {};
    if (message.validators?.length) {
      obj.validators = message.validators.map((e) => Validator.toJSON(e));
    }
    if (message.totalVotingPower !== 0) {
      obj.totalVotingPower = Math.round(message.totalVotingPower);
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEpochValSetResponse>, I>>(
    base?: I,
  ): QueryEpochValSetResponse {
    return QueryEpochValSetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEpochValSetResponse>, I>>(
    object: I,
  ): QueryEpochValSetResponse {
    const message = createBaseQueryEpochValSetResponse();
    message.validators =
      object.validators?.map((e) => Validator.fromPartial(e)) || [];
    message.totalVotingPower = object.totalVotingPower ?? 0;
    message.pagination =
      object.pagination !== undefined && object.pagination !== null
        ? PageResponse.fromPartial(object.pagination)
        : undefined;
    return message;
  },
};

function createBaseEpochResponse(): EpochResponse {
  return {
    epochNumber: 0,
    currentEpochInterval: 0,
    firstBlockHeight: 0,
    lastBlockTime: undefined,
    sealerAppHashHex: "",
    sealerBlockHash: "",
  };
}

export const EpochResponse: MessageFns<EpochResponse> = {
  encode(
    message: EpochResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.epochNumber !== 0) {
      writer.uint32(8).uint64(message.epochNumber);
    }
    if (message.currentEpochInterval !== 0) {
      writer.uint32(16).uint64(message.currentEpochInterval);
    }
    if (message.firstBlockHeight !== 0) {
      writer.uint32(24).uint64(message.firstBlockHeight);
    }
    if (message.lastBlockTime !== undefined) {
      Timestamp.encode(
        toTimestamp(message.lastBlockTime),
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.sealerAppHashHex !== "") {
      writer.uint32(42).string(message.sealerAppHashHex);
    }
    if (message.sealerBlockHash !== "") {
      writer.uint32(50).string(message.sealerBlockHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EpochResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEpochResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.epochNumber = longToNumber(reader.uint64());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.currentEpochInterval = longToNumber(reader.uint64());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.firstBlockHeight = longToNumber(reader.uint64());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lastBlockTime = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sealerAppHashHex = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sealerBlockHash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EpochResponse {
    return {
      epochNumber: isSet(object.epochNumber)
        ? globalThis.Number(object.epochNumber)
        : 0,
      currentEpochInterval: isSet(object.currentEpochInterval)
        ? globalThis.Number(object.currentEpochInterval)
        : 0,
      firstBlockHeight: isSet(object.firstBlockHeight)
        ? globalThis.Number(object.firstBlockHeight)
        : 0,
      lastBlockTime: isSet(object.lastBlockTime)
        ? fromJsonTimestamp(object.lastBlockTime)
        : undefined,
      sealerAppHashHex: isSet(object.sealerAppHashHex)
        ? globalThis.String(object.sealerAppHashHex)
        : "",
      sealerBlockHash: isSet(object.sealerBlockHash)
        ? globalThis.String(object.sealerBlockHash)
        : "",
    };
  },

  toJSON(message: EpochResponse): unknown {
    const obj: any = {};
    if (message.epochNumber !== 0) {
      obj.epochNumber = Math.round(message.epochNumber);
    }
    if (message.currentEpochInterval !== 0) {
      obj.currentEpochInterval = Math.round(message.currentEpochInterval);
    }
    if (message.firstBlockHeight !== 0) {
      obj.firstBlockHeight = Math.round(message.firstBlockHeight);
    }
    if (message.lastBlockTime !== undefined) {
      obj.lastBlockTime = message.lastBlockTime.toISOString();
    }
    if (message.sealerAppHashHex !== "") {
      obj.sealerAppHashHex = message.sealerAppHashHex;
    }
    if (message.sealerBlockHash !== "") {
      obj.sealerBlockHash = message.sealerBlockHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EpochResponse>, I>>(
    base?: I,
  ): EpochResponse {
    return EpochResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EpochResponse>, I>>(
    object: I,
  ): EpochResponse {
    const message = createBaseEpochResponse();
    message.epochNumber = object.epochNumber ?? 0;
    message.currentEpochInterval = object.currentEpochInterval ?? 0;
    message.firstBlockHeight = object.firstBlockHeight ?? 0;
    message.lastBlockTime = object.lastBlockTime ?? undefined;
    message.sealerAppHashHex = object.sealerAppHashHex ?? "";
    message.sealerBlockHash = object.sealerBlockHash ?? "";
    return message;
  },
};

function createBaseQueuedMessageResponse(): QueuedMessageResponse {
  return { txId: "", msgId: "", blockHeight: 0, blockTime: undefined, msg: "" };
}

export const QueuedMessageResponse: MessageFns<QueuedMessageResponse> = {
  encode(
    message: QueuedMessageResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.txId !== "") {
      writer.uint32(10).string(message.txId);
    }
    if (message.msgId !== "") {
      writer.uint32(18).string(message.msgId);
    }
    if (message.blockHeight !== 0) {
      writer.uint32(24).uint64(message.blockHeight);
    }
    if (message.blockTime !== undefined) {
      Timestamp.encode(
        toTimestamp(message.blockTime),
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.msg !== "") {
      writer.uint32(42).string(message.msg);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueuedMessageResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueuedMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.msgId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.blockHeight = longToNumber(reader.uint64());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.blockTime = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.msg = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueuedMessageResponse {
    return {
      txId: isSet(object.txId) ? globalThis.String(object.txId) : "",
      msgId: isSet(object.msgId) ? globalThis.String(object.msgId) : "",
      blockHeight: isSet(object.blockHeight)
        ? globalThis.Number(object.blockHeight)
        : 0,
      blockTime: isSet(object.blockTime)
        ? fromJsonTimestamp(object.blockTime)
        : undefined,
      msg: isSet(object.msg) ? globalThis.String(object.msg) : "",
    };
  },

  toJSON(message: QueuedMessageResponse): unknown {
    const obj: any = {};
    if (message.txId !== "") {
      obj.txId = message.txId;
    }
    if (message.msgId !== "") {
      obj.msgId = message.msgId;
    }
    if (message.blockHeight !== 0) {
      obj.blockHeight = Math.round(message.blockHeight);
    }
    if (message.blockTime !== undefined) {
      obj.blockTime = message.blockTime.toISOString();
    }
    if (message.msg !== "") {
      obj.msg = message.msg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueuedMessageResponse>, I>>(
    base?: I,
  ): QueuedMessageResponse {
    return QueuedMessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueuedMessageResponse>, I>>(
    object: I,
  ): QueuedMessageResponse {
    const message = createBaseQueuedMessageResponse();
    message.txId = object.txId ?? "";
    message.msgId = object.msgId ?? "";
    message.blockHeight = object.blockHeight ?? 0;
    message.blockTime = object.blockTime ?? undefined;
    message.msg = object.msg ?? "";
    return message;
  },
};

function createBaseQueuedMessageList(): QueuedMessageList {
  return { epochNumber: 0, msgs: [] };
}

export const QueuedMessageList: MessageFns<QueuedMessageList> = {
  encode(
    message: QueuedMessageList,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.epochNumber !== 0) {
      writer.uint32(8).uint64(message.epochNumber);
    }
    for (const v of message.msgs) {
      QueuedMessageResponse.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueuedMessageList {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueuedMessageList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.epochNumber = longToNumber(reader.uint64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.msgs.push(
            QueuedMessageResponse.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueuedMessageList {
    return {
      epochNumber: isSet(object.epochNumber)
        ? globalThis.Number(object.epochNumber)
        : 0,
      msgs: globalThis.Array.isArray(object?.msgs)
        ? object.msgs.map((e: any) => QueuedMessageResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueuedMessageList): unknown {
    const obj: any = {};
    if (message.epochNumber !== 0) {
      obj.epochNumber = Math.round(message.epochNumber);
    }
    if (message.msgs?.length) {
      obj.msgs = message.msgs.map((e) => QueuedMessageResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueuedMessageList>, I>>(
    base?: I,
  ): QueuedMessageList {
    return QueuedMessageList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueuedMessageList>, I>>(
    object: I,
  ): QueuedMessageList {
    const message = createBaseQueuedMessageList();
    message.epochNumber = object.epochNumber ?? 0;
    message.msgs =
      object.msgs?.map((e) => QueuedMessageResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseValStateUpdateResponse(): ValStateUpdateResponse {
  return { stateDesc: "", blockHeight: 0, blockTime: undefined };
}

export const ValStateUpdateResponse: MessageFns<ValStateUpdateResponse> = {
  encode(
    message: ValStateUpdateResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.stateDesc !== "") {
      writer.uint32(10).string(message.stateDesc);
    }
    if (message.blockHeight !== 0) {
      writer.uint32(16).uint64(message.blockHeight);
    }
    if (message.blockTime !== undefined) {
      Timestamp.encode(
        toTimestamp(message.blockTime),
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ValStateUpdateResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValStateUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stateDesc = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.blockHeight = longToNumber(reader.uint64());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.blockTime = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValStateUpdateResponse {
    return {
      stateDesc: isSet(object.stateDesc)
        ? globalThis.String(object.stateDesc)
        : "",
      blockHeight: isSet(object.blockHeight)
        ? globalThis.Number(object.blockHeight)
        : 0,
      blockTime: isSet(object.blockTime)
        ? fromJsonTimestamp(object.blockTime)
        : undefined,
    };
  },

  toJSON(message: ValStateUpdateResponse): unknown {
    const obj: any = {};
    if (message.stateDesc !== "") {
      obj.stateDesc = message.stateDesc;
    }
    if (message.blockHeight !== 0) {
      obj.blockHeight = Math.round(message.blockHeight);
    }
    if (message.blockTime !== undefined) {
      obj.blockTime = message.blockTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValStateUpdateResponse>, I>>(
    base?: I,
  ): ValStateUpdateResponse {
    return ValStateUpdateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValStateUpdateResponse>, I>>(
    object: I,
  ): ValStateUpdateResponse {
    const message = createBaseValStateUpdateResponse();
    message.stateDesc = object.stateDesc ?? "";
    message.blockHeight = object.blockHeight ?? 0;
    message.blockTime = object.blockTime ?? undefined;
    return message;
  },
};

/** Query defines the gRPC querier service. */
export interface Query {
  /** Params queries the parameters of the module. */
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
  /** EpochInfo queries the information of a given epoch */
  EpochInfo(request: QueryEpochInfoRequest): Promise<QueryEpochInfoResponse>;
  /**
   * EpochsInfo queries the metadata of epochs in a given range, depending on
   * the parameters in the pagination request. Th main use case will be querying
   * the latest epochs in time order.
   */
  EpochsInfo(request: QueryEpochsInfoRequest): Promise<QueryEpochsInfoResponse>;
  /** CurrentEpoch queries the current epoch */
  CurrentEpoch(
    request: QueryCurrentEpochRequest,
  ): Promise<QueryCurrentEpochResponse>;
  /** EpochMsgs queries the messages of a given epoch */
  EpochMsgs(request: QueryEpochMsgsRequest): Promise<QueryEpochMsgsResponse>;
  /**
   * LatestEpochMsgs queries the messages within a given number of most recent
   * epochs
   */
  LatestEpochMsgs(
    request: QueryLatestEpochMsgsRequest,
  ): Promise<QueryLatestEpochMsgsResponse>;
  /** ValidatorLifecycle queries the lifecycle of a given validator */
  ValidatorLifecycle(
    request: QueryValidatorLifecycleRequest,
  ): Promise<QueryValidatorLifecycleResponse>;
  /** DelegationLifecycle queries the lifecycle of a given delegation */
  DelegationLifecycle(
    request: QueryDelegationLifecycleRequest,
  ): Promise<QueryDelegationLifecycleResponse>;
  /** EpochValSet queries the validator set of a given epoch */
  EpochValSet(
    request: QueryEpochValSetRequest,
  ): Promise<QueryEpochValSetResponse>;
}

export const QueryServiceName = "babylon.epoching.v1.Query";
export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceName;
    this.rpc = rpc;
    this.Params = this.Params.bind(this);
    this.EpochInfo = this.EpochInfo.bind(this);
    this.EpochsInfo = this.EpochsInfo.bind(this);
    this.CurrentEpoch = this.CurrentEpoch.bind(this);
    this.EpochMsgs = this.EpochMsgs.bind(this);
    this.LatestEpochMsgs = this.LatestEpochMsgs.bind(this);
    this.ValidatorLifecycle = this.ValidatorLifecycle.bind(this);
    this.DelegationLifecycle = this.DelegationLifecycle.bind(this);
    this.EpochValSet = this.EpochValSet.bind(this);
  }
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse> {
    const data = QueryParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Params", data);
    return promise.then((data) =>
      QueryParamsResponse.decode(new BinaryReader(data)),
    );
  }

  EpochInfo(request: QueryEpochInfoRequest): Promise<QueryEpochInfoResponse> {
    const data = QueryEpochInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EpochInfo", data);
    return promise.then((data) =>
      QueryEpochInfoResponse.decode(new BinaryReader(data)),
    );
  }

  EpochsInfo(
    request: QueryEpochsInfoRequest,
  ): Promise<QueryEpochsInfoResponse> {
    const data = QueryEpochsInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EpochsInfo", data);
    return promise.then((data) =>
      QueryEpochsInfoResponse.decode(new BinaryReader(data)),
    );
  }

  CurrentEpoch(
    request: QueryCurrentEpochRequest,
  ): Promise<QueryCurrentEpochResponse> {
    const data = QueryCurrentEpochRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CurrentEpoch", data);
    return promise.then((data) =>
      QueryCurrentEpochResponse.decode(new BinaryReader(data)),
    );
  }

  EpochMsgs(request: QueryEpochMsgsRequest): Promise<QueryEpochMsgsResponse> {
    const data = QueryEpochMsgsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EpochMsgs", data);
    return promise.then((data) =>
      QueryEpochMsgsResponse.decode(new BinaryReader(data)),
    );
  }

  LatestEpochMsgs(
    request: QueryLatestEpochMsgsRequest,
  ): Promise<QueryLatestEpochMsgsResponse> {
    const data = QueryLatestEpochMsgsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "LatestEpochMsgs", data);
    return promise.then((data) =>
      QueryLatestEpochMsgsResponse.decode(new BinaryReader(data)),
    );
  }

  ValidatorLifecycle(
    request: QueryValidatorLifecycleRequest,
  ): Promise<QueryValidatorLifecycleResponse> {
    const data = QueryValidatorLifecycleRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ValidatorLifecycle", data);
    return promise.then((data) =>
      QueryValidatorLifecycleResponse.decode(new BinaryReader(data)),
    );
  }

  DelegationLifecycle(
    request: QueryDelegationLifecycleRequest,
  ): Promise<QueryDelegationLifecycleResponse> {
    const data = QueryDelegationLifecycleRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DelegationLifecycle", data);
    return promise.then((data) =>
      QueryDelegationLifecycleResponse.decode(new BinaryReader(data)),
    );
  }

  EpochValSet(
    request: QueryEpochValSetRequest,
  ): Promise<QueryEpochValSetResponse> {
    const data = QueryEpochValSetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EpochValSet", data);
    return promise.then((data) =>
      QueryEpochValSetResponse.decode(new BinaryReader(data)),
    );
  }
}

interface Rpc {
  request(
    service: string,
    method: string,
    data: Uint8Array,
  ): Promise<Uint8Array>;
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
