// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: babylon/checkpointing/v1/events.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { RawCheckpoint, RawCheckpointWithMeta } from "./checkpoint";

export const protobufPackage = "babylon.checkpointing.v1";

/**
 * EventCheckpointAccumulating is emitted when a checkpoint reaches the
 * `Accumulating` state.
 */
export interface EventCheckpointAccumulating {
  checkpoint: RawCheckpointWithMeta | undefined;
}

/**
 * EventCheckpointSealed is emitted when a checkpoint reaches the `Sealed`
 * state.
 */
export interface EventCheckpointSealed {
  checkpoint: RawCheckpointWithMeta | undefined;
}

/**
 * EventCheckpointSubmitted is emitted when a checkpoint reaches the `Submitted`
 * state.
 */
export interface EventCheckpointSubmitted {
  checkpoint: RawCheckpointWithMeta | undefined;
}

/**
 * EventCheckpointConfirmed is emitted when a checkpoint reaches the `Confirmed`
 * state.
 */
export interface EventCheckpointConfirmed {
  checkpoint: RawCheckpointWithMeta | undefined;
}

/**
 * EventCheckpointFinalized is emitted when a checkpoint reaches the `Finalized`
 * state.
 */
export interface EventCheckpointFinalized {
  checkpoint: RawCheckpointWithMeta | undefined;
}

/**
 * EventCheckpointForgotten is emitted when a checkpoint switches to a
 * `Forgotten` state.
 */
export interface EventCheckpointForgotten {
  checkpoint: RawCheckpointWithMeta | undefined;
}

/**
 * EventConflictingCheckpoint is emitted when two conflicting checkpoints are
 * found.
 */
export interface EventConflictingCheckpoint {
  conflictingCheckpoint: RawCheckpoint | undefined;
  localCheckpoint: RawCheckpointWithMeta | undefined;
}

function createBaseEventCheckpointAccumulating(): EventCheckpointAccumulating {
  return { checkpoint: undefined };
}

export const EventCheckpointAccumulating: MessageFns<EventCheckpointAccumulating> =
  {
    encode(
      message: EventCheckpointAccumulating,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.checkpoint !== undefined) {
        RawCheckpointWithMeta.encode(
          message.checkpoint,
          writer.uint32(10).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): EventCheckpointAccumulating {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEventCheckpointAccumulating();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.checkpoint = RawCheckpointWithMeta.decode(
              reader,
              reader.uint32(),
            );
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventCheckpointAccumulating {
      return {
        checkpoint: isSet(object.checkpoint)
          ? RawCheckpointWithMeta.fromJSON(object.checkpoint)
          : undefined,
      };
    },

    toJSON(message: EventCheckpointAccumulating): unknown {
      const obj: any = {};
      if (message.checkpoint !== undefined) {
        obj.checkpoint = RawCheckpointWithMeta.toJSON(message.checkpoint);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<EventCheckpointAccumulating>, I>>(
      base?: I,
    ): EventCheckpointAccumulating {
      return EventCheckpointAccumulating.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<EventCheckpointAccumulating>, I>>(
      object: I,
    ): EventCheckpointAccumulating {
      const message = createBaseEventCheckpointAccumulating();
      message.checkpoint =
        object.checkpoint !== undefined && object.checkpoint !== null
          ? RawCheckpointWithMeta.fromPartial(object.checkpoint)
          : undefined;
      return message;
    },
  };

function createBaseEventCheckpointSealed(): EventCheckpointSealed {
  return { checkpoint: undefined };
}

export const EventCheckpointSealed: MessageFns<EventCheckpointSealed> = {
  encode(
    message: EventCheckpointSealed,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.checkpoint !== undefined) {
      RawCheckpointWithMeta.encode(
        message.checkpoint,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): EventCheckpointSealed {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventCheckpointSealed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.checkpoint = RawCheckpointWithMeta.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventCheckpointSealed {
    return {
      checkpoint: isSet(object.checkpoint)
        ? RawCheckpointWithMeta.fromJSON(object.checkpoint)
        : undefined,
    };
  },

  toJSON(message: EventCheckpointSealed): unknown {
    const obj: any = {};
    if (message.checkpoint !== undefined) {
      obj.checkpoint = RawCheckpointWithMeta.toJSON(message.checkpoint);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventCheckpointSealed>, I>>(
    base?: I,
  ): EventCheckpointSealed {
    return EventCheckpointSealed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventCheckpointSealed>, I>>(
    object: I,
  ): EventCheckpointSealed {
    const message = createBaseEventCheckpointSealed();
    message.checkpoint =
      object.checkpoint !== undefined && object.checkpoint !== null
        ? RawCheckpointWithMeta.fromPartial(object.checkpoint)
        : undefined;
    return message;
  },
};

function createBaseEventCheckpointSubmitted(): EventCheckpointSubmitted {
  return { checkpoint: undefined };
}

export const EventCheckpointSubmitted: MessageFns<EventCheckpointSubmitted> = {
  encode(
    message: EventCheckpointSubmitted,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.checkpoint !== undefined) {
      RawCheckpointWithMeta.encode(
        message.checkpoint,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): EventCheckpointSubmitted {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventCheckpointSubmitted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.checkpoint = RawCheckpointWithMeta.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventCheckpointSubmitted {
    return {
      checkpoint: isSet(object.checkpoint)
        ? RawCheckpointWithMeta.fromJSON(object.checkpoint)
        : undefined,
    };
  },

  toJSON(message: EventCheckpointSubmitted): unknown {
    const obj: any = {};
    if (message.checkpoint !== undefined) {
      obj.checkpoint = RawCheckpointWithMeta.toJSON(message.checkpoint);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventCheckpointSubmitted>, I>>(
    base?: I,
  ): EventCheckpointSubmitted {
    return EventCheckpointSubmitted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventCheckpointSubmitted>, I>>(
    object: I,
  ): EventCheckpointSubmitted {
    const message = createBaseEventCheckpointSubmitted();
    message.checkpoint =
      object.checkpoint !== undefined && object.checkpoint !== null
        ? RawCheckpointWithMeta.fromPartial(object.checkpoint)
        : undefined;
    return message;
  },
};

function createBaseEventCheckpointConfirmed(): EventCheckpointConfirmed {
  return { checkpoint: undefined };
}

export const EventCheckpointConfirmed: MessageFns<EventCheckpointConfirmed> = {
  encode(
    message: EventCheckpointConfirmed,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.checkpoint !== undefined) {
      RawCheckpointWithMeta.encode(
        message.checkpoint,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): EventCheckpointConfirmed {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventCheckpointConfirmed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.checkpoint = RawCheckpointWithMeta.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventCheckpointConfirmed {
    return {
      checkpoint: isSet(object.checkpoint)
        ? RawCheckpointWithMeta.fromJSON(object.checkpoint)
        : undefined,
    };
  },

  toJSON(message: EventCheckpointConfirmed): unknown {
    const obj: any = {};
    if (message.checkpoint !== undefined) {
      obj.checkpoint = RawCheckpointWithMeta.toJSON(message.checkpoint);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventCheckpointConfirmed>, I>>(
    base?: I,
  ): EventCheckpointConfirmed {
    return EventCheckpointConfirmed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventCheckpointConfirmed>, I>>(
    object: I,
  ): EventCheckpointConfirmed {
    const message = createBaseEventCheckpointConfirmed();
    message.checkpoint =
      object.checkpoint !== undefined && object.checkpoint !== null
        ? RawCheckpointWithMeta.fromPartial(object.checkpoint)
        : undefined;
    return message;
  },
};

function createBaseEventCheckpointFinalized(): EventCheckpointFinalized {
  return { checkpoint: undefined };
}

export const EventCheckpointFinalized: MessageFns<EventCheckpointFinalized> = {
  encode(
    message: EventCheckpointFinalized,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.checkpoint !== undefined) {
      RawCheckpointWithMeta.encode(
        message.checkpoint,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): EventCheckpointFinalized {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventCheckpointFinalized();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.checkpoint = RawCheckpointWithMeta.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventCheckpointFinalized {
    return {
      checkpoint: isSet(object.checkpoint)
        ? RawCheckpointWithMeta.fromJSON(object.checkpoint)
        : undefined,
    };
  },

  toJSON(message: EventCheckpointFinalized): unknown {
    const obj: any = {};
    if (message.checkpoint !== undefined) {
      obj.checkpoint = RawCheckpointWithMeta.toJSON(message.checkpoint);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventCheckpointFinalized>, I>>(
    base?: I,
  ): EventCheckpointFinalized {
    return EventCheckpointFinalized.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventCheckpointFinalized>, I>>(
    object: I,
  ): EventCheckpointFinalized {
    const message = createBaseEventCheckpointFinalized();
    message.checkpoint =
      object.checkpoint !== undefined && object.checkpoint !== null
        ? RawCheckpointWithMeta.fromPartial(object.checkpoint)
        : undefined;
    return message;
  },
};

function createBaseEventCheckpointForgotten(): EventCheckpointForgotten {
  return { checkpoint: undefined };
}

export const EventCheckpointForgotten: MessageFns<EventCheckpointForgotten> = {
  encode(
    message: EventCheckpointForgotten,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.checkpoint !== undefined) {
      RawCheckpointWithMeta.encode(
        message.checkpoint,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): EventCheckpointForgotten {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventCheckpointForgotten();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.checkpoint = RawCheckpointWithMeta.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventCheckpointForgotten {
    return {
      checkpoint: isSet(object.checkpoint)
        ? RawCheckpointWithMeta.fromJSON(object.checkpoint)
        : undefined,
    };
  },

  toJSON(message: EventCheckpointForgotten): unknown {
    const obj: any = {};
    if (message.checkpoint !== undefined) {
      obj.checkpoint = RawCheckpointWithMeta.toJSON(message.checkpoint);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventCheckpointForgotten>, I>>(
    base?: I,
  ): EventCheckpointForgotten {
    return EventCheckpointForgotten.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventCheckpointForgotten>, I>>(
    object: I,
  ): EventCheckpointForgotten {
    const message = createBaseEventCheckpointForgotten();
    message.checkpoint =
      object.checkpoint !== undefined && object.checkpoint !== null
        ? RawCheckpointWithMeta.fromPartial(object.checkpoint)
        : undefined;
    return message;
  },
};

function createBaseEventConflictingCheckpoint(): EventConflictingCheckpoint {
  return { conflictingCheckpoint: undefined, localCheckpoint: undefined };
}

export const EventConflictingCheckpoint: MessageFns<EventConflictingCheckpoint> =
  {
    encode(
      message: EventConflictingCheckpoint,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.conflictingCheckpoint !== undefined) {
        RawCheckpoint.encode(
          message.conflictingCheckpoint,
          writer.uint32(10).fork(),
        ).join();
      }
      if (message.localCheckpoint !== undefined) {
        RawCheckpointWithMeta.encode(
          message.localCheckpoint,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): EventConflictingCheckpoint {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEventConflictingCheckpoint();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.conflictingCheckpoint = RawCheckpoint.decode(
              reader,
              reader.uint32(),
            );
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.localCheckpoint = RawCheckpointWithMeta.decode(
              reader,
              reader.uint32(),
            );
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventConflictingCheckpoint {
      return {
        conflictingCheckpoint: isSet(object.conflictingCheckpoint)
          ? RawCheckpoint.fromJSON(object.conflictingCheckpoint)
          : undefined,
        localCheckpoint: isSet(object.localCheckpoint)
          ? RawCheckpointWithMeta.fromJSON(object.localCheckpoint)
          : undefined,
      };
    },

    toJSON(message: EventConflictingCheckpoint): unknown {
      const obj: any = {};
      if (message.conflictingCheckpoint !== undefined) {
        obj.conflictingCheckpoint = RawCheckpoint.toJSON(
          message.conflictingCheckpoint,
        );
      }
      if (message.localCheckpoint !== undefined) {
        obj.localCheckpoint = RawCheckpointWithMeta.toJSON(
          message.localCheckpoint,
        );
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<EventConflictingCheckpoint>, I>>(
      base?: I,
    ): EventConflictingCheckpoint {
      return EventConflictingCheckpoint.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<EventConflictingCheckpoint>, I>>(
      object: I,
    ): EventConflictingCheckpoint {
      const message = createBaseEventConflictingCheckpoint();
      message.conflictingCheckpoint =
        object.conflictingCheckpoint !== undefined &&
        object.conflictingCheckpoint !== null
          ? RawCheckpoint.fromPartial(object.conflictingCheckpoint)
          : undefined;
      message.localCheckpoint =
        object.localCheckpoint !== undefined && object.localCheckpoint !== null
          ? RawCheckpointWithMeta.fromPartial(object.localCheckpoint)
          : undefined;
      return message;
    },
  };

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
