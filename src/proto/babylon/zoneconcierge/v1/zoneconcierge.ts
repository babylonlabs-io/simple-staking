// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: babylon/zoneconcierge/v1/zoneconcierge.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { ProofOps } from "../../../tendermint/crypto/proof";
import {
  SubmissionKey,
  TransactionInfo,
} from "../../btccheckpoint/v1/btccheckpoint";
import { BTCHeaderInfo } from "../../btclightclient/v1/btclightclient";
import { ValidatorWithBlsKey } from "../../checkpointing/v1/bls_key";
import { RawCheckpoint } from "../../checkpointing/v1/checkpoint";
import { Epoch } from "../../epoching/v1/epoching";

export const protobufPackage = "babylon.zoneconcierge.v1";

/** IndexedHeader is the metadata of a CZ header */
export interface IndexedHeader {
  /** chain_id is the unique ID of the chain */
  chainId: string;
  /** hash is the hash of this header */
  hash: Uint8Array;
  /**
   * height is the height of this header on CZ ledger
   * (hash, height) jointly provides the position of the header on CZ ledger
   */
  height: number;
  /**
   * time is the timestamp of this header on CZ ledger
   * it is needed for CZ to unbond all mature validators/delegations
   * before this timestamp when this header is BTC-finalised
   */
  time: Date | undefined;
  /**
   * babylon_header_hash is the hash of the babylon block that includes this CZ
   * header
   */
  babylonHeaderHash: Uint8Array;
  /**
   * babylon_header_height is the height of the babylon block that includes this CZ
   * header
   */
  babylonHeaderHeight: number;
  /** epoch is the epoch number of this header on Babylon ledger */
  babylonEpoch: number;
  /**
   * babylon_tx_hash is the hash of the tx that includes this header
   * (babylon_block_height, babylon_tx_hash) jointly provides the position of
   * the header on Babylon ledger
   */
  babylonTxHash: Uint8Array;
}

/**
 * Forks is a list of non-canonical `IndexedHeader`s at the same height.
 * For example, assuming the following blockchain
 * ```
 * A <- B <- C <- D <- E
 *            \ -- D1
 *            \ -- D2
 * ```
 * Then the fork will be {[D1, D2]} where each item is in struct `IndexedBlock`.
 *
 * Note that each `IndexedHeader` in the fork should have a valid quorum
 * certificate. Such forks exist since Babylon considers CZs might have
 * dishonest majority. Also note that the IBC-Go implementation will only
 * consider the first header in a fork valid, since the subsequent headers
 * cannot be verified without knowing the validator set in the previous header.
 */
export interface Forks {
  /** blocks is the list of non-canonical indexed headers at the same height */
  headers: IndexedHeader[];
}

/** ChainInfo is the information of a CZ */
export interface ChainInfo {
  /** chain_id is the ID of the chain */
  chainId: string;
  /** latest_header is the latest header in CZ's canonical chain */
  latestHeader: IndexedHeader | undefined;
  /**
   * latest_forks is the latest forks, formed as a series of IndexedHeader (from
   * low to high)
   */
  latestForks: Forks | undefined;
  /**
   * timestamped_headers_count is the number of timestamped headers in CZ's
   * canonical chain
   */
  timestampedHeadersCount: number;
}

/**
 * ChainInfoWithProof is the chain info with a proof that the latest header in
 * the chain info is included in the epoch
 */
export interface ChainInfoWithProof {
  chainInfo: ChainInfo | undefined;
  /**
   * proof_header_in_epoch is an inclusion proof that the latest_header in chain_info
   * is committed  to `app_hash` of the sealer header of latest_header.babylon_epoch
   * this field is optional
   */
  proofHeaderInEpoch: ProofOps | undefined;
}

/** FinalizedChainInfo is the information of a CZ that is BTC-finalised */
export interface FinalizedChainInfo {
  /** chain_id is the ID of the chain */
  chainId: string;
  /** finalized_chain_info is the info of the CZ */
  finalizedChainInfo: ChainInfo | undefined;
  /** epoch_info is the metadata of the last BTC-finalised epoch */
  epochInfo: Epoch | undefined;
  /** raw_checkpoint is the raw checkpoint of this epoch */
  rawCheckpoint: RawCheckpoint | undefined;
  /**
   * btc_submission_key is position of two BTC txs that include the raw
   * checkpoint of this epoch
   */
  btcSubmissionKey: SubmissionKey | undefined;
  /** proof is the proof that the chain info is finalized */
  proof: ProofFinalizedChainInfo | undefined;
}

/**
 * ProofEpochSealed is the proof that an epoch is sealed by the sealer header,
 * i.e., the 2nd header of the next epoch With the access of metadata
 * - Metadata of this epoch, which includes the sealer header
 * - Raw checkpoint of this epoch
 * The verifier can perform the following verification rules:
 * - The raw checkpoint's `app_hash` is same as in the sealer header
 * - More than 2/3 (in voting power) validators in the validator set of this
 * epoch have signed `app_hash` of the sealer header
 * - The epoch metadata is committed to the `app_hash` of the sealer header
 * - The validator set is committed to the `app_hash` of the sealer header
 */
export interface ProofEpochSealed {
  /**
   * validator_set is the validator set of the sealed epoch
   * This validator set has generated a BLS multisig on `app_hash` of
   * the sealer header
   */
  validatorSet: ValidatorWithBlsKey[];
  /**
   * proof_epoch_info is the Merkle proof that the epoch's metadata is committed
   * to `app_hash` of the sealer header
   */
  proofEpochInfo: ProofOps | undefined;
  /**
   * proof_epoch_info is the Merkle proof that the epoch's validator set is
   * committed to `app_hash` of the sealer header
   */
  proofEpochValSet: ProofOps | undefined;
}

/**
 * ProofFinalizedChainInfo is a set of proofs that attest a chain info is
 * BTC-finalised
 */
export interface ProofFinalizedChainInfo {
  /**
   * proof_cz_header_in_epoch is the proof that the CZ header is timestamped
   * within a certain epoch
   */
  proofCzHeaderInEpoch: ProofOps | undefined;
  /** proof_epoch_sealed is the proof that the epoch is sealed */
  proofEpochSealed: ProofEpochSealed | undefined;
  /**
   * proof_epoch_submitted is the proof that the epoch's checkpoint is included
   * in BTC ledger It is the two TransactionInfo in the best (i.e., earliest)
   * checkpoint submission
   */
  proofEpochSubmitted: TransactionInfo[];
}

/** Btc light client chain segment grown during last finalized epoch */
export interface BTCChainSegment {
  btcHeaders: BTCHeaderInfo[];
}

function createBaseIndexedHeader(): IndexedHeader {
  return {
    chainId: "",
    hash: new Uint8Array(0),
    height: 0,
    time: undefined,
    babylonHeaderHash: new Uint8Array(0),
    babylonHeaderHeight: 0,
    babylonEpoch: 0,
    babylonTxHash: new Uint8Array(0),
  };
}

export const IndexedHeader: MessageFns<IndexedHeader> = {
  encode(
    message: IndexedHeader,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.hash.length !== 0) {
      writer.uint32(18).bytes(message.hash);
    }
    if (message.height !== 0) {
      writer.uint32(24).uint64(message.height);
    }
    if (message.time !== undefined) {
      Timestamp.encode(
        toTimestamp(message.time),
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.babylonHeaderHash.length !== 0) {
      writer.uint32(42).bytes(message.babylonHeaderHash);
    }
    if (message.babylonHeaderHeight !== 0) {
      writer.uint32(48).uint64(message.babylonHeaderHeight);
    }
    if (message.babylonEpoch !== 0) {
      writer.uint32(56).uint64(message.babylonEpoch);
    }
    if (message.babylonTxHash.length !== 0) {
      writer.uint32(66).bytes(message.babylonTxHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexedHeader {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexedHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hash = reader.bytes();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.time = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.babylonHeaderHash = reader.bytes();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.babylonHeaderHeight = longToNumber(reader.uint64());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.babylonEpoch = longToNumber(reader.uint64());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.babylonTxHash = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndexedHeader {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      hash: isSet(object.hash)
        ? bytesFromBase64(object.hash)
        : new Uint8Array(0),
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,
      babylonHeaderHash: isSet(object.babylonHeaderHash)
        ? bytesFromBase64(object.babylonHeaderHash)
        : new Uint8Array(0),
      babylonHeaderHeight: isSet(object.babylonHeaderHeight)
        ? globalThis.Number(object.babylonHeaderHeight)
        : 0,
      babylonEpoch: isSet(object.babylonEpoch)
        ? globalThis.Number(object.babylonEpoch)
        : 0,
      babylonTxHash: isSet(object.babylonTxHash)
        ? bytesFromBase64(object.babylonTxHash)
        : new Uint8Array(0),
    };
  },

  toJSON(message: IndexedHeader): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.time !== undefined) {
      obj.time = message.time.toISOString();
    }
    if (message.babylonHeaderHash.length !== 0) {
      obj.babylonHeaderHash = base64FromBytes(message.babylonHeaderHash);
    }
    if (message.babylonHeaderHeight !== 0) {
      obj.babylonHeaderHeight = Math.round(message.babylonHeaderHeight);
    }
    if (message.babylonEpoch !== 0) {
      obj.babylonEpoch = Math.round(message.babylonEpoch);
    }
    if (message.babylonTxHash.length !== 0) {
      obj.babylonTxHash = base64FromBytes(message.babylonTxHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IndexedHeader>, I>>(
    base?: I,
  ): IndexedHeader {
    return IndexedHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IndexedHeader>, I>>(
    object: I,
  ): IndexedHeader {
    const message = createBaseIndexedHeader();
    message.chainId = object.chainId ?? "";
    message.hash = object.hash ?? new Uint8Array(0);
    message.height = object.height ?? 0;
    message.time = object.time ?? undefined;
    message.babylonHeaderHash = object.babylonHeaderHash ?? new Uint8Array(0);
    message.babylonHeaderHeight = object.babylonHeaderHeight ?? 0;
    message.babylonEpoch = object.babylonEpoch ?? 0;
    message.babylonTxHash = object.babylonTxHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseForks(): Forks {
  return { headers: [] };
}

export const Forks: MessageFns<Forks> = {
  encode(
    message: Forks,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.headers) {
      IndexedHeader.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Forks {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForks();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.headers.push(IndexedHeader.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Forks {
    return {
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => IndexedHeader.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Forks): unknown {
    const obj: any = {};
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => IndexedHeader.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Forks>, I>>(base?: I): Forks {
    return Forks.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Forks>, I>>(object: I): Forks {
    const message = createBaseForks();
    message.headers =
      object.headers?.map((e) => IndexedHeader.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChainInfo(): ChainInfo {
  return {
    chainId: "",
    latestHeader: undefined,
    latestForks: undefined,
    timestampedHeadersCount: 0,
  };
}

export const ChainInfo: MessageFns<ChainInfo> = {
  encode(
    message: ChainInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.latestHeader !== undefined) {
      IndexedHeader.encode(
        message.latestHeader,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.latestForks !== undefined) {
      Forks.encode(message.latestForks, writer.uint32(26).fork()).join();
    }
    if (message.timestampedHeadersCount !== 0) {
      writer.uint32(32).uint64(message.timestampedHeadersCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainInfo {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestHeader = IndexedHeader.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.latestForks = Forks.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timestampedHeadersCount = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainInfo {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      latestHeader: isSet(object.latestHeader)
        ? IndexedHeader.fromJSON(object.latestHeader)
        : undefined,
      latestForks: isSet(object.latestForks)
        ? Forks.fromJSON(object.latestForks)
        : undefined,
      timestampedHeadersCount: isSet(object.timestampedHeadersCount)
        ? globalThis.Number(object.timestampedHeadersCount)
        : 0,
    };
  },

  toJSON(message: ChainInfo): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.latestHeader !== undefined) {
      obj.latestHeader = IndexedHeader.toJSON(message.latestHeader);
    }
    if (message.latestForks !== undefined) {
      obj.latestForks = Forks.toJSON(message.latestForks);
    }
    if (message.timestampedHeadersCount !== 0) {
      obj.timestampedHeadersCount = Math.round(message.timestampedHeadersCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainInfo>, I>>(base?: I): ChainInfo {
    return ChainInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainInfo>, I>>(
    object: I,
  ): ChainInfo {
    const message = createBaseChainInfo();
    message.chainId = object.chainId ?? "";
    message.latestHeader =
      object.latestHeader !== undefined && object.latestHeader !== null
        ? IndexedHeader.fromPartial(object.latestHeader)
        : undefined;
    message.latestForks =
      object.latestForks !== undefined && object.latestForks !== null
        ? Forks.fromPartial(object.latestForks)
        : undefined;
    message.timestampedHeadersCount = object.timestampedHeadersCount ?? 0;
    return message;
  },
};

function createBaseChainInfoWithProof(): ChainInfoWithProof {
  return { chainInfo: undefined, proofHeaderInEpoch: undefined };
}

export const ChainInfoWithProof: MessageFns<ChainInfoWithProof> = {
  encode(
    message: ChainInfoWithProof,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.chainInfo !== undefined) {
      ChainInfo.encode(message.chainInfo, writer.uint32(10).fork()).join();
    }
    if (message.proofHeaderInEpoch !== undefined) {
      ProofOps.encode(
        message.proofHeaderInEpoch,
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ChainInfoWithProof {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainInfoWithProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainInfo = ChainInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.proofHeaderInEpoch = ProofOps.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainInfoWithProof {
    return {
      chainInfo: isSet(object.chainInfo)
        ? ChainInfo.fromJSON(object.chainInfo)
        : undefined,
      proofHeaderInEpoch: isSet(object.proofHeaderInEpoch)
        ? ProofOps.fromJSON(object.proofHeaderInEpoch)
        : undefined,
    };
  },

  toJSON(message: ChainInfoWithProof): unknown {
    const obj: any = {};
    if (message.chainInfo !== undefined) {
      obj.chainInfo = ChainInfo.toJSON(message.chainInfo);
    }
    if (message.proofHeaderInEpoch !== undefined) {
      obj.proofHeaderInEpoch = ProofOps.toJSON(message.proofHeaderInEpoch);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainInfoWithProof>, I>>(
    base?: I,
  ): ChainInfoWithProof {
    return ChainInfoWithProof.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainInfoWithProof>, I>>(
    object: I,
  ): ChainInfoWithProof {
    const message = createBaseChainInfoWithProof();
    message.chainInfo =
      object.chainInfo !== undefined && object.chainInfo !== null
        ? ChainInfo.fromPartial(object.chainInfo)
        : undefined;
    message.proofHeaderInEpoch =
      object.proofHeaderInEpoch !== undefined &&
      object.proofHeaderInEpoch !== null
        ? ProofOps.fromPartial(object.proofHeaderInEpoch)
        : undefined;
    return message;
  },
};

function createBaseFinalizedChainInfo(): FinalizedChainInfo {
  return {
    chainId: "",
    finalizedChainInfo: undefined,
    epochInfo: undefined,
    rawCheckpoint: undefined,
    btcSubmissionKey: undefined,
    proof: undefined,
  };
}

export const FinalizedChainInfo: MessageFns<FinalizedChainInfo> = {
  encode(
    message: FinalizedChainInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.finalizedChainInfo !== undefined) {
      ChainInfo.encode(
        message.finalizedChainInfo,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.epochInfo !== undefined) {
      Epoch.encode(message.epochInfo, writer.uint32(26).fork()).join();
    }
    if (message.rawCheckpoint !== undefined) {
      RawCheckpoint.encode(
        message.rawCheckpoint,
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.btcSubmissionKey !== undefined) {
      SubmissionKey.encode(
        message.btcSubmissionKey,
        writer.uint32(42).fork(),
      ).join();
    }
    if (message.proof !== undefined) {
      ProofFinalizedChainInfo.encode(
        message.proof,
        writer.uint32(50).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): FinalizedChainInfo {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizedChainInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.finalizedChainInfo = ChainInfo.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.epochInfo = Epoch.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rawCheckpoint = RawCheckpoint.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.btcSubmissionKey = SubmissionKey.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.proof = ProofFinalizedChainInfo.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizedChainInfo {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      finalizedChainInfo: isSet(object.finalizedChainInfo)
        ? ChainInfo.fromJSON(object.finalizedChainInfo)
        : undefined,
      epochInfo: isSet(object.epochInfo)
        ? Epoch.fromJSON(object.epochInfo)
        : undefined,
      rawCheckpoint: isSet(object.rawCheckpoint)
        ? RawCheckpoint.fromJSON(object.rawCheckpoint)
        : undefined,
      btcSubmissionKey: isSet(object.btcSubmissionKey)
        ? SubmissionKey.fromJSON(object.btcSubmissionKey)
        : undefined,
      proof: isSet(object.proof)
        ? ProofFinalizedChainInfo.fromJSON(object.proof)
        : undefined,
    };
  },

  toJSON(message: FinalizedChainInfo): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.finalizedChainInfo !== undefined) {
      obj.finalizedChainInfo = ChainInfo.toJSON(message.finalizedChainInfo);
    }
    if (message.epochInfo !== undefined) {
      obj.epochInfo = Epoch.toJSON(message.epochInfo);
    }
    if (message.rawCheckpoint !== undefined) {
      obj.rawCheckpoint = RawCheckpoint.toJSON(message.rawCheckpoint);
    }
    if (message.btcSubmissionKey !== undefined) {
      obj.btcSubmissionKey = SubmissionKey.toJSON(message.btcSubmissionKey);
    }
    if (message.proof !== undefined) {
      obj.proof = ProofFinalizedChainInfo.toJSON(message.proof);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FinalizedChainInfo>, I>>(
    base?: I,
  ): FinalizedChainInfo {
    return FinalizedChainInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FinalizedChainInfo>, I>>(
    object: I,
  ): FinalizedChainInfo {
    const message = createBaseFinalizedChainInfo();
    message.chainId = object.chainId ?? "";
    message.finalizedChainInfo =
      object.finalizedChainInfo !== undefined &&
      object.finalizedChainInfo !== null
        ? ChainInfo.fromPartial(object.finalizedChainInfo)
        : undefined;
    message.epochInfo =
      object.epochInfo !== undefined && object.epochInfo !== null
        ? Epoch.fromPartial(object.epochInfo)
        : undefined;
    message.rawCheckpoint =
      object.rawCheckpoint !== undefined && object.rawCheckpoint !== null
        ? RawCheckpoint.fromPartial(object.rawCheckpoint)
        : undefined;
    message.btcSubmissionKey =
      object.btcSubmissionKey !== undefined && object.btcSubmissionKey !== null
        ? SubmissionKey.fromPartial(object.btcSubmissionKey)
        : undefined;
    message.proof =
      object.proof !== undefined && object.proof !== null
        ? ProofFinalizedChainInfo.fromPartial(object.proof)
        : undefined;
    return message;
  },
};

function createBaseProofEpochSealed(): ProofEpochSealed {
  return {
    validatorSet: [],
    proofEpochInfo: undefined,
    proofEpochValSet: undefined,
  };
}

export const ProofEpochSealed: MessageFns<ProofEpochSealed> = {
  encode(
    message: ProofEpochSealed,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.validatorSet) {
      ValidatorWithBlsKey.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.proofEpochInfo !== undefined) {
      ProofOps.encode(message.proofEpochInfo, writer.uint32(18).fork()).join();
    }
    if (message.proofEpochValSet !== undefined) {
      ProofOps.encode(
        message.proofEpochValSet,
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProofEpochSealed {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProofEpochSealed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.validatorSet.push(
            ValidatorWithBlsKey.decode(reader, reader.uint32()),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.proofEpochInfo = ProofOps.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.proofEpochValSet = ProofOps.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProofEpochSealed {
    return {
      validatorSet: globalThis.Array.isArray(object?.validatorSet)
        ? object.validatorSet.map((e: any) => ValidatorWithBlsKey.fromJSON(e))
        : [],
      proofEpochInfo: isSet(object.proofEpochInfo)
        ? ProofOps.fromJSON(object.proofEpochInfo)
        : undefined,
      proofEpochValSet: isSet(object.proofEpochValSet)
        ? ProofOps.fromJSON(object.proofEpochValSet)
        : undefined,
    };
  },

  toJSON(message: ProofEpochSealed): unknown {
    const obj: any = {};
    if (message.validatorSet?.length) {
      obj.validatorSet = message.validatorSet.map((e) =>
        ValidatorWithBlsKey.toJSON(e),
      );
    }
    if (message.proofEpochInfo !== undefined) {
      obj.proofEpochInfo = ProofOps.toJSON(message.proofEpochInfo);
    }
    if (message.proofEpochValSet !== undefined) {
      obj.proofEpochValSet = ProofOps.toJSON(message.proofEpochValSet);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProofEpochSealed>, I>>(
    base?: I,
  ): ProofEpochSealed {
    return ProofEpochSealed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProofEpochSealed>, I>>(
    object: I,
  ): ProofEpochSealed {
    const message = createBaseProofEpochSealed();
    message.validatorSet =
      object.validatorSet?.map((e) => ValidatorWithBlsKey.fromPartial(e)) || [];
    message.proofEpochInfo =
      object.proofEpochInfo !== undefined && object.proofEpochInfo !== null
        ? ProofOps.fromPartial(object.proofEpochInfo)
        : undefined;
    message.proofEpochValSet =
      object.proofEpochValSet !== undefined && object.proofEpochValSet !== null
        ? ProofOps.fromPartial(object.proofEpochValSet)
        : undefined;
    return message;
  },
};

function createBaseProofFinalizedChainInfo(): ProofFinalizedChainInfo {
  return {
    proofCzHeaderInEpoch: undefined,
    proofEpochSealed: undefined,
    proofEpochSubmitted: [],
  };
}

export const ProofFinalizedChainInfo: MessageFns<ProofFinalizedChainInfo> = {
  encode(
    message: ProofFinalizedChainInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.proofCzHeaderInEpoch !== undefined) {
      ProofOps.encode(
        message.proofCzHeaderInEpoch,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.proofEpochSealed !== undefined) {
      ProofEpochSealed.encode(
        message.proofEpochSealed,
        writer.uint32(18).fork(),
      ).join();
    }
    for (const v of message.proofEpochSubmitted) {
      TransactionInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ProofFinalizedChainInfo {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProofFinalizedChainInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.proofCzHeaderInEpoch = ProofOps.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.proofEpochSealed = ProofEpochSealed.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.proofEpochSubmitted.push(
            TransactionInfo.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProofFinalizedChainInfo {
    return {
      proofCzHeaderInEpoch: isSet(object.proofCzHeaderInEpoch)
        ? ProofOps.fromJSON(object.proofCzHeaderInEpoch)
        : undefined,
      proofEpochSealed: isSet(object.proofEpochSealed)
        ? ProofEpochSealed.fromJSON(object.proofEpochSealed)
        : undefined,
      proofEpochSubmitted: globalThis.Array.isArray(object?.proofEpochSubmitted)
        ? object.proofEpochSubmitted.map((e: any) =>
            TransactionInfo.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: ProofFinalizedChainInfo): unknown {
    const obj: any = {};
    if (message.proofCzHeaderInEpoch !== undefined) {
      obj.proofCzHeaderInEpoch = ProofOps.toJSON(message.proofCzHeaderInEpoch);
    }
    if (message.proofEpochSealed !== undefined) {
      obj.proofEpochSealed = ProofEpochSealed.toJSON(message.proofEpochSealed);
    }
    if (message.proofEpochSubmitted?.length) {
      obj.proofEpochSubmitted = message.proofEpochSubmitted.map((e) =>
        TransactionInfo.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProofFinalizedChainInfo>, I>>(
    base?: I,
  ): ProofFinalizedChainInfo {
    return ProofFinalizedChainInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProofFinalizedChainInfo>, I>>(
    object: I,
  ): ProofFinalizedChainInfo {
    const message = createBaseProofFinalizedChainInfo();
    message.proofCzHeaderInEpoch =
      object.proofCzHeaderInEpoch !== undefined &&
      object.proofCzHeaderInEpoch !== null
        ? ProofOps.fromPartial(object.proofCzHeaderInEpoch)
        : undefined;
    message.proofEpochSealed =
      object.proofEpochSealed !== undefined && object.proofEpochSealed !== null
        ? ProofEpochSealed.fromPartial(object.proofEpochSealed)
        : undefined;
    message.proofEpochSubmitted =
      object.proofEpochSubmitted?.map((e) => TransactionInfo.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseBTCChainSegment(): BTCChainSegment {
  return { btcHeaders: [] };
}

export const BTCChainSegment: MessageFns<BTCChainSegment> = {
  encode(
    message: BTCChainSegment,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.btcHeaders) {
      BTCHeaderInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BTCChainSegment {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCChainSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.btcHeaders.push(
            BTCHeaderInfo.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCChainSegment {
    return {
      btcHeaders: globalThis.Array.isArray(object?.btcHeaders)
        ? object.btcHeaders.map((e: any) => BTCHeaderInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BTCChainSegment): unknown {
    const obj: any = {};
    if (message.btcHeaders?.length) {
      obj.btcHeaders = message.btcHeaders.map((e) => BTCHeaderInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BTCChainSegment>, I>>(
    base?: I,
  ): BTCChainSegment {
    return BTCChainSegment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BTCChainSegment>, I>>(
    object: I,
  ): BTCChainSegment {
    const message = createBaseBTCChainSegment();
    message.btcHeaders =
      object.btcHeaders?.map((e) => BTCHeaderInfo.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
