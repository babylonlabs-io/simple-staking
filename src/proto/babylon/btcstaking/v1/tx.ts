// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: babylon/btcstaking/v1/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Description } from "../../../cosmos/staking/v1beta1/staking";
import { InclusionProof } from "./btcstaking";
import { Params } from "./params";
import { ProofOfPossessionBTC } from "./pop";

export const protobufPackage = "babylon.btcstaking.v1";

/** MsgCreateFinalityProvider is the message for creating a finality provider */
export interface MsgCreateFinalityProvider {
  /**
   * addr defines the address of the finality provider that will receive
   * the commissions to all the delegations.
   */
  addr: string;
  /** description defines the description terms for the finality provider */
  description: Description | undefined;
  /** commission defines the commission rate of the finality provider */
  commission: string;
  /**
   * btc_pk is the Bitcoin secp256k1 PK of this finality provider
   * the PK follows encoding in BIP-340 spec
   */
  btcPk: Uint8Array;
  /** pop is the proof of possession of btc_pk over the FP signer address. */
  pop: ProofOfPossessionBTC | undefined;
}

/** MsgCreateFinalityProviderResponse is the response for MsgCreateFinalityProvider */
export interface MsgCreateFinalityProviderResponse {}

/** MsgEditFinalityProvider is the message for editing an existing finality provider */
export interface MsgEditFinalityProvider {
  /** addr the address of the finality provider that whishes to edit his information. */
  addr: string;
  /** btc_pk is the Bitcoin secp256k1 PK of the finality provider to be edited */
  btcPk: Uint8Array;
  /** description defines the updated description terms for the finality provider */
  description: Description | undefined;
  /** commission defines the updated commission rate of the finality provider */
  commission: string;
}

/** MsgEditFinalityProviderResponse is the response for MsgEditFinalityProvider */
export interface MsgEditFinalityProviderResponse {}

/** MsgCreateBTCDelegation is the message for creating a BTC delegation */
export interface MsgCreateBTCDelegation {
  /** staker_addr is the address to receive rewards from BTC delegation. */
  stakerAddr: string;
  /** pop is the proof of possession of btc_pk by the staker_addr. */
  pop: ProofOfPossessionBTC | undefined;
  /** btc_pk is the Bitcoin secp256k1 PK of the BTC delegator */
  btcPk: Uint8Array;
  /**
   * fp_btc_pk_list is the list of Bitcoin secp256k1 PKs of the finality providers, if there is more than one
   * finality provider pk it means that delegation is re-staked
   */
  fpBtcPkList: Uint8Array[];
  /** staking_time is the time lock used in staking transaction */
  stakingTime: number;
  /** staking_value  is the amount of satoshis locked in staking output */
  stakingValue: number;
  /** staking_tx is a bitcoin staking transaction i.e transaction that locks funds */
  stakingTx: Uint8Array;
  /** staking_tx_inclusion_proof is the inclusion proof of the staking tx in BTC chain */
  stakingTxInclusionProof: InclusionProof | undefined;
  /**
   * slashing_tx is the slashing tx
   * Note that the tx itself does not contain signatures, which are off-chain.
   */
  slashingTx: Uint8Array;
  /**
   * delegator_slashing_sig is the signature on the slashing tx by the delegator (i.e., SK corresponding to btc_pk).
   * It will be a part of the witness for the staking tx output.
   * The staking tx output further needs signatures from covenant and finality provider in
   * order to be spendable.
   */
  delegatorSlashingSig: Uint8Array;
  /**
   * unbonding_time is the time lock used when funds are being unbonded. It is be used in:
   * - unbonding transaction, time lock spending path
   * - staking slashing transaction, change output
   * - unbonding slashing transaction, change output
   * It must be smaller than math.MaxUInt16 and larger that max(MinUnbondingTime, CheckpointFinalizationTimeout)
   */
  unbondingTime: number;
  /**
   * fields related to unbonding transaction
   * unbonding_tx is a bitcoin unbonding transaction i.e transaction that spends
   * staking output and sends it to the unbonding output
   */
  unbondingTx: Uint8Array;
  /**
   * unbonding_value is amount of satoshis locked in unbonding output.
   * NOTE: staking_value and unbonding_value could be different because of the difference between the fee for staking tx and that for unbonding
   */
  unbondingValue: number;
  /**
   * unbonding_slashing_tx is the slashing tx which slash unbonding contract
   * Note that the tx itself does not contain signatures, which are off-chain.
   */
  unbondingSlashingTx: Uint8Array;
  /** delegator_unbonding_slashing_sig is the signature on the slashing tx by the delegator (i.e., SK corresponding to btc_pk). */
  delegatorUnbondingSlashingSig: Uint8Array;
}

/** MsgCreateBTCDelegationResponse is the response for MsgCreateBTCDelegation */
export interface MsgCreateBTCDelegationResponse {}

/** MsgAddBTCDelegationInclusionProof is the message for adding proof of inclusion of BTC delegation on BTC chain */
export interface MsgAddBTCDelegationInclusionProof {
  signer: string;
  /**
   * staking_tx_hash is the hash of the staking tx.
   * It uniquely identifies a BTC delegation
   */
  stakingTxHash: string;
  /** staking_tx_inclusion_proof is the inclusion proof of the staking tx in BTC chain */
  stakingTxInclusionProof: InclusionProof | undefined;
}

/** MsgAddBTCDelegationInclusionProofResponse is the response for MsgAddBTCDelegationInclusionProof */
export interface MsgAddBTCDelegationInclusionProofResponse {}

/** MsgAddCovenantSigs is the message for handling signatures from a covenant member */
export interface MsgAddCovenantSigs {
  signer: string;
  /** pk is the BTC public key of the covenant member */
  pk: Uint8Array;
  /**
   * staking_tx_hash is the hash of the staking tx.
   * It uniquely identifies a BTC delegation
   */
  stakingTxHash: string;
  /**
   * sigs is a list of adaptor signatures of the covenant
   * the order of sigs should respect the order of finality providers
   * of the corresponding delegation
   */
  slashingTxSigs: Uint8Array[];
  /**
   * unbonding_tx_sig is the signature of the covenant on the unbonding tx submitted to babylon
   * the signature follows encoding in BIP-340 spec
   */
  unbondingTxSig: Uint8Array;
  /**
   * slashing_unbonding_tx_sigs is a list of adaptor signatures of the covenant
   * on slashing tx corresponding to unbonding tx submitted to babylon
   * the order of sigs should respect the order of finality providers
   * of the corresponding delegation
   */
  slashingUnbondingTxSigs: Uint8Array[];
}

/** MsgAddCovenantSigsResponse is the response for MsgAddCovenantSigs */
export interface MsgAddCovenantSigsResponse {}

/**
 * MsgBTCUndelegate is the message for handling signature on unbonding tx
 * from its delegator. This signature effectively proves that the delegator
 * wants to unbond this BTC delegation
 */
export interface MsgBTCUndelegate {
  signer: string;
  /**
   * staking_tx_hash is the hash of the staking tx.
   * It uniquely identifies a BTC delegation
   */
  stakingTxHash: string;
  /**
   * unbonding_tx_sig is the signature of the staker on the unbonding tx submitted to babylon
   * the signature follows encoding in BIP-340 spec
   */
  unbondingTxSig: Uint8Array;
}

/** MsgBTCUndelegateResponse is the response for MsgBTCUndelegate */
export interface MsgBTCUndelegateResponse {}

/**
 * MsgSelectiveSlashingEvidence is the message for handling evidence of selective slashing
 * launched by a finality provider
 */
export interface MsgSelectiveSlashingEvidence {
  signer: string;
  /**
   * staking_tx_hash is the hash of the staking tx.
   * It uniquely identifies a BTC delegation
   */
  stakingTxHash: string;
  /**
   * recovered_fp_btc_sk is the BTC SK of the finality provider who
   * launches the selective slashing offence. The SK is recovered by
   * using a covenant adaptor signature and the corresponding Schnorr
   * signature
   */
  recoveredFpBtcSk: Uint8Array;
}

/** MsgSelectiveSlashingEvidenceResponse is the response for MsgSelectiveSlashingEvidence */
export interface MsgSelectiveSlashingEvidenceResponse {}

/** MsgUpdateParams defines a message for updating btcstaking module parameters. */
export interface MsgUpdateParams {
  /**
   * authority is the address of the governance account.
   * just FYI: cosmos.AddressString marks that this field should use type alias
   * for AddressString instead of string, but the functionality is not yet implemented
   * in cosmos-proto
   */
  authority: string;
  /**
   * params defines the finality parameters to update.
   *
   * NOTE: All parameters must be supplied.
   */
  params: Params | undefined;
}

/** MsgUpdateParamsResponse is the response to the MsgUpdateParams message. */
export interface MsgUpdateParamsResponse {}

function createBaseMsgCreateFinalityProvider(): MsgCreateFinalityProvider {
  return {
    addr: "",
    description: undefined,
    commission: "",
    btcPk: new Uint8Array(0),
    pop: undefined,
  };
}

export const MsgCreateFinalityProvider: MessageFns<MsgCreateFinalityProvider> =
  {
    encode(
      message: MsgCreateFinalityProvider,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.addr !== "") {
        writer.uint32(10).string(message.addr);
      }
      if (message.description !== undefined) {
        Description.encode(
          message.description,
          writer.uint32(18).fork(),
        ).join();
      }
      if (message.commission !== "") {
        writer.uint32(26).string(message.commission);
      }
      if (message.btcPk.length !== 0) {
        writer.uint32(34).bytes(message.btcPk);
      }
      if (message.pop !== undefined) {
        ProofOfPossessionBTC.encode(
          message.pop,
          writer.uint32(42).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): MsgCreateFinalityProvider {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgCreateFinalityProvider();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.addr = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.description = Description.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }

            message.commission = reader.string();
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }

            message.btcPk = reader.bytes();
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }

            message.pop = ProofOfPossessionBTC.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): MsgCreateFinalityProvider {
      return {
        addr: isSet(object.addr) ? globalThis.String(object.addr) : "",
        description: isSet(object.description)
          ? Description.fromJSON(object.description)
          : undefined,
        commission: isSet(object.commission)
          ? globalThis.String(object.commission)
          : "",
        btcPk: isSet(object.btcPk)
          ? bytesFromBase64(object.btcPk)
          : new Uint8Array(0),
        pop: isSet(object.pop)
          ? ProofOfPossessionBTC.fromJSON(object.pop)
          : undefined,
      };
    },

    toJSON(message: MsgCreateFinalityProvider): unknown {
      const obj: any = {};
      if (message.addr !== "") {
        obj.addr = message.addr;
      }
      if (message.description !== undefined) {
        obj.description = Description.toJSON(message.description);
      }
      if (message.commission !== "") {
        obj.commission = message.commission;
      }
      if (message.btcPk.length !== 0) {
        obj.btcPk = base64FromBytes(message.btcPk);
      }
      if (message.pop !== undefined) {
        obj.pop = ProofOfPossessionBTC.toJSON(message.pop);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<MsgCreateFinalityProvider>, I>>(
      base?: I,
    ): MsgCreateFinalityProvider {
      return MsgCreateFinalityProvider.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<MsgCreateFinalityProvider>, I>>(
      object: I,
    ): MsgCreateFinalityProvider {
      const message = createBaseMsgCreateFinalityProvider();
      message.addr = object.addr ?? "";
      message.description =
        object.description !== undefined && object.description !== null
          ? Description.fromPartial(object.description)
          : undefined;
      message.commission = object.commission ?? "";
      message.btcPk = object.btcPk ?? new Uint8Array(0);
      message.pop =
        object.pop !== undefined && object.pop !== null
          ? ProofOfPossessionBTC.fromPartial(object.pop)
          : undefined;
      return message;
    },
  };

function createBaseMsgCreateFinalityProviderResponse(): MsgCreateFinalityProviderResponse {
  return {};
}

export const MsgCreateFinalityProviderResponse: MessageFns<MsgCreateFinalityProviderResponse> =
  {
    encode(
      _: MsgCreateFinalityProviderResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): MsgCreateFinalityProviderResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgCreateFinalityProviderResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): MsgCreateFinalityProviderResponse {
      return {};
    },

    toJSON(_: MsgCreateFinalityProviderResponse): unknown {
      const obj: any = {};
      return obj;
    },

    create<I extends Exact<DeepPartial<MsgCreateFinalityProviderResponse>, I>>(
      base?: I,
    ): MsgCreateFinalityProviderResponse {
      return MsgCreateFinalityProviderResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<MsgCreateFinalityProviderResponse>, I>,
    >(_: I): MsgCreateFinalityProviderResponse {
      const message = createBaseMsgCreateFinalityProviderResponse();
      return message;
    },
  };

function createBaseMsgEditFinalityProvider(): MsgEditFinalityProvider {
  return {
    addr: "",
    btcPk: new Uint8Array(0),
    description: undefined,
    commission: "",
  };
}

export const MsgEditFinalityProvider: MessageFns<MsgEditFinalityProvider> = {
  encode(
    message: MsgEditFinalityProvider,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.addr !== "") {
      writer.uint32(10).string(message.addr);
    }
    if (message.btcPk.length !== 0) {
      writer.uint32(18).bytes(message.btcPk);
    }
    if (message.description !== undefined) {
      Description.encode(message.description, writer.uint32(26).fork()).join();
    }
    if (message.commission !== "") {
      writer.uint32(34).string(message.commission);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MsgEditFinalityProvider {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEditFinalityProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.addr = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.btcPk = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = Description.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.commission = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgEditFinalityProvider {
    return {
      addr: isSet(object.addr) ? globalThis.String(object.addr) : "",
      btcPk: isSet(object.btcPk)
        ? bytesFromBase64(object.btcPk)
        : new Uint8Array(0),
      description: isSet(object.description)
        ? Description.fromJSON(object.description)
        : undefined,
      commission: isSet(object.commission)
        ? globalThis.String(object.commission)
        : "",
    };
  },

  toJSON(message: MsgEditFinalityProvider): unknown {
    const obj: any = {};
    if (message.addr !== "") {
      obj.addr = message.addr;
    }
    if (message.btcPk.length !== 0) {
      obj.btcPk = base64FromBytes(message.btcPk);
    }
    if (message.description !== undefined) {
      obj.description = Description.toJSON(message.description);
    }
    if (message.commission !== "") {
      obj.commission = message.commission;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgEditFinalityProvider>, I>>(
    base?: I,
  ): MsgEditFinalityProvider {
    return MsgEditFinalityProvider.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgEditFinalityProvider>, I>>(
    object: I,
  ): MsgEditFinalityProvider {
    const message = createBaseMsgEditFinalityProvider();
    message.addr = object.addr ?? "";
    message.btcPk = object.btcPk ?? new Uint8Array(0);
    message.description =
      object.description !== undefined && object.description !== null
        ? Description.fromPartial(object.description)
        : undefined;
    message.commission = object.commission ?? "";
    return message;
  },
};

function createBaseMsgEditFinalityProviderResponse(): MsgEditFinalityProviderResponse {
  return {};
}

export const MsgEditFinalityProviderResponse: MessageFns<MsgEditFinalityProviderResponse> =
  {
    encode(
      _: MsgEditFinalityProviderResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): MsgEditFinalityProviderResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgEditFinalityProviderResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): MsgEditFinalityProviderResponse {
      return {};
    },

    toJSON(_: MsgEditFinalityProviderResponse): unknown {
      const obj: any = {};
      return obj;
    },

    create<I extends Exact<DeepPartial<MsgEditFinalityProviderResponse>, I>>(
      base?: I,
    ): MsgEditFinalityProviderResponse {
      return MsgEditFinalityProviderResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<MsgEditFinalityProviderResponse>, I>,
    >(_: I): MsgEditFinalityProviderResponse {
      const message = createBaseMsgEditFinalityProviderResponse();
      return message;
    },
  };

function createBaseMsgCreateBTCDelegation(): MsgCreateBTCDelegation {
  return {
    stakerAddr: "",
    pop: undefined,
    btcPk: new Uint8Array(0),
    fpBtcPkList: [],
    stakingTime: 0,
    stakingValue: 0,
    stakingTx: new Uint8Array(0),
    stakingTxInclusionProof: undefined,
    slashingTx: new Uint8Array(0),
    delegatorSlashingSig: new Uint8Array(0),
    unbondingTime: 0,
    unbondingTx: new Uint8Array(0),
    unbondingValue: 0,
    unbondingSlashingTx: new Uint8Array(0),
    delegatorUnbondingSlashingSig: new Uint8Array(0),
  };
}

export const MsgCreateBTCDelegation: MessageFns<MsgCreateBTCDelegation> = {
  encode(
    message: MsgCreateBTCDelegation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.stakerAddr !== "") {
      writer.uint32(10).string(message.stakerAddr);
    }
    if (message.pop !== undefined) {
      ProofOfPossessionBTC.encode(message.pop, writer.uint32(18).fork()).join();
    }
    if (message.btcPk.length !== 0) {
      writer.uint32(26).bytes(message.btcPk);
    }
    for (const v of message.fpBtcPkList) {
      writer.uint32(34).bytes(v!);
    }
    if (message.stakingTime !== 0) {
      writer.uint32(40).uint32(message.stakingTime);
    }
    if (message.stakingValue !== 0) {
      writer.uint32(48).int64(message.stakingValue);
    }
    if (message.stakingTx.length !== 0) {
      writer.uint32(58).bytes(message.stakingTx);
    }
    if (message.stakingTxInclusionProof !== undefined) {
      InclusionProof.encode(
        message.stakingTxInclusionProof,
        writer.uint32(66).fork(),
      ).join();
    }
    if (message.slashingTx.length !== 0) {
      writer.uint32(74).bytes(message.slashingTx);
    }
    if (message.delegatorSlashingSig.length !== 0) {
      writer.uint32(82).bytes(message.delegatorSlashingSig);
    }
    if (message.unbondingTime !== 0) {
      writer.uint32(88).uint32(message.unbondingTime);
    }
    if (message.unbondingTx.length !== 0) {
      writer.uint32(98).bytes(message.unbondingTx);
    }
    if (message.unbondingValue !== 0) {
      writer.uint32(104).int64(message.unbondingValue);
    }
    if (message.unbondingSlashingTx.length !== 0) {
      writer.uint32(114).bytes(message.unbondingSlashingTx);
    }
    if (message.delegatorUnbondingSlashingSig.length !== 0) {
      writer.uint32(122).bytes(message.delegatorUnbondingSlashingSig);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MsgCreateBTCDelegation {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateBTCDelegation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stakerAddr = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pop = ProofOfPossessionBTC.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.btcPk = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fpBtcPkList.push(reader.bytes());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.stakingTime = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.stakingValue = longToNumber(reader.int64());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.stakingTx = reader.bytes();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.stakingTxInclusionProof = InclusionProof.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.slashingTx = reader.bytes();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.delegatorSlashingSig = reader.bytes();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.unbondingTime = reader.uint32();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.unbondingTx = reader.bytes();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.unbondingValue = longToNumber(reader.int64());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.unbondingSlashingTx = reader.bytes();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.delegatorUnbondingSlashingSig = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateBTCDelegation {
    return {
      stakerAddr: isSet(object.stakerAddr)
        ? globalThis.String(object.stakerAddr)
        : "",
      pop: isSet(object.pop)
        ? ProofOfPossessionBTC.fromJSON(object.pop)
        : undefined,
      btcPk: isSet(object.btcPk)
        ? bytesFromBase64(object.btcPk)
        : new Uint8Array(0),
      fpBtcPkList: globalThis.Array.isArray(object?.fpBtcPkList)
        ? object.fpBtcPkList.map((e: any) => bytesFromBase64(e))
        : [],
      stakingTime: isSet(object.stakingTime)
        ? globalThis.Number(object.stakingTime)
        : 0,
      stakingValue: isSet(object.stakingValue)
        ? globalThis.Number(object.stakingValue)
        : 0,
      stakingTx: isSet(object.stakingTx)
        ? bytesFromBase64(object.stakingTx)
        : new Uint8Array(0),
      stakingTxInclusionProof: isSet(object.stakingTxInclusionProof)
        ? InclusionProof.fromJSON(object.stakingTxInclusionProof)
        : undefined,
      slashingTx: isSet(object.slashingTx)
        ? bytesFromBase64(object.slashingTx)
        : new Uint8Array(0),
      delegatorSlashingSig: isSet(object.delegatorSlashingSig)
        ? bytesFromBase64(object.delegatorSlashingSig)
        : new Uint8Array(0),
      unbondingTime: isSet(object.unbondingTime)
        ? globalThis.Number(object.unbondingTime)
        : 0,
      unbondingTx: isSet(object.unbondingTx)
        ? bytesFromBase64(object.unbondingTx)
        : new Uint8Array(0),
      unbondingValue: isSet(object.unbondingValue)
        ? globalThis.Number(object.unbondingValue)
        : 0,
      unbondingSlashingTx: isSet(object.unbondingSlashingTx)
        ? bytesFromBase64(object.unbondingSlashingTx)
        : new Uint8Array(0),
      delegatorUnbondingSlashingSig: isSet(object.delegatorUnbondingSlashingSig)
        ? bytesFromBase64(object.delegatorUnbondingSlashingSig)
        : new Uint8Array(0),
    };
  },

  toJSON(message: MsgCreateBTCDelegation): unknown {
    const obj: any = {};
    if (message.stakerAddr !== "") {
      obj.stakerAddr = message.stakerAddr;
    }
    if (message.pop !== undefined) {
      obj.pop = ProofOfPossessionBTC.toJSON(message.pop);
    }
    if (message.btcPk.length !== 0) {
      obj.btcPk = base64FromBytes(message.btcPk);
    }
    if (message.fpBtcPkList?.length) {
      obj.fpBtcPkList = message.fpBtcPkList.map((e) => base64FromBytes(e));
    }
    if (message.stakingTime !== 0) {
      obj.stakingTime = Math.round(message.stakingTime);
    }
    if (message.stakingValue !== 0) {
      obj.stakingValue = Math.round(message.stakingValue);
    }
    if (message.stakingTx.length !== 0) {
      obj.stakingTx = base64FromBytes(message.stakingTx);
    }
    if (message.stakingTxInclusionProof !== undefined) {
      obj.stakingTxInclusionProof = InclusionProof.toJSON(
        message.stakingTxInclusionProof,
      );
    }
    if (message.slashingTx.length !== 0) {
      obj.slashingTx = base64FromBytes(message.slashingTx);
    }
    if (message.delegatorSlashingSig.length !== 0) {
      obj.delegatorSlashingSig = base64FromBytes(message.delegatorSlashingSig);
    }
    if (message.unbondingTime !== 0) {
      obj.unbondingTime = Math.round(message.unbondingTime);
    }
    if (message.unbondingTx.length !== 0) {
      obj.unbondingTx = base64FromBytes(message.unbondingTx);
    }
    if (message.unbondingValue !== 0) {
      obj.unbondingValue = Math.round(message.unbondingValue);
    }
    if (message.unbondingSlashingTx.length !== 0) {
      obj.unbondingSlashingTx = base64FromBytes(message.unbondingSlashingTx);
    }
    if (message.delegatorUnbondingSlashingSig.length !== 0) {
      obj.delegatorUnbondingSlashingSig = base64FromBytes(
        message.delegatorUnbondingSlashingSig,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateBTCDelegation>, I>>(
    base?: I,
  ): MsgCreateBTCDelegation {
    return MsgCreateBTCDelegation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateBTCDelegation>, I>>(
    object: I,
  ): MsgCreateBTCDelegation {
    const message = createBaseMsgCreateBTCDelegation();
    message.stakerAddr = object.stakerAddr ?? "";
    message.pop =
      object.pop !== undefined && object.pop !== null
        ? ProofOfPossessionBTC.fromPartial(object.pop)
        : undefined;
    message.btcPk = object.btcPk ?? new Uint8Array(0);
    message.fpBtcPkList = object.fpBtcPkList?.map((e) => e) || [];
    message.stakingTime = object.stakingTime ?? 0;
    message.stakingValue = object.stakingValue ?? 0;
    message.stakingTx = object.stakingTx ?? new Uint8Array(0);
    message.stakingTxInclusionProof =
      object.stakingTxInclusionProof !== undefined &&
      object.stakingTxInclusionProof !== null
        ? InclusionProof.fromPartial(object.stakingTxInclusionProof)
        : undefined;
    message.slashingTx = object.slashingTx ?? new Uint8Array(0);
    message.delegatorSlashingSig =
      object.delegatorSlashingSig ?? new Uint8Array(0);
    message.unbondingTime = object.unbondingTime ?? 0;
    message.unbondingTx = object.unbondingTx ?? new Uint8Array(0);
    message.unbondingValue = object.unbondingValue ?? 0;
    message.unbondingSlashingTx =
      object.unbondingSlashingTx ?? new Uint8Array(0);
    message.delegatorUnbondingSlashingSig =
      object.delegatorUnbondingSlashingSig ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgCreateBTCDelegationResponse(): MsgCreateBTCDelegationResponse {
  return {};
}

export const MsgCreateBTCDelegationResponse: MessageFns<MsgCreateBTCDelegationResponse> =
  {
    encode(
      _: MsgCreateBTCDelegationResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): MsgCreateBTCDelegationResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgCreateBTCDelegationResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): MsgCreateBTCDelegationResponse {
      return {};
    },

    toJSON(_: MsgCreateBTCDelegationResponse): unknown {
      const obj: any = {};
      return obj;
    },

    create<I extends Exact<DeepPartial<MsgCreateBTCDelegationResponse>, I>>(
      base?: I,
    ): MsgCreateBTCDelegationResponse {
      return MsgCreateBTCDelegationResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<MsgCreateBTCDelegationResponse>, I>,
    >(_: I): MsgCreateBTCDelegationResponse {
      const message = createBaseMsgCreateBTCDelegationResponse();
      return message;
    },
  };

function createBaseMsgAddBTCDelegationInclusionProof(): MsgAddBTCDelegationInclusionProof {
  return { signer: "", stakingTxHash: "", stakingTxInclusionProof: undefined };
}

export const MsgAddBTCDelegationInclusionProof: MessageFns<MsgAddBTCDelegationInclusionProof> =
  {
    encode(
      message: MsgAddBTCDelegationInclusionProof,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.signer !== "") {
        writer.uint32(10).string(message.signer);
      }
      if (message.stakingTxHash !== "") {
        writer.uint32(18).string(message.stakingTxHash);
      }
      if (message.stakingTxInclusionProof !== undefined) {
        InclusionProof.encode(
          message.stakingTxInclusionProof,
          writer.uint32(26).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): MsgAddBTCDelegationInclusionProof {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgAddBTCDelegationInclusionProof();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.signer = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.stakingTxHash = reader.string();
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }

            message.stakingTxInclusionProof = InclusionProof.decode(
              reader,
              reader.uint32(),
            );
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): MsgAddBTCDelegationInclusionProof {
      return {
        signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
        stakingTxHash: isSet(object.stakingTxHash)
          ? globalThis.String(object.stakingTxHash)
          : "",
        stakingTxInclusionProof: isSet(object.stakingTxInclusionProof)
          ? InclusionProof.fromJSON(object.stakingTxInclusionProof)
          : undefined,
      };
    },

    toJSON(message: MsgAddBTCDelegationInclusionProof): unknown {
      const obj: any = {};
      if (message.signer !== "") {
        obj.signer = message.signer;
      }
      if (message.stakingTxHash !== "") {
        obj.stakingTxHash = message.stakingTxHash;
      }
      if (message.stakingTxInclusionProof !== undefined) {
        obj.stakingTxInclusionProof = InclusionProof.toJSON(
          message.stakingTxInclusionProof,
        );
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<MsgAddBTCDelegationInclusionProof>, I>>(
      base?: I,
    ): MsgAddBTCDelegationInclusionProof {
      return MsgAddBTCDelegationInclusionProof.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<MsgAddBTCDelegationInclusionProof>, I>,
    >(object: I): MsgAddBTCDelegationInclusionProof {
      const message = createBaseMsgAddBTCDelegationInclusionProof();
      message.signer = object.signer ?? "";
      message.stakingTxHash = object.stakingTxHash ?? "";
      message.stakingTxInclusionProof =
        object.stakingTxInclusionProof !== undefined &&
        object.stakingTxInclusionProof !== null
          ? InclusionProof.fromPartial(object.stakingTxInclusionProof)
          : undefined;
      return message;
    },
  };

function createBaseMsgAddBTCDelegationInclusionProofResponse(): MsgAddBTCDelegationInclusionProofResponse {
  return {};
}

export const MsgAddBTCDelegationInclusionProofResponse: MessageFns<MsgAddBTCDelegationInclusionProofResponse> =
  {
    encode(
      _: MsgAddBTCDelegationInclusionProofResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): MsgAddBTCDelegationInclusionProofResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgAddBTCDelegationInclusionProofResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): MsgAddBTCDelegationInclusionProofResponse {
      return {};
    },

    toJSON(_: MsgAddBTCDelegationInclusionProofResponse): unknown {
      const obj: any = {};
      return obj;
    },

    create<
      I extends Exact<
        DeepPartial<MsgAddBTCDelegationInclusionProofResponse>,
        I
      >,
    >(base?: I): MsgAddBTCDelegationInclusionProofResponse {
      return MsgAddBTCDelegationInclusionProofResponse.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<
        DeepPartial<MsgAddBTCDelegationInclusionProofResponse>,
        I
      >,
    >(_: I): MsgAddBTCDelegationInclusionProofResponse {
      const message = createBaseMsgAddBTCDelegationInclusionProofResponse();
      return message;
    },
  };

function createBaseMsgAddCovenantSigs(): MsgAddCovenantSigs {
  return {
    signer: "",
    pk: new Uint8Array(0),
    stakingTxHash: "",
    slashingTxSigs: [],
    unbondingTxSig: new Uint8Array(0),
    slashingUnbondingTxSigs: [],
  };
}

export const MsgAddCovenantSigs: MessageFns<MsgAddCovenantSigs> = {
  encode(
    message: MsgAddCovenantSigs,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.signer !== "") {
      writer.uint32(10).string(message.signer);
    }
    if (message.pk.length !== 0) {
      writer.uint32(18).bytes(message.pk);
    }
    if (message.stakingTxHash !== "") {
      writer.uint32(26).string(message.stakingTxHash);
    }
    for (const v of message.slashingTxSigs) {
      writer.uint32(34).bytes(v!);
    }
    if (message.unbondingTxSig.length !== 0) {
      writer.uint32(42).bytes(message.unbondingTxSig);
    }
    for (const v of message.slashingUnbondingTxSigs) {
      writer.uint32(50).bytes(v!);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MsgAddCovenantSigs {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddCovenantSigs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signer = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pk = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stakingTxHash = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.slashingTxSigs.push(reader.bytes());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.unbondingTxSig = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.slashingUnbondingTxSigs.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddCovenantSigs {
    return {
      signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
      pk: isSet(object.pk) ? bytesFromBase64(object.pk) : new Uint8Array(0),
      stakingTxHash: isSet(object.stakingTxHash)
        ? globalThis.String(object.stakingTxHash)
        : "",
      slashingTxSigs: globalThis.Array.isArray(object?.slashingTxSigs)
        ? object.slashingTxSigs.map((e: any) => bytesFromBase64(e))
        : [],
      unbondingTxSig: isSet(object.unbondingTxSig)
        ? bytesFromBase64(object.unbondingTxSig)
        : new Uint8Array(0),
      slashingUnbondingTxSigs: globalThis.Array.isArray(
        object?.slashingUnbondingTxSigs,
      )
        ? object.slashingUnbondingTxSigs.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: MsgAddCovenantSigs): unknown {
    const obj: any = {};
    if (message.signer !== "") {
      obj.signer = message.signer;
    }
    if (message.pk.length !== 0) {
      obj.pk = base64FromBytes(message.pk);
    }
    if (message.stakingTxHash !== "") {
      obj.stakingTxHash = message.stakingTxHash;
    }
    if (message.slashingTxSigs?.length) {
      obj.slashingTxSigs = message.slashingTxSigs.map((e) =>
        base64FromBytes(e),
      );
    }
    if (message.unbondingTxSig.length !== 0) {
      obj.unbondingTxSig = base64FromBytes(message.unbondingTxSig);
    }
    if (message.slashingUnbondingTxSigs?.length) {
      obj.slashingUnbondingTxSigs = message.slashingUnbondingTxSigs.map((e) =>
        base64FromBytes(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddCovenantSigs>, I>>(
    base?: I,
  ): MsgAddCovenantSigs {
    return MsgAddCovenantSigs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddCovenantSigs>, I>>(
    object: I,
  ): MsgAddCovenantSigs {
    const message = createBaseMsgAddCovenantSigs();
    message.signer = object.signer ?? "";
    message.pk = object.pk ?? new Uint8Array(0);
    message.stakingTxHash = object.stakingTxHash ?? "";
    message.slashingTxSigs = object.slashingTxSigs?.map((e) => e) || [];
    message.unbondingTxSig = object.unbondingTxSig ?? new Uint8Array(0);
    message.slashingUnbondingTxSigs =
      object.slashingUnbondingTxSigs?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgAddCovenantSigsResponse(): MsgAddCovenantSigsResponse {
  return {};
}

export const MsgAddCovenantSigsResponse: MessageFns<MsgAddCovenantSigsResponse> =
  {
    encode(
      _: MsgAddCovenantSigsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): MsgAddCovenantSigsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgAddCovenantSigsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): MsgAddCovenantSigsResponse {
      return {};
    },

    toJSON(_: MsgAddCovenantSigsResponse): unknown {
      const obj: any = {};
      return obj;
    },

    create<I extends Exact<DeepPartial<MsgAddCovenantSigsResponse>, I>>(
      base?: I,
    ): MsgAddCovenantSigsResponse {
      return MsgAddCovenantSigsResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<MsgAddCovenantSigsResponse>, I>>(
      _: I,
    ): MsgAddCovenantSigsResponse {
      const message = createBaseMsgAddCovenantSigsResponse();
      return message;
    },
  };

function createBaseMsgBTCUndelegate(): MsgBTCUndelegate {
  return { signer: "", stakingTxHash: "", unbondingTxSig: new Uint8Array(0) };
}

export const MsgBTCUndelegate: MessageFns<MsgBTCUndelegate> = {
  encode(
    message: MsgBTCUndelegate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.signer !== "") {
      writer.uint32(10).string(message.signer);
    }
    if (message.stakingTxHash !== "") {
      writer.uint32(18).string(message.stakingTxHash);
    }
    if (message.unbondingTxSig.length !== 0) {
      writer.uint32(26).bytes(message.unbondingTxSig);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBTCUndelegate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBTCUndelegate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signer = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stakingTxHash = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unbondingTxSig = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBTCUndelegate {
    return {
      signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
      stakingTxHash: isSet(object.stakingTxHash)
        ? globalThis.String(object.stakingTxHash)
        : "",
      unbondingTxSig: isSet(object.unbondingTxSig)
        ? bytesFromBase64(object.unbondingTxSig)
        : new Uint8Array(0),
    };
  },

  toJSON(message: MsgBTCUndelegate): unknown {
    const obj: any = {};
    if (message.signer !== "") {
      obj.signer = message.signer;
    }
    if (message.stakingTxHash !== "") {
      obj.stakingTxHash = message.stakingTxHash;
    }
    if (message.unbondingTxSig.length !== 0) {
      obj.unbondingTxSig = base64FromBytes(message.unbondingTxSig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBTCUndelegate>, I>>(
    base?: I,
  ): MsgBTCUndelegate {
    return MsgBTCUndelegate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBTCUndelegate>, I>>(
    object: I,
  ): MsgBTCUndelegate {
    const message = createBaseMsgBTCUndelegate();
    message.signer = object.signer ?? "";
    message.stakingTxHash = object.stakingTxHash ?? "";
    message.unbondingTxSig = object.unbondingTxSig ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgBTCUndelegateResponse(): MsgBTCUndelegateResponse {
  return {};
}

export const MsgBTCUndelegateResponse: MessageFns<MsgBTCUndelegateResponse> = {
  encode(
    _: MsgBTCUndelegateResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MsgBTCUndelegateResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBTCUndelegateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgBTCUndelegateResponse {
    return {};
  },

  toJSON(_: MsgBTCUndelegateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBTCUndelegateResponse>, I>>(
    base?: I,
  ): MsgBTCUndelegateResponse {
    return MsgBTCUndelegateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBTCUndelegateResponse>, I>>(
    _: I,
  ): MsgBTCUndelegateResponse {
    const message = createBaseMsgBTCUndelegateResponse();
    return message;
  },
};

function createBaseMsgSelectiveSlashingEvidence(): MsgSelectiveSlashingEvidence {
  return { signer: "", stakingTxHash: "", recoveredFpBtcSk: new Uint8Array(0) };
}

export const MsgSelectiveSlashingEvidence: MessageFns<MsgSelectiveSlashingEvidence> =
  {
    encode(
      message: MsgSelectiveSlashingEvidence,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.signer !== "") {
        writer.uint32(10).string(message.signer);
      }
      if (message.stakingTxHash !== "") {
        writer.uint32(18).string(message.stakingTxHash);
      }
      if (message.recoveredFpBtcSk.length !== 0) {
        writer.uint32(26).bytes(message.recoveredFpBtcSk);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): MsgSelectiveSlashingEvidence {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgSelectiveSlashingEvidence();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.signer = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.stakingTxHash = reader.string();
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }

            message.recoveredFpBtcSk = reader.bytes();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): MsgSelectiveSlashingEvidence {
      return {
        signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
        stakingTxHash: isSet(object.stakingTxHash)
          ? globalThis.String(object.stakingTxHash)
          : "",
        recoveredFpBtcSk: isSet(object.recoveredFpBtcSk)
          ? bytesFromBase64(object.recoveredFpBtcSk)
          : new Uint8Array(0),
      };
    },

    toJSON(message: MsgSelectiveSlashingEvidence): unknown {
      const obj: any = {};
      if (message.signer !== "") {
        obj.signer = message.signer;
      }
      if (message.stakingTxHash !== "") {
        obj.stakingTxHash = message.stakingTxHash;
      }
      if (message.recoveredFpBtcSk.length !== 0) {
        obj.recoveredFpBtcSk = base64FromBytes(message.recoveredFpBtcSk);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<MsgSelectiveSlashingEvidence>, I>>(
      base?: I,
    ): MsgSelectiveSlashingEvidence {
      return MsgSelectiveSlashingEvidence.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<MsgSelectiveSlashingEvidence>, I>>(
      object: I,
    ): MsgSelectiveSlashingEvidence {
      const message = createBaseMsgSelectiveSlashingEvidence();
      message.signer = object.signer ?? "";
      message.stakingTxHash = object.stakingTxHash ?? "";
      message.recoveredFpBtcSk = object.recoveredFpBtcSk ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseMsgSelectiveSlashingEvidenceResponse(): MsgSelectiveSlashingEvidenceResponse {
  return {};
}

export const MsgSelectiveSlashingEvidenceResponse: MessageFns<MsgSelectiveSlashingEvidenceResponse> =
  {
    encode(
      _: MsgSelectiveSlashingEvidenceResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): MsgSelectiveSlashingEvidenceResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgSelectiveSlashingEvidenceResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): MsgSelectiveSlashingEvidenceResponse {
      return {};
    },

    toJSON(_: MsgSelectiveSlashingEvidenceResponse): unknown {
      const obj: any = {};
      return obj;
    },

    create<
      I extends Exact<DeepPartial<MsgSelectiveSlashingEvidenceResponse>, I>,
    >(base?: I): MsgSelectiveSlashingEvidenceResponse {
      return MsgSelectiveSlashingEvidenceResponse.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<DeepPartial<MsgSelectiveSlashingEvidenceResponse>, I>,
    >(_: I): MsgSelectiveSlashingEvidenceResponse {
      const message = createBaseMsgSelectiveSlashingEvidenceResponse();
      return message;
    },
  };

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(
    message: MsgUpdateParams,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority)
        ? globalThis.String(object.authority)
        : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(
    base?: I,
  ): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(
    object: I,
  ): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params =
      object.params !== undefined && object.params !== null
        ? Params.fromPartial(object.params)
        : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(
    _: MsgUpdateParamsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MsgUpdateParamsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(
    base?: I,
  ): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(
    _: I,
  ): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

/**
 * Msg defines the Msg service.
 * TODO: handle unbonding tx with full witness
 */
export interface Msg {
  /** CreateFinalityProvider creates a new finality provider */
  CreateFinalityProvider(
    request: MsgCreateFinalityProvider,
  ): Promise<MsgCreateFinalityProviderResponse>;
  /** EditFinalityProvider edits an existing finality provider */
  EditFinalityProvider(
    request: MsgEditFinalityProvider,
  ): Promise<MsgEditFinalityProviderResponse>;
  /** CreateBTCDelegation creates a new BTC delegation */
  CreateBTCDelegation(
    request: MsgCreateBTCDelegation,
  ): Promise<MsgCreateBTCDelegationResponse>;
  /** AddBTCDelegationInclusionProof adds inclusion proof of a given delegation on BTC chain */
  AddBTCDelegationInclusionProof(
    request: MsgAddBTCDelegationInclusionProof,
  ): Promise<MsgAddBTCDelegationInclusionProofResponse>;
  /** AddCovenantSigs handles signatures from a covenant member */
  AddCovenantSigs(
    request: MsgAddCovenantSigs,
  ): Promise<MsgAddCovenantSigsResponse>;
  /** BTCUndelegate handles a signature on unbonding tx from its delegator */
  BTCUndelegate(request: MsgBTCUndelegate): Promise<MsgBTCUndelegateResponse>;
  /**
   * SelectiveSlashingEvidence handles the evidence of selective slashing launched
   * by a finality provider
   */
  SelectiveSlashingEvidence(
    request: MsgSelectiveSlashingEvidence,
  ): Promise<MsgSelectiveSlashingEvidenceResponse>;
  /** UpdateParams updates the btcstaking module parameters. */
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
}

export const MsgServiceName = "babylon.btcstaking.v1.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.CreateFinalityProvider = this.CreateFinalityProvider.bind(this);
    this.EditFinalityProvider = this.EditFinalityProvider.bind(this);
    this.CreateBTCDelegation = this.CreateBTCDelegation.bind(this);
    this.AddBTCDelegationInclusionProof =
      this.AddBTCDelegationInclusionProof.bind(this);
    this.AddCovenantSigs = this.AddCovenantSigs.bind(this);
    this.BTCUndelegate = this.BTCUndelegate.bind(this);
    this.SelectiveSlashingEvidence = this.SelectiveSlashingEvidence.bind(this);
    this.UpdateParams = this.UpdateParams.bind(this);
  }
  CreateFinalityProvider(
    request: MsgCreateFinalityProvider,
  ): Promise<MsgCreateFinalityProviderResponse> {
    const data = MsgCreateFinalityProvider.encode(request).finish();
    const promise = this.rpc.request(
      this.service,
      "CreateFinalityProvider",
      data,
    );
    return promise.then((data) =>
      MsgCreateFinalityProviderResponse.decode(new BinaryReader(data)),
    );
  }

  EditFinalityProvider(
    request: MsgEditFinalityProvider,
  ): Promise<MsgEditFinalityProviderResponse> {
    const data = MsgEditFinalityProvider.encode(request).finish();
    const promise = this.rpc.request(
      this.service,
      "EditFinalityProvider",
      data,
    );
    return promise.then((data) =>
      MsgEditFinalityProviderResponse.decode(new BinaryReader(data)),
    );
  }

  CreateBTCDelegation(
    request: MsgCreateBTCDelegation,
  ): Promise<MsgCreateBTCDelegationResponse> {
    const data = MsgCreateBTCDelegation.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateBTCDelegation", data);
    return promise.then((data) =>
      MsgCreateBTCDelegationResponse.decode(new BinaryReader(data)),
    );
  }

  AddBTCDelegationInclusionProof(
    request: MsgAddBTCDelegationInclusionProof,
  ): Promise<MsgAddBTCDelegationInclusionProofResponse> {
    const data = MsgAddBTCDelegationInclusionProof.encode(request).finish();
    const promise = this.rpc.request(
      this.service,
      "AddBTCDelegationInclusionProof",
      data,
    );
    return promise.then((data) =>
      MsgAddBTCDelegationInclusionProofResponse.decode(new BinaryReader(data)),
    );
  }

  AddCovenantSigs(
    request: MsgAddCovenantSigs,
  ): Promise<MsgAddCovenantSigsResponse> {
    const data = MsgAddCovenantSigs.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddCovenantSigs", data);
    return promise.then((data) =>
      MsgAddCovenantSigsResponse.decode(new BinaryReader(data)),
    );
  }

  BTCUndelegate(request: MsgBTCUndelegate): Promise<MsgBTCUndelegateResponse> {
    const data = MsgBTCUndelegate.encode(request).finish();
    const promise = this.rpc.request(this.service, "BTCUndelegate", data);
    return promise.then((data) =>
      MsgBTCUndelegateResponse.decode(new BinaryReader(data)),
    );
  }

  SelectiveSlashingEvidence(
    request: MsgSelectiveSlashingEvidence,
  ): Promise<MsgSelectiveSlashingEvidenceResponse> {
    const data = MsgSelectiveSlashingEvidence.encode(request).finish();
    const promise = this.rpc.request(
      this.service,
      "SelectiveSlashingEvidence",
      data,
    );
    return promise.then((data) =>
      MsgSelectiveSlashingEvidenceResponse.decode(new BinaryReader(data)),
    );
  }

  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse> {
    const data = MsgUpdateParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateParams", data);
    return promise.then((data) =>
      MsgUpdateParamsResponse.decode(new BinaryReader(data)),
    );
  }
}

interface Rpc {
  request(
    service: string,
    method: string,
    data: Uint8Array,
  ): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
