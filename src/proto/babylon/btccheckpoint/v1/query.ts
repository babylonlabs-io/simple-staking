// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: babylon/btccheckpoint/v1/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  PageRequest,
  PageResponse,
} from "../../../cosmos/base/query/v1beta1/pagination";
import { Params } from "./params";

export const protobufPackage = "babylon.btccheckpoint.v1";

/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {}

/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
  /** params holds all the parameters of this module. */
  params: Params | undefined;
}

/**
 * QueryBtcCheckpointInfoRequest defines the query to get the best checkpoint
 * for a given epoch
 */
export interface QueryBtcCheckpointInfoRequest {
  /**
   * Number of epoch for which the earliest checkpointing btc height is
   * requested
   */
  epochNum: number;
}

/**
 * QueryBtcCheckpointInfoResponse is response type for the
 * Query/BtcCheckpointInfo RPC method
 */
export interface QueryBtcCheckpointInfoResponse {
  info: BTCCheckpointInfoResponse | undefined;
}

/**
 * QueryBtcCheckpointsInfoRequest is request type for the
 * Query/BtcCheckpointsInfo RPC method
 */
export interface QueryBtcCheckpointsInfoRequest {
  /** pagination defines whether to have the pagination in the request */
  pagination: PageRequest | undefined;
}

/**
 * QueryBtcCheckpointsInfoResponse is response type for the
 * Query/BtcCheckpointsInfo RPC method
 */
export interface QueryBtcCheckpointsInfoResponse {
  infoList: BTCCheckpointInfoResponse[];
  /** pagination defines the pagination in the response */
  pagination: PageResponse | undefined;
}

/**
 * QueryEpochSubmissionsRequest defines a request to get all submissions in
 * given epoch
 */
export interface QueryEpochSubmissionsRequest {
  /** Number of epoch for which submissions are requested */
  epochNum: number;
}

/**
 * QueryEpochSubmissionsResponse defines a response to get all submissions in
 * given epoch (QueryEpochSubmissionsRequest)
 */
export interface QueryEpochSubmissionsResponse {
  /** Keys All submissions transactions key saved during an epoch. */
  keys: SubmissionKeyResponse[];
}

/**
 * BTCCheckpointInfoResponse contains all data about best submission of checkpoint for
 * given epoch. Best submission is the submission which is deeper in btc ledger.
 */
export interface BTCCheckpointInfoResponse {
  /** EpochNumber of this checkpoint. */
  epochNumber: number;
  /** btc height of the best submission of the epoch */
  bestSubmissionBtcBlockHeight: number;
  /**
   * hash of the btc block which determines checkpoint btc block height i.e.
   * youngest block of best submission Hexadecimal
   */
  bestSubmissionBtcBlockHash: string;
  /** the BTC checkpoint transactions of the best submission */
  bestSubmissionTransactions: TransactionInfoResponse[];
  /** list of vigilantes' addresses of the best submission */
  bestSubmissionVigilanteAddressList: CheckpointAddressesResponse[];
}

/**
 * TransactionInfoResponse is the info of a tx on Bitcoin,
 * including
 * - the position of the tx on BTC blockchain
 * - the full tx content
 * - the Merkle proof that this tx is on the above position
 */
export interface TransactionInfoResponse {
  /** Index Bitcoin Transaction index in block. */
  index: number;
  /** Hash BTC Header hash as hex. */
  hash: string;
  /** transaction is the full transaction data as str hex. */
  transaction: string;
  /** proof is the Merkle proof that this tx is included in the position in `key` */
  proof: string;
}

/**
 * CheckpointAddressesResponse contains the addresses of the submitter and reporter of a
 * given checkpoint
 */
export interface CheckpointAddressesResponse {
  /**
   * submitter is the address of the checkpoint submitter to BTC, extracted from
   * the checkpoint itself.
   */
  submitter: string;
  /**
   * reporter is the address of the reporter who reported the submissions,
   * calculated from submission message MsgInsertBTCSpvProof itself
   */
  reporter: string;
}

/**
 * SubmissionKeyResponse Checkpoint can be composed from multiple transactions,
 * so to identify whole submission we need list of transaction keys.
 * Each submission can generally be identified by this list of (txIdx,
 * blockHash) tuples. Note: this could possibly be optimized as if transactions
 * were in one block they would have the same block hash and different indexes,
 * but each blockhash is only 33 (1  byte for prefix encoding and 32 byte hash),
 * so there should be other strong arguments for this optimization
 */
export interface SubmissionKeyResponse {
  /** FirstTxBlockHash is the BTCHeaderHashBytes in hex. */
  firstTxBlockHash: string;
  firstTxIndex: number;
  /** SecondBlockHash is the BTCHeaderHashBytes in hex. */
  secondTxBlockHash: string;
  secondTxIndex: number;
}

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(
    _: QueryParamsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryParamsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(
    base?: I,
  ): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(
    _: I,
  ): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(
    message: QueryParamsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryParamsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return {
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(
    base?: I,
  ): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(
    object: I,
  ): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params =
      object.params !== undefined && object.params !== null
        ? Params.fromPartial(object.params)
        : undefined;
    return message;
  },
};

function createBaseQueryBtcCheckpointInfoRequest(): QueryBtcCheckpointInfoRequest {
  return { epochNum: 0 };
}

export const QueryBtcCheckpointInfoRequest: MessageFns<QueryBtcCheckpointInfoRequest> =
  {
    encode(
      message: QueryBtcCheckpointInfoRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.epochNum !== 0) {
        writer.uint32(8).uint64(message.epochNum);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryBtcCheckpointInfoRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryBtcCheckpointInfoRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }

            message.epochNum = longToNumber(reader.uint64());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryBtcCheckpointInfoRequest {
      return {
        epochNum: isSet(object.epochNum)
          ? globalThis.Number(object.epochNum)
          : 0,
      };
    },

    toJSON(message: QueryBtcCheckpointInfoRequest): unknown {
      const obj: any = {};
      if (message.epochNum !== 0) {
        obj.epochNum = Math.round(message.epochNum);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryBtcCheckpointInfoRequest>, I>>(
      base?: I,
    ): QueryBtcCheckpointInfoRequest {
      return QueryBtcCheckpointInfoRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryBtcCheckpointInfoRequest>, I>>(
      object: I,
    ): QueryBtcCheckpointInfoRequest {
      const message = createBaseQueryBtcCheckpointInfoRequest();
      message.epochNum = object.epochNum ?? 0;
      return message;
    },
  };

function createBaseQueryBtcCheckpointInfoResponse(): QueryBtcCheckpointInfoResponse {
  return { info: undefined };
}

export const QueryBtcCheckpointInfoResponse: MessageFns<QueryBtcCheckpointInfoResponse> =
  {
    encode(
      message: QueryBtcCheckpointInfoResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.info !== undefined) {
        BTCCheckpointInfoResponse.encode(
          message.info,
          writer.uint32(10).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryBtcCheckpointInfoResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryBtcCheckpointInfoResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.info = BTCCheckpointInfoResponse.decode(
              reader,
              reader.uint32(),
            );
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryBtcCheckpointInfoResponse {
      return {
        info: isSet(object.info)
          ? BTCCheckpointInfoResponse.fromJSON(object.info)
          : undefined,
      };
    },

    toJSON(message: QueryBtcCheckpointInfoResponse): unknown {
      const obj: any = {};
      if (message.info !== undefined) {
        obj.info = BTCCheckpointInfoResponse.toJSON(message.info);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryBtcCheckpointInfoResponse>, I>>(
      base?: I,
    ): QueryBtcCheckpointInfoResponse {
      return QueryBtcCheckpointInfoResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryBtcCheckpointInfoResponse>, I>,
    >(object: I): QueryBtcCheckpointInfoResponse {
      const message = createBaseQueryBtcCheckpointInfoResponse();
      message.info =
        object.info !== undefined && object.info !== null
          ? BTCCheckpointInfoResponse.fromPartial(object.info)
          : undefined;
      return message;
    },
  };

function createBaseQueryBtcCheckpointsInfoRequest(): QueryBtcCheckpointsInfoRequest {
  return { pagination: undefined };
}

export const QueryBtcCheckpointsInfoRequest: MessageFns<QueryBtcCheckpointsInfoRequest> =
  {
    encode(
      message: QueryBtcCheckpointsInfoRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.pagination !== undefined) {
        PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryBtcCheckpointsInfoRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryBtcCheckpointsInfoRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.pagination = PageRequest.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryBtcCheckpointsInfoRequest {
      return {
        pagination: isSet(object.pagination)
          ? PageRequest.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryBtcCheckpointsInfoRequest): unknown {
      const obj: any = {};
      if (message.pagination !== undefined) {
        obj.pagination = PageRequest.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryBtcCheckpointsInfoRequest>, I>>(
      base?: I,
    ): QueryBtcCheckpointsInfoRequest {
      return QueryBtcCheckpointsInfoRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryBtcCheckpointsInfoRequest>, I>,
    >(object: I): QueryBtcCheckpointsInfoRequest {
      const message = createBaseQueryBtcCheckpointsInfoRequest();
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageRequest.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryBtcCheckpointsInfoResponse(): QueryBtcCheckpointsInfoResponse {
  return { infoList: [], pagination: undefined };
}

export const QueryBtcCheckpointsInfoResponse: MessageFns<QueryBtcCheckpointsInfoResponse> =
  {
    encode(
      message: QueryBtcCheckpointsInfoResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.infoList) {
        BTCCheckpointInfoResponse.encode(v!, writer.uint32(10).fork()).join();
      }
      if (message.pagination !== undefined) {
        PageResponse.encode(
          message.pagination,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryBtcCheckpointsInfoResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryBtcCheckpointsInfoResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.infoList.push(
              BTCCheckpointInfoResponse.decode(reader, reader.uint32()),
            );
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.pagination = PageResponse.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryBtcCheckpointsInfoResponse {
      return {
        infoList: globalThis.Array.isArray(object?.infoList)
          ? object.infoList.map((e: any) =>
              BTCCheckpointInfoResponse.fromJSON(e),
            )
          : [],
        pagination: isSet(object.pagination)
          ? PageResponse.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryBtcCheckpointsInfoResponse): unknown {
      const obj: any = {};
      if (message.infoList?.length) {
        obj.infoList = message.infoList.map((e) =>
          BTCCheckpointInfoResponse.toJSON(e),
        );
      }
      if (message.pagination !== undefined) {
        obj.pagination = PageResponse.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryBtcCheckpointsInfoResponse>, I>>(
      base?: I,
    ): QueryBtcCheckpointsInfoResponse {
      return QueryBtcCheckpointsInfoResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryBtcCheckpointsInfoResponse>, I>,
    >(object: I): QueryBtcCheckpointsInfoResponse {
      const message = createBaseQueryBtcCheckpointsInfoResponse();
      message.infoList =
        object.infoList?.map((e) => BTCCheckpointInfoResponse.fromPartial(e)) ||
        [];
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageResponse.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryEpochSubmissionsRequest(): QueryEpochSubmissionsRequest {
  return { epochNum: 0 };
}

export const QueryEpochSubmissionsRequest: MessageFns<QueryEpochSubmissionsRequest> =
  {
    encode(
      message: QueryEpochSubmissionsRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.epochNum !== 0) {
        writer.uint32(8).uint64(message.epochNum);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryEpochSubmissionsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryEpochSubmissionsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }

            message.epochNum = longToNumber(reader.uint64());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryEpochSubmissionsRequest {
      return {
        epochNum: isSet(object.epochNum)
          ? globalThis.Number(object.epochNum)
          : 0,
      };
    },

    toJSON(message: QueryEpochSubmissionsRequest): unknown {
      const obj: any = {};
      if (message.epochNum !== 0) {
        obj.epochNum = Math.round(message.epochNum);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryEpochSubmissionsRequest>, I>>(
      base?: I,
    ): QueryEpochSubmissionsRequest {
      return QueryEpochSubmissionsRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryEpochSubmissionsRequest>, I>>(
      object: I,
    ): QueryEpochSubmissionsRequest {
      const message = createBaseQueryEpochSubmissionsRequest();
      message.epochNum = object.epochNum ?? 0;
      return message;
    },
  };

function createBaseQueryEpochSubmissionsResponse(): QueryEpochSubmissionsResponse {
  return { keys: [] };
}

export const QueryEpochSubmissionsResponse: MessageFns<QueryEpochSubmissionsResponse> =
  {
    encode(
      message: QueryEpochSubmissionsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.keys) {
        SubmissionKeyResponse.encode(v!, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryEpochSubmissionsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryEpochSubmissionsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.keys.push(
              SubmissionKeyResponse.decode(reader, reader.uint32()),
            );
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryEpochSubmissionsResponse {
      return {
        keys: globalThis.Array.isArray(object?.keys)
          ? object.keys.map((e: any) => SubmissionKeyResponse.fromJSON(e))
          : [],
      };
    },

    toJSON(message: QueryEpochSubmissionsResponse): unknown {
      const obj: any = {};
      if (message.keys?.length) {
        obj.keys = message.keys.map((e) => SubmissionKeyResponse.toJSON(e));
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryEpochSubmissionsResponse>, I>>(
      base?: I,
    ): QueryEpochSubmissionsResponse {
      return QueryEpochSubmissionsResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryEpochSubmissionsResponse>, I>>(
      object: I,
    ): QueryEpochSubmissionsResponse {
      const message = createBaseQueryEpochSubmissionsResponse();
      message.keys =
        object.keys?.map((e) => SubmissionKeyResponse.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseBTCCheckpointInfoResponse(): BTCCheckpointInfoResponse {
  return {
    epochNumber: 0,
    bestSubmissionBtcBlockHeight: 0,
    bestSubmissionBtcBlockHash: "",
    bestSubmissionTransactions: [],
    bestSubmissionVigilanteAddressList: [],
  };
}

export const BTCCheckpointInfoResponse: MessageFns<BTCCheckpointInfoResponse> =
  {
    encode(
      message: BTCCheckpointInfoResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.epochNumber !== 0) {
        writer.uint32(8).uint64(message.epochNumber);
      }
      if (message.bestSubmissionBtcBlockHeight !== 0) {
        writer.uint32(16).uint32(message.bestSubmissionBtcBlockHeight);
      }
      if (message.bestSubmissionBtcBlockHash !== "") {
        writer.uint32(26).string(message.bestSubmissionBtcBlockHash);
      }
      for (const v of message.bestSubmissionTransactions) {
        TransactionInfoResponse.encode(v!, writer.uint32(34).fork()).join();
      }
      for (const v of message.bestSubmissionVigilanteAddressList) {
        CheckpointAddressesResponse.encode(v!, writer.uint32(42).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): BTCCheckpointInfoResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseBTCCheckpointInfoResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }

            message.epochNumber = longToNumber(reader.uint64());
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }

            message.bestSubmissionBtcBlockHeight = reader.uint32();
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }

            message.bestSubmissionBtcBlockHash = reader.string();
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }

            message.bestSubmissionTransactions.push(
              TransactionInfoResponse.decode(reader, reader.uint32()),
            );
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }

            message.bestSubmissionVigilanteAddressList.push(
              CheckpointAddressesResponse.decode(reader, reader.uint32()),
            );
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): BTCCheckpointInfoResponse {
      return {
        epochNumber: isSet(object.epochNumber)
          ? globalThis.Number(object.epochNumber)
          : 0,
        bestSubmissionBtcBlockHeight: isSet(object.bestSubmissionBtcBlockHeight)
          ? globalThis.Number(object.bestSubmissionBtcBlockHeight)
          : 0,
        bestSubmissionBtcBlockHash: isSet(object.bestSubmissionBtcBlockHash)
          ? globalThis.String(object.bestSubmissionBtcBlockHash)
          : "",
        bestSubmissionTransactions: globalThis.Array.isArray(
          object?.bestSubmissionTransactions,
        )
          ? object.bestSubmissionTransactions.map((e: any) =>
              TransactionInfoResponse.fromJSON(e),
            )
          : [],
        bestSubmissionVigilanteAddressList: globalThis.Array.isArray(
          object?.bestSubmissionVigilanteAddressList,
        )
          ? object.bestSubmissionVigilanteAddressList.map((e: any) =>
              CheckpointAddressesResponse.fromJSON(e),
            )
          : [],
      };
    },

    toJSON(message: BTCCheckpointInfoResponse): unknown {
      const obj: any = {};
      if (message.epochNumber !== 0) {
        obj.epochNumber = Math.round(message.epochNumber);
      }
      if (message.bestSubmissionBtcBlockHeight !== 0) {
        obj.bestSubmissionBtcBlockHeight = Math.round(
          message.bestSubmissionBtcBlockHeight,
        );
      }
      if (message.bestSubmissionBtcBlockHash !== "") {
        obj.bestSubmissionBtcBlockHash = message.bestSubmissionBtcBlockHash;
      }
      if (message.bestSubmissionTransactions?.length) {
        obj.bestSubmissionTransactions = message.bestSubmissionTransactions.map(
          (e) => TransactionInfoResponse.toJSON(e),
        );
      }
      if (message.bestSubmissionVigilanteAddressList?.length) {
        obj.bestSubmissionVigilanteAddressList =
          message.bestSubmissionVigilanteAddressList.map((e) =>
            CheckpointAddressesResponse.toJSON(e),
          );
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<BTCCheckpointInfoResponse>, I>>(
      base?: I,
    ): BTCCheckpointInfoResponse {
      return BTCCheckpointInfoResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<BTCCheckpointInfoResponse>, I>>(
      object: I,
    ): BTCCheckpointInfoResponse {
      const message = createBaseBTCCheckpointInfoResponse();
      message.epochNumber = object.epochNumber ?? 0;
      message.bestSubmissionBtcBlockHeight =
        object.bestSubmissionBtcBlockHeight ?? 0;
      message.bestSubmissionBtcBlockHash =
        object.bestSubmissionBtcBlockHash ?? "";
      message.bestSubmissionTransactions =
        object.bestSubmissionTransactions?.map((e) =>
          TransactionInfoResponse.fromPartial(e),
        ) || [];
      message.bestSubmissionVigilanteAddressList =
        object.bestSubmissionVigilanteAddressList?.map((e) =>
          CheckpointAddressesResponse.fromPartial(e),
        ) || [];
      return message;
    },
  };

function createBaseTransactionInfoResponse(): TransactionInfoResponse {
  return { index: 0, hash: "", transaction: "", proof: "" };
}

export const TransactionInfoResponse: MessageFns<TransactionInfoResponse> = {
  encode(
    message: TransactionInfoResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).uint32(message.index);
    }
    if (message.hash !== "") {
      writer.uint32(18).string(message.hash);
    }
    if (message.transaction !== "") {
      writer.uint32(26).string(message.transaction);
    }
    if (message.proof !== "") {
      writer.uint32(34).string(message.proof);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): TransactionInfoResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transaction = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.proof = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionInfoResponse {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      transaction: isSet(object.transaction)
        ? globalThis.String(object.transaction)
        : "",
      proof: isSet(object.proof) ? globalThis.String(object.proof) : "",
    };
  },

  toJSON(message: TransactionInfoResponse): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.transaction !== "") {
      obj.transaction = message.transaction;
    }
    if (message.proof !== "") {
      obj.proof = message.proof;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionInfoResponse>, I>>(
    base?: I,
  ): TransactionInfoResponse {
    return TransactionInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionInfoResponse>, I>>(
    object: I,
  ): TransactionInfoResponse {
    const message = createBaseTransactionInfoResponse();
    message.index = object.index ?? 0;
    message.hash = object.hash ?? "";
    message.transaction = object.transaction ?? "";
    message.proof = object.proof ?? "";
    return message;
  },
};

function createBaseCheckpointAddressesResponse(): CheckpointAddressesResponse {
  return { submitter: "", reporter: "" };
}

export const CheckpointAddressesResponse: MessageFns<CheckpointAddressesResponse> =
  {
    encode(
      message: CheckpointAddressesResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.submitter !== "") {
        writer.uint32(10).string(message.submitter);
      }
      if (message.reporter !== "") {
        writer.uint32(18).string(message.reporter);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CheckpointAddressesResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCheckpointAddressesResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.submitter = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.reporter = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CheckpointAddressesResponse {
      return {
        submitter: isSet(object.submitter)
          ? globalThis.String(object.submitter)
          : "",
        reporter: isSet(object.reporter)
          ? globalThis.String(object.reporter)
          : "",
      };
    },

    toJSON(message: CheckpointAddressesResponse): unknown {
      const obj: any = {};
      if (message.submitter !== "") {
        obj.submitter = message.submitter;
      }
      if (message.reporter !== "") {
        obj.reporter = message.reporter;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<CheckpointAddressesResponse>, I>>(
      base?: I,
    ): CheckpointAddressesResponse {
      return CheckpointAddressesResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<CheckpointAddressesResponse>, I>>(
      object: I,
    ): CheckpointAddressesResponse {
      const message = createBaseCheckpointAddressesResponse();
      message.submitter = object.submitter ?? "";
      message.reporter = object.reporter ?? "";
      return message;
    },
  };

function createBaseSubmissionKeyResponse(): SubmissionKeyResponse {
  return {
    firstTxBlockHash: "",
    firstTxIndex: 0,
    secondTxBlockHash: "",
    secondTxIndex: 0,
  };
}

export const SubmissionKeyResponse: MessageFns<SubmissionKeyResponse> = {
  encode(
    message: SubmissionKeyResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.firstTxBlockHash !== "") {
      writer.uint32(10).string(message.firstTxBlockHash);
    }
    if (message.firstTxIndex !== 0) {
      writer.uint32(16).uint32(message.firstTxIndex);
    }
    if (message.secondTxBlockHash !== "") {
      writer.uint32(26).string(message.secondTxBlockHash);
    }
    if (message.secondTxIndex !== 0) {
      writer.uint32(32).uint32(message.secondTxIndex);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SubmissionKeyResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmissionKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.firstTxBlockHash = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.firstTxIndex = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.secondTxBlockHash = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.secondTxIndex = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmissionKeyResponse {
    return {
      firstTxBlockHash: isSet(object.firstTxBlockHash)
        ? globalThis.String(object.firstTxBlockHash)
        : "",
      firstTxIndex: isSet(object.firstTxIndex)
        ? globalThis.Number(object.firstTxIndex)
        : 0,
      secondTxBlockHash: isSet(object.secondTxBlockHash)
        ? globalThis.String(object.secondTxBlockHash)
        : "",
      secondTxIndex: isSet(object.secondTxIndex)
        ? globalThis.Number(object.secondTxIndex)
        : 0,
    };
  },

  toJSON(message: SubmissionKeyResponse): unknown {
    const obj: any = {};
    if (message.firstTxBlockHash !== "") {
      obj.firstTxBlockHash = message.firstTxBlockHash;
    }
    if (message.firstTxIndex !== 0) {
      obj.firstTxIndex = Math.round(message.firstTxIndex);
    }
    if (message.secondTxBlockHash !== "") {
      obj.secondTxBlockHash = message.secondTxBlockHash;
    }
    if (message.secondTxIndex !== 0) {
      obj.secondTxIndex = Math.round(message.secondTxIndex);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmissionKeyResponse>, I>>(
    base?: I,
  ): SubmissionKeyResponse {
    return SubmissionKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmissionKeyResponse>, I>>(
    object: I,
  ): SubmissionKeyResponse {
    const message = createBaseSubmissionKeyResponse();
    message.firstTxBlockHash = object.firstTxBlockHash ?? "";
    message.firstTxIndex = object.firstTxIndex ?? 0;
    message.secondTxBlockHash = object.secondTxBlockHash ?? "";
    message.secondTxIndex = object.secondTxIndex ?? 0;
    return message;
  },
};

/** Query defines the gRPC querier service. */
export interface Query {
  /** Parameters queries the parameters of the module. */
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
  /** BtcCheckpointInfo returns checkpoint info for a given epoch */
  BtcCheckpointInfo(
    request: QueryBtcCheckpointInfoRequest,
  ): Promise<QueryBtcCheckpointInfoResponse>;
  /** BtcCheckpointsInfo returns checkpoint info for a range of epochs */
  BtcCheckpointsInfo(
    request: QueryBtcCheckpointsInfoRequest,
  ): Promise<QueryBtcCheckpointsInfoResponse>;
  /** EpochSubmissions returns all submissions for a given epoch */
  EpochSubmissions(
    request: QueryEpochSubmissionsRequest,
  ): Promise<QueryEpochSubmissionsResponse>;
}

export const QueryServiceName = "babylon.btccheckpoint.v1.Query";
export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceName;
    this.rpc = rpc;
    this.Params = this.Params.bind(this);
    this.BtcCheckpointInfo = this.BtcCheckpointInfo.bind(this);
    this.BtcCheckpointsInfo = this.BtcCheckpointsInfo.bind(this);
    this.EpochSubmissions = this.EpochSubmissions.bind(this);
  }
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse> {
    const data = QueryParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Params", data);
    return promise.then((data) =>
      QueryParamsResponse.decode(new BinaryReader(data)),
    );
  }

  BtcCheckpointInfo(
    request: QueryBtcCheckpointInfoRequest,
  ): Promise<QueryBtcCheckpointInfoResponse> {
    const data = QueryBtcCheckpointInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BtcCheckpointInfo", data);
    return promise.then((data) =>
      QueryBtcCheckpointInfoResponse.decode(new BinaryReader(data)),
    );
  }

  BtcCheckpointsInfo(
    request: QueryBtcCheckpointsInfoRequest,
  ): Promise<QueryBtcCheckpointsInfoResponse> {
    const data = QueryBtcCheckpointsInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BtcCheckpointsInfo", data);
    return promise.then((data) =>
      QueryBtcCheckpointsInfoResponse.decode(new BinaryReader(data)),
    );
  }

  EpochSubmissions(
    request: QueryEpochSubmissionsRequest,
  ): Promise<QueryEpochSubmissionsResponse> {
    const data = QueryEpochSubmissionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EpochSubmissions", data);
    return promise.then((data) =>
      QueryEpochSubmissionsResponse.decode(new BinaryReader(data)),
    );
  }
}

interface Rpc {
  request(
    service: string,
    method: string,
    data: Uint8Array,
  ): Promise<Uint8Array>;
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
